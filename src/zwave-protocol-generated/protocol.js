/*
 * Copyright (c) 2017 Internet of Protocols Alliance (IOPA)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 /*
 * ZWAVE CUSTOM COMMAND CLASSES PROTOCOL
 *
 * This file was system generated for IOPA Zwave (iopa-io/iopa-zwave)
 * based on the Z-Wave Public Specification at Z-WavePublic/libzwaveip
 * under the Apache License above.
 * 
 * Do not edit directly, but make a pull request instead.
 *
 */

const BufferStreamFactory = require('./bufferstream').BufferStreamFactory,
	BufferStream = new BufferStreamFactory();

const helpers = require('./helpers').helpers;

const COMMAND_CLASS = { 
	NO_OPERATION: { id: 0x00 },
	ZWAVE_CMD_CLASS: { id: 0x01,
		ACCEPT_LOST: 0x17,
		ASSIGN_ID: 0x03,
		ASSIGN_RETURN_ROUTE: 0x0c,
		ASSIGN_RETURN_ROUTE_PRIORITY: 0x24,
		ASSIGN_SUC_RETURN_ROUTE: 0x14,
		ASSIGN_SUC_RETURN_ROUTE_PRIORITY: 0x25,
		AUTOMATIC_CONTROLLER_UPDATE_START: 0x10,
		COMMAND_COMPLETE: 0x07,
		EXCLUDE_REQUEST: 0x23,
		FIND_NODES_IN_RANGE: 0x04,
		GET_NODES_IN_RANGE: 0x05,
		LOST: 0x16,
		NEW_NODE_REGISTERED: 0x0d,
		NEW_RANGE_REGISTERED: 0x0e,
		NODES_EXIST: 0x1f,
		NODES_EXIST_REPLY: 0x20,
		NODE_INFO: 0x01,
		NODE_RANGE_INFO: 0x06,
		NOP: 0x00,
		NOP_POWER: 0x18,
		REQUEST_NODE_INFO: 0x02,
		RESERVED_IDS: 0x1a,
		RESERVE_NODE_IDS: 0x19,
		SET_NWI_MODE: 0x22,
		SET_SUC: 0x12,
		SET_SUC_ACK: 0x13,
		STATIC_ROUTE_REQUEST: 0x15,
		SUC_NODE_ID: 0x11,
		TRANSFER_END: 0x0b,
		TRANSFER_NEW_PRIMARY_COMPLETE: 0x0f,
		TRANSFER_NODE_INFO: 0x09,
		TRANSFER_PRESENTATION: 0x08,
		TRANSFER_RANGE_INFO: 0x0a },
	ZENSOR_NET: { id: 0x02,
		BIND_ACCEPT: 0x02,
		BIND_COMPLETE: 0x03,
		BIND_REQUEST: 0x01 },
	BASIC: { id: 0x20,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	BASICV2: { id: 0x20,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	CONTROLLER_REPLICATION: { id: 0x21,
		CTRL_REPLICATION_TRANSFER_GROUP: 0x31,
		CTRL_REPLICATION_TRANSFER_GROUP_NAME: 0x32,
		CTRL_REPLICATION_TRANSFER_SCENE: 0x33,
		CTRL_REPLICATION_TRANSFER_SCENE_NAME: 0x34 },
	APPLICATION_STATUS: { id: 0x22,
		APPLICATION_BUSY: 0x01,
		APPLICATION_REJECTED_REQUEST: 0x02 },
	ZIP: { id: 0x23,
		COMMAND_ZIP_PACKET: 0x02 },
	ZIPV2: { id: 0x23,
		COMMAND_ZIP_PACKET: 0x02 },
	ZIPV3: { id: 0x23,
		COMMAND_ZIP_PACKET: 0x02 },
	SECURITY_PANEL_MODE: { id: 0x24,
		GET: 0x03,
		REPORT: 0x04,
		SET: 0x05,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	SWITCH_BINARY: { id: 0x25,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	SWITCH_BINARYV2: { id: 0x25,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	SWITCH_MULTILEVEL: { id: 0x26,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		START_LEVEL_CHANGE: 0x04,
		STOP_LEVEL_CHANGE: 0x05 },
	SWITCH_MULTILEVELV2: { id: 0x26,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		START_LEVEL_CHANGE: 0x04,
		STOP_LEVEL_CHANGE: 0x05 },
	SWITCH_MULTILEVELV3: { id: 0x26,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		START_LEVEL_CHANGE: 0x04,
		STOP_LEVEL_CHANGE: 0x05,
		SUPPORTED_GET: 0x06,
		SUPPORTED_REPORT: 0x07 },
	SWITCH_MULTILEVELV4: { id: 0x26,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		START_LEVEL_CHANGE: 0x04,
		STOP_LEVEL_CHANGE: 0x05,
		SUPPORTED_GET: 0x06,
		SUPPORTED_REPORT: 0x07 },
	SWITCH_ALL: { id: 0x27,
		GET: 0x02,
		OFF: 0x05,
		ON: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	SWITCH_TOGGLE_BINARY: { id: 0x28,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	SWITCH_TOGGLE_MULTILEVEL: { id: 0x29,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		START_LEVEL_CHANGE: 0x04,
		STOP_LEVEL_CHANGE: 0x05 },
	CHIMNEY_FAN: { id: 0x2a,
		ALARM_LOG_GET: 0x20,
		ALARM_LOG_REPORT: 0x21,
		ALARM_LOG_SET: 0x1f,
		ALARM_STATUS_GET: 0x23,
		ALARM_STATUS_REPORT: 0x24,
		ALARM_STATUS_SET: 0x22,
		ALARM_TEMP_GET: 0x0e,
		ALARM_TEMP_REPORT: 0x0f,
		ALARM_TEMP_SET: 0x0d,
		BOOST_TIME_GET: 0x11,
		BOOST_TIME_REPORT: 0x12,
		BOOST_TIME_SET: 0x10,
		DEFAULT_SET: 0x28,
		MIN_SPEED_GET: 0x26,
		MIN_SPEED_REPORT: 0x27,
		MIN_SPEED_SET: 0x25,
		MODE_GET: 0x17,
		MODE_REPORT: 0x18,
		MODE_SET: 0x16,
		SETUP_GET: 0x1a,
		SETUP_REPORT: 0x1b,
		SETUP_SET: 0x19,
		SPEED_GET: 0x05,
		SPEED_REPORT: 0x06,
		SPEED_SET: 0x04,
		START_TEMP_GET: 0x08,
		START_TEMP_REPORT: 0x09,
		START_TEMP_SET: 0x07,
		STATE_GET: 0x02,
		STATE_REPORT: 0x03,
		STATE_SET: 0x01,
		STATUS_GET: 0x1d,
		STATUS_REPORT: 0x1e,
		STOP_TEMP_GET: 0x0b,
		STOP_TEMP_REPORT: 0x0c,
		STOP_TEMP_SET: 0x0a,
		STOP_TIME_GET: 0x14,
		STOP_TIME_REPORT: 0x15,
		STOP_TIME_SET: 0x13 },
	SCENE_ACTIVATION: { id: 0x2b,
		SET: 0x01 },
	SCENE_ACTUATOR_CONF: { id: 0x2c,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	SCENE_CONTROLLER_CONF: { id: 0x2d,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	SECURITY_PANEL_ZONE: { id: 0x2e,
		NUMBER_SUPPORTED_GET: 0x01,
		STATE_GET: 0x05,
		STATE_REPORT: 0x06,
		SUPPORTED_REPORT: 0x02,
		TYPE_GET: 0x03,
		TYPE_REPORT: 0x04 },
	SECURITY_PANEL_ZONE_SENSOR: { id: 0x2f,
		INSTALLED_GET: 0x01,
		SECURITY_PANEL_ZONE_SENSOR_INSTALLED_REPORT: 0x02,
		STATE_GET: 0x05,
		STATE_REPORT: 0x06,
		TYPE_GET: 0x03,
		TYPE_REPORT: 0x04 },
	SENSOR_BINARY: { id: 0x30,
		GET: 0x02,
		REPORT: 0x03 },
	SENSOR_BINARYV2: { id: 0x30,
		GET: 0x02,
		REPORT: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SENSOR_REPORT: 0x04 },
	SENSOR_MULTILEVEL: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05 },
	SENSOR_MULTILEVELV10: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	SENSOR_MULTILEVELV2: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05 },
	SENSOR_MULTILEVELV3: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05 },
	SENSOR_MULTILEVELV4: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05 },
	SENSOR_MULTILEVELV5: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	SENSOR_MULTILEVELV6: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	SENSOR_MULTILEVELV7: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	SENSOR_MULTILEVELV8: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	SENSOR_MULTILEVELV9: { id: 0x31,
		GET: 0x04,
		REPORT: 0x05,
		SUPPORTED_GET_SCALE: 0x03,
		SUPPORTED_GET_SENSOR: 0x01,
		SUPPORTED_SCALE_REPORT: 0x06,
		SUPPORTED_SENSOR_REPORT: 0x02 },
	METER: { id: 0x32,
		GET: 0x01,
		REPORT: 0x02 },
	METERV2: { id: 0x32,
		GET: 0x01,
		REPORT: 0x02,
		RESET: 0x05,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	METERV3: { id: 0x32,
		GET: 0x01,
		REPORT: 0x02,
		RESET: 0x05,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	METERV4: { id: 0x32,
		GET: 0x01,
		REPORT: 0x02,
		RESET: 0x05,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	SWITCH_COLOR: { id: 0x33,
		GET: 0x03,
		REPORT: 0x04,
		SET: 0x05,
		START_LEVEL_CHANGE: 0x06,
		STOP_LEVEL_CHANGE: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	SWITCH_COLORV2: { id: 0x33,
		GET: 0x03,
		REPORT: 0x04,
		SET: 0x05,
		START_LEVEL_CHANGE: 0x06,
		STOP_LEVEL_CHANGE: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	SWITCH_COLORV3: { id: 0x33,
		GET: 0x03,
		REPORT: 0x04,
		SET: 0x05,
		START_LEVEL_CHANGE: 0x06,
		STOP_LEVEL_CHANGE: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	NETWORK_MANAGEMENT_INCLUSION: { id: 0x34,
		FAILED_NODE_REMOVE: 0x07,
		FAILED_NODE_REMOVE_STATUS: 0x08,
		FAILED_NODE_REPLACE: 0x09,
		FAILED_NODE_REPLACE_STATUS: 0x0a,
		NODE_ADD: 0x01,
		NODE_ADD_STATUS: 0x02,
		NODE_NEIGHBOR_UPDATE_REQUEST: 0x0b,
		NODE_NEIGHBOR_UPDATE_STATUS: 0x0c,
		NODE_REMOVE: 0x03,
		NODE_REMOVE_STATUS: 0x04,
		RETURN_ROUTE_ASSIGN: 0x0d,
		RETURN_ROUTE_ASSIGN_COMPLETE: 0x0e,
		RETURN_ROUTE_DELETE: 0x0f,
		RETURN_ROUTE_DELETE_COMPLETE: 0x10 },
	NETWORK_MANAGEMENT_INCLUSIONV2: { id: 0x34,
		FAILED_NODE_REMOVE: 0x07,
		FAILED_NODE_REMOVE_STATUS: 0x08,
		FAILED_NODE_REPLACE: 0x09,
		FAILED_NODE_REPLACE_STATUS: 0x0a,
		NODE_ADD: 0x01,
		NODE_ADD_DSK_REPORT: 0x13,
		NODE_ADD_DSK_SET: 0x14,
		NODE_ADD_KEYS_REPORT: 0x11,
		NODE_ADD_KEYS_SET: 0x12,
		NODE_ADD_STATUS: 0x02,
		NODE_NEIGHBOR_UPDATE_REQUEST: 0x0b,
		NODE_NEIGHBOR_UPDATE_STATUS: 0x0c,
		NODE_REMOVE: 0x03,
		NODE_REMOVE_STATUS: 0x04,
		RETURN_ROUTE_ASSIGN: 0x0d,
		RETURN_ROUTE_ASSIGN_COMPLETE: 0x0e,
		RETURN_ROUTE_DELETE: 0x0f,
		RETURN_ROUTE_DELETE_COMPLETE: 0x10 },
	METER_PULSE: { id: 0x35,
		GET: 0x04,
		REPORT: 0x05 },
	BASIC_TARIFF_INFO: { id: 0x36,
		GET: 0x01,
		REPORT: 0x02 },
	HRV_STATUS: { id: 0x37,
		GET: 0x01,
		REPORT: 0x02,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	THERMOSTAT_HEATING: { id: 0x38,
		MODE_GET: 0x02,
		MODE_REPORT: 0x03,
		MODE_SET: 0x01,
		RELAY_STATUS_GET: 0x09,
		RELAY_STATUS_REPORT: 0x0a,
		SETPOINT_GET: 0x05,
		SETPOINT_REPORT: 0x06,
		SETPOINT_SET: 0x04,
		STATUS_GET: 0x0c,
		STATUS_REPORT: 0x0d,
		STATUS_SET: 0x0b,
		TIMED_OFF_SET: 0x11 },
	HRV_CONTROL: { id: 0x39,
		BYPASS_GET: 0x05,
		BYPASS_REPORT: 0x06,
		BYPASS_SET: 0x04,
		MODE_GET: 0x02,
		MODE_REPORT: 0x03,
		MODE_SET: 0x01,
		MODE_SUPPORTED_GET: 0x0a,
		MODE_SUPPORTED_REPORT: 0x0b,
		VENTILATION_RATE_GET: 0x08,
		VENTILATION_RATE_REPORT: 0x09,
		VENTILATION_RATE_SET: 0x07 },
	DCP_CONFIG: { id: 0x3a,
		DCP_LIST_REMOVE: 0x04,
		DCP_LIST_SET: 0x03,
		DCP_LIST_SUPPORTED_GET: 0x01,
		DCP_LIST_SUPPORTED_REPORT: 0x02 },
	DCP_MONITOR: { id: 0x3b,
		DCP_EVENT_STATUS_GET: 0x03,
		DCP_EVENT_STATUS_REPORT: 0x04,
		DCP_LIST_GET: 0x01,
		DCP_LIST_REPORT: 0x02 },
	METER_TBL_CONFIG: { id: 0x3c,
		METER_TBL_TABLE_POINT_ADM_NO_SET: 0x01 },
	METER_TBL_MONITOR: { id: 0x3d,
		METER_TBL_CURRENT_DATA_GET: 0x0c,
		METER_TBL_CURRENT_DATA_REPORT: 0x0d,
		METER_TBL_HISTORICAL_DATA_GET: 0x0e,
		METER_TBL_HISTORICAL_DATA_REPORT: 0x0f,
		METER_TBL_REPORT: 0x06,
		METER_TBL_STATUS_DATE_GET: 0x0a,
		METER_TBL_STATUS_DEPTH_GET: 0x09,
		METER_TBL_STATUS_REPORT: 0x0b,
		METER_TBL_STATUS_SUPPORTED_GET: 0x07,
		METER_TBL_STATUS_SUPPORTED_REPORT: 0x08,
		METER_TBL_TABLE_CAPABILITY_GET: 0x05,
		METER_TBL_TABLE_ID_GET: 0x03,
		METER_TBL_TABLE_ID_REPORT: 0x04,
		METER_TBL_TABLE_POINT_ADM_NO_GET: 0x01,
		METER_TBL_TABLE_POINT_ADM_NO_REPORT: 0x02 },
	METER_TBL_MONITORV2: { id: 0x3d,
		METER_TBL_CURRENT_DATA_GET: 0x0c,
		METER_TBL_CURRENT_DATA_REPORT: 0x0d,
		METER_TBL_HISTORICAL_DATA_GET: 0x0e,
		METER_TBL_HISTORICAL_DATA_REPORT: 0x0f,
		METER_TBL_REPORT: 0x06,
		METER_TBL_STATUS_DATE_GET: 0x0a,
		METER_TBL_STATUS_DEPTH_GET: 0x09,
		METER_TBL_STATUS_REPORT: 0x0b,
		METER_TBL_STATUS_SUPPORTED_GET: 0x07,
		METER_TBL_STATUS_SUPPORTED_REPORT: 0x08,
		METER_TBL_TABLE_CAPABILITY_GET: 0x05,
		METER_TBL_TABLE_ID_GET: 0x03,
		METER_TBL_TABLE_ID_REPORT: 0x04,
		METER_TBL_TABLE_POINT_ADM_NO_GET: 0x01,
		METER_TBL_TABLE_POINT_ADM_NO_REPORT: 0x02 },
	METER_TBL_PUSH: { id: 0x3e,
		CONFIGURATION_GET: 0x02,
		CONFIGURATION_REPORT: 0x03,
		CONFIGURATION_SET: 0x01 },
	PREPAYMENT: { id: 0x3f,
		BALANCE_GET: 0x01,
		BALANCE_REPORT: 0x02,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	THERMOSTAT_MODE: { id: 0x40,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_MODEV2: { id: 0x40,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_MODEV3: { id: 0x40,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	PREPAYMENT_ENCAPSULATION: { id: 0x41,
		ENCAPSULATION: 0x01 },
	THERMOSTAT_OPERATING_STATE: { id: 0x42,
		GET: 0x02,
		REPORT: 0x03 },
	THERMOSTAT_OPERATING_STATEV2: { id: 0x42,
		GET: 0x02,
		LOGGING_GET: 0x05,
		LOGGING_REPORT: 0x06,
		LOGGING_SUPPORTED_GET: 0x01,
		REPORT: 0x03,
		THERMOSTAT_OPERATING_LOGGING_SUPPORTED_REPORT: 0x04 },
	THERMOSTAT_SETPOINT: { id: 0x43,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_SETPOINTV2: { id: 0x43,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_SETPOINTV3: { id: 0x43,
		CAPABILITIES_GET: 0x09,
		CAPABILITIES_REPORT: 0x0a,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_FAN_MODE: { id: 0x44,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_FAN_MODEV2: { id: 0x44,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_FAN_MODEV3: { id: 0x44,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_FAN_MODEV4: { id: 0x44,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	THERMOSTAT_FAN_STATE: { id: 0x45,
		GET: 0x02,
		REPORT: 0x03 },
	THERMOSTAT_FAN_STATEV2: { id: 0x45,
		GET: 0x02,
		REPORT: 0x03 },
	CLIMATE_CONTROL_SCHEDULE: { id: 0x46,
		SCHEDULE_CHANGED_GET: 0x04,
		SCHEDULE_CHANGED_REPORT: 0x05,
		SCHEDULE_GET: 0x02,
		SCHEDULE_OVERRIDE_GET: 0x07,
		SCHEDULE_OVERRIDE_REPORT: 0x08,
		SCHEDULE_OVERRIDE_SET: 0x06,
		SCHEDULE_REPORT: 0x03,
		SCHEDULE_SET: 0x01 },
	THERMOSTAT_SETBACK: { id: 0x47,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	RATE_TBL_CONFIG: { id: 0x48,
		RATE_TBL_REMOVE: 0x02,
		RATE_TBL_SET: 0x01 },
	RATE_TBL_MONITOR: { id: 0x49,
		RATE_TBL_ACTIVE_RATE_GET: 0x05,
		RATE_TBL_ACTIVE_RATE_REPORT: 0x06,
		RATE_TBL_CURRENT_DATA_GET: 0x07,
		RATE_TBL_CURRENT_DATA_REPORT: 0x08,
		RATE_TBL_GET: 0x03,
		RATE_TBL_HISTORICAL_DATA_GET: 0x09,
		RATE_TBL_HISTORICAL_DATA_REPORT: 0x0a,
		RATE_TBL_REPORT: 0x04,
		RATE_TBL_SUPPORTED_GET: 0x01,
		RATE_TBL_SUPPORTED_REPORT: 0x02 },
	TARIFF_CONFIG: { id: 0x4a,
		TARIFF_TBL_REMOVE: 0x03,
		TARIFF_TBL_SET: 0x02,
		TARIFF_TBL_SUPPLIER_SET: 0x01 },
	TARIFF_TBL_MONITOR: { id: 0x4b,
		TARIFF_TBL_COST_GET: 0x05,
		TARIFF_TBL_COST_REPORT: 0x06,
		TARIFF_TBL_GET: 0x03,
		TARIFF_TBL_REPORT: 0x04,
		TARIFF_TBL_SUPPLIER_GET: 0x01,
		TARIFF_TBL_SUPPLIER_REPORT: 0x02 },
	DOOR_LOCK_LOGGING: { id: 0x4c,
		RECORDS_SUPPORTED_GET: 0x01,
		RECORDS_SUPPORTED_REPORT: 0x02,
		RECORD_GET: 0x03,
		RECORD_REPORT: 0x04 },
	NETWORK_MANAGEMENT_BASIC: { id: 0x4d,
		DEFAULT_SET: 0x06,
		DEFAULT_SET_COMPLETE: 0x07,
		LEARN_MODE_SET: 0x01,
		LEARN_MODE_SET_STATUS: 0x02,
		NETWORK_UPDATE_REQUEST: 0x03,
		NETWORK_UPDATE_REQUEST_STATUS: 0x04,
		NODE_INFORMATION_SEND: 0x05 },
	NETWORK_MANAGEMENT_BASICV2: { id: 0x4d,
		DEFAULT_SET: 0x06,
		DEFAULT_SET_COMPLETE: 0x07,
		DSK_GET: 0x08,
		DSK_REPORT: 0x09,
		LEARN_MODE_SET: 0x01,
		LEARN_MODE_SET_STATUS: 0x02,
		NETWORK_UPDATE_REQUEST: 0x03,
		NETWORK_UPDATE_REQUEST_STATUS: 0x04,
		NODE_INFORMATION_SEND: 0x05 },
	SCHEDULE_ENTRY_LOCK: { id: 0x4e,
		ENABLE_ALL_SET: 0x02,
		ENABLE_SET: 0x01,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_GET: 0x09,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_REPORT: 0x0a,
		WEEK_DAY_GET: 0x04,
		WEEK_DAY_REPORT: 0x05,
		WEEK_DAY_SET: 0x03,
		YEAR_DAY_GET: 0x07,
		YEAR_DAY_REPORT: 0x08,
		YEAR_DAY_SET: 0x06 },
	SCHEDULE_ENTRY_LOCKV2: { id: 0x4e,
		ENABLE_ALL_SET: 0x02,
		ENABLE_SET: 0x01,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_GET: 0x09,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_REPORT: 0x0a,
		TIME_OFFSET_GET: 0x0b,
		TIME_OFFSET_REPORT: 0x0c,
		TIME_OFFSET_SET: 0x0d,
		WEEK_DAY_GET: 0x04,
		WEEK_DAY_REPORT: 0x05,
		WEEK_DAY_SET: 0x03,
		YEAR_DAY_GET: 0x07,
		YEAR_DAY_REPORT: 0x08,
		YEAR_DAY_SET: 0x06 },
	SCHEDULE_ENTRY_LOCKV3: { id: 0x4e,
		DAILY_REPEATING_GET: 0x0e,
		DAILY_REPEATING_REPORT: 0x0f,
		DAILY_REPEATING_SET: 0x10,
		ENABLE_ALL_SET: 0x02,
		ENABLE_SET: 0x01,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_GET: 0x09,
		SCHEDULE_ENTRY_TYPE_SUPPORTED_REPORT: 0x0a,
		TIME_OFFSET_GET: 0x0b,
		TIME_OFFSET_REPORT: 0x0c,
		TIME_OFFSET_SET: 0x0d,
		WEEK_DAY_GET: 0x04,
		WEEK_DAY_REPORT: 0x05,
		WEEK_DAY_SET: 0x03,
		YEAR_DAY_GET: 0x07,
		YEAR_DAY_REPORT: 0x08,
		YEAR_DAY_SET: 0x06 },
	ZIP_6LOWPAN: { id: 0x4f,
		LOWPAN_FIRST_FRAGMENT: 0xc0,
		LOWPAN_SUBSEQUENT_FRAGMENT: 0xe0 },
	BASIC_WINDOW_COVERING: { id: 0x50,
		START_LEVEL_CHANGE: 0x01,
		STOP_LEVEL_CHANGE: 0x02 },
	MTP_WINDOW_COVERING: { id: 0x51,
		MOVE_TO_POSITION_GET: 0x02,
		MOVE_TO_POSITION_REPORT: 0x03,
		MOVE_TO_POSITION_SET: 0x01 },
	NETWORK_MANAGEMENT_PROXY: { id: 0x52,
		NODE_INFO_CACHED_GET: 0x03,
		NODE_INFO_CACHED_REPORT: 0x04,
		NODE_LIST_GET: 0x01,
		NODE_LIST_REPORT: 0x02 },
	NETWORK_MANAGEMENT_PROXYV2: { id: 0x52,
		NODE_INFO_CACHED_GET: 0x03,
		NODE_INFO_CACHED_REPORT: 0x04,
		NODE_LIST_GET: 0x01,
		NODE_LIST_REPORT: 0x02 },
	SCHEDULE: { id: 0x53,
		COMMAND_SCHEDULE_GET: 0x04,
		COMMAND_SCHEDULE_REPORT: 0x05,
		COMMAND_SCHEDULE_SET: 0x03,
		REMOVE: 0x06,
		STATE_GET: 0x08,
		STATE_REPORT: 0x09,
		STATE_SET: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	SCHEDULEV2: { id: 0x53,
		COMMAND_SCHEDULE_GET: 0x04,
		COMMAND_SCHEDULE_REPORT: 0x05,
		COMMAND_SCHEDULE_SET: 0x03,
		REMOVE: 0x06,
		STATE_GET: 0x08,
		STATE_REPORT: 0x09,
		STATE_SET: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	SCHEDULEV3: { id: 0x53,
		COMMAND_SCHEDULE_GET: 0x04,
		COMMAND_SCHEDULE_REPORT: 0x05,
		COMMAND_SCHEDULE_SET: 0x03,
		REMOVE: 0x06,
		STATE_GET: 0x08,
		STATE_REPORT: 0x09,
		STATE_SET: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	NETWORK_MANAGEMENT_PRIMARY: { id: 0x54,
		CONTROLLER_CHANGE: 0x01,
		CONTROLLER_CHANGE_STATUS: 0x02 },
	TRANSPORT_SERVICE: { id: 0x55,
		COMMAND_FIRST_FRAGMENT: 0xc0,
		COMMAND_SUBSEQUENT_FRAGMENT: 0xe0 },
	TRANSPORT_SERVICEV2: { id: 0x55,
		COMMAND_FIRST_SEGMENT: 0xc0,
		COMMAND_SEGMENT_COMPLETE: 0xe8,
		COMMAND_SEGMENT_REQUEST: 0xc8,
		COMMAND_SEGMENT_WAIT: 0xf0,
		COMMAND_SUBSEQUENT_SEGMENT: 0xe0 },
	CRC_16_ENCAP: { id: 0x56,
		CRC_16_ENCAP: 0x01 },
	APPLICATION_CAPABILITY: { id: 0x57,
		COMMAND_COMMAND_CLASS_NOT_SUPPORTED: 0x01 },
	ZIP_ND: { id: 0x58,
		ZIP_INV_NODE_SOLICITATION: 0x04,
		ZIP_NODE_ADVERTISEMENT: 0x01,
		ZIP_NODE_SOLICITATION: 0x03 },
	ASSOCIATION_GRP_INFO: { id: 0x59,
		ASSOCIATION_GROUP_COMMAND_LIST_GET: 0x05,
		ASSOCIATION_GROUP_COMMAND_LIST_REPORT: 0x06,
		ASSOCIATION_GROUP_INFO_GET: 0x03,
		ASSOCIATION_GROUP_INFO_REPORT: 0x04,
		ASSOCIATION_GROUP_NAME_GET: 0x01,
		ASSOCIATION_GROUP_NAME_REPORT: 0x02 },
	ASSOCIATION_GRP_INFOV2: { id: 0x59,
		ASSOCIATION_GROUP_COMMAND_LIST_GET: 0x05,
		ASSOCIATION_GROUP_COMMAND_LIST_REPORT: 0x06,
		ASSOCIATION_GROUP_INFO_GET: 0x03,
		ASSOCIATION_GROUP_INFO_REPORT: 0x04,
		ASSOCIATION_GROUP_NAME_GET: 0x01,
		ASSOCIATION_GROUP_NAME_REPORT: 0x02 },
	ASSOCIATION_GRP_INFOV3: { id: 0x59,
		ASSOCIATION_GROUP_COMMAND_LIST_GET: 0x05,
		ASSOCIATION_GROUP_COMMAND_LIST_REPORT: 0x06,
		ASSOCIATION_GROUP_INFO_GET: 0x03,
		ASSOCIATION_GROUP_INFO_REPORT: 0x04,
		ASSOCIATION_GROUP_NAME_GET: 0x01,
		ASSOCIATION_GROUP_NAME_REPORT: 0x02 },
	DEVICE_RESET_LOCALLY: { id: 0x5a,
		NOTIFICATION: 0x01 },
	CENTRAL_SCENE: { id: 0x5b,
		NOTIFICATION: 0x03,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	CENTRAL_SCENEV2: { id: 0x5b,
		NOTIFICATION: 0x03,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	CENTRAL_SCENEV3: { id: 0x5b,
		CONFIGURATION_GET: 0x05,
		CONFIGURATION_REPORT: 0x06,
		CONFIGURATION_SET: 0x04,
		NOTIFICATION: 0x03,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	IP_ASSOCIATION: { id: 0x5c,
		GET: 0x02,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	ANTITHEFT: { id: 0x5d,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	ANTITHEFTV2: { id: 0x5d,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	ZWAVEPLUS_INFO: { id: 0x5e,
		GET: 0x01,
		REPORT: 0x02 },
	ZWAVEPLUS_INFOV2: { id: 0x5e,
		GET: 0x01,
		REPORT: 0x02 },
	ZIP_GATEWAY: { id: 0x5f,
		COMMAND_APPLICATION_NODE_INFO_GET: 0x0c,
		COMMAND_APPLICATION_NODE_INFO_REPORT: 0x0d,
		COMMAND_APPLICATION_NODE_INFO_SET: 0x0b,
		GATEWAY_LOCK_SET: 0x07,
		GATEWAY_MODE_GET: 0x02,
		GATEWAY_MODE_REPORT: 0x03,
		GATEWAY_MODE_SET: 0x01,
		GATEWAY_PEER_GET: 0x05,
		GATEWAY_PEER_REPORT: 0x06,
		GATEWAY_PEER_SET: 0x04,
		UNSOLICITED_DESTINATION_GET: 0x09,
		UNSOLICITED_DESTINATION_REPORT: 0x0a,
		UNSOLICITED_DESTINATION_SET: 0x08 },
	MULTI_INSTANCE: { id: 0x60,
		ENCAP: 0x06,
		GET: 0x04,
		REPORT: 0x05 },
	MULTI_CHANNEL: { id: 0x60,
		CAPABILITY_GET: 0x09,
		CAPABILITY_REPORT: 0x0a,
		ENCAP: 0x0d,
		END_POINT_FIND: 0x0b,
		END_POINT_FIND_REPORT: 0x0c,
		END_POINT_GET: 0x07,
		END_POINT_REPORT: 0x08,
		MULTI_INSTANCE_CMD_ENCAP: 0x06,
		MULTI_INSTANCE_GET: 0x04,
		MULTI_INSTANCE_REPORT: 0x05 },
	MULTI_CHANNELV3: { id: 0x60,
		CAPABILITY_GET: 0x09,
		CAPABILITY_REPORT: 0x0a,
		ENCAP: 0x0d,
		END_POINT_FIND: 0x0b,
		END_POINT_FIND_REPORT: 0x0c,
		END_POINT_GET: 0x07,
		END_POINT_REPORT: 0x08,
		MULTI_INSTANCE_CMD_ENCAP: 0x06,
		MULTI_INSTANCE_GET: 0x04,
		MULTI_INSTANCE_REPORT: 0x05 },
	MULTI_CHANNELV4: { id: 0x60,
		AGGREGATED_MEMBERS_GET: 0x0e,
		AGGREGATED_MEMBERS_REPORT: 0x0f,
		CAPABILITY_GET: 0x09,
		CAPABILITY_REPORT: 0x0a,
		ENCAP: 0x0d,
		END_POINT_FIND: 0x0b,
		END_POINT_FIND_REPORT: 0x0c,
		END_POINT_GET: 0x07,
		END_POINT_REPORT: 0x08,
		MULTI_INSTANCE_CMD_ENCAP: 0x06,
		MULTI_INSTANCE_GET: 0x04,
		MULTI_INSTANCE_REPORT: 0x05 },
	ZIP_PORTAL: { id: 0x61,
		GATEWAY_CONFIGURATION_GET: 0x03,
		GATEWAY_CONFIGURATION_REPORT: 0x04,
		GATEWAY_CONFIGURATION_SET: 0x01,
		GATEWAY_CONFIGURATION_STATUS: 0x02 },
	DOOR_LOCK: { id: 0x62,
		CONFIGURATION_GET: 0x05,
		CONFIGURATION_REPORT: 0x06,
		CONFIGURATION_SET: 0x04,
		OPERATION_GET: 0x02,
		OPERATION_REPORT: 0x03,
		OPERATION_SET: 0x01 },
	DOOR_LOCKV2: { id: 0x62,
		CONFIGURATION_GET: 0x05,
		CONFIGURATION_REPORT: 0x06,
		CONFIGURATION_SET: 0x04,
		OPERATION_GET: 0x02,
		OPERATION_REPORT: 0x03,
		OPERATION_SET: 0x01 },
	DOOR_LOCKV3: { id: 0x62,
		CONFIGURATION_GET: 0x05,
		CONFIGURATION_REPORT: 0x06,
		CONFIGURATION_SET: 0x04,
		OPERATION_GET: 0x02,
		OPERATION_REPORT: 0x03,
		OPERATION_SET: 0x01 },
	USER_CODE: { id: 0x63,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		USERS_NUMBER_GET: 0x04,
		USERS_NUMBER_REPORT: 0x05 },
	HUMIDITY_CONTROL_SETPOINT: { id: 0x64,
		CAPABILITIES_GET: 0x08,
		CAPABILITIES_REPORT: 0x09,
		GET: 0x02,
		REPORT: 0x03,
		SCALE_SUPPORTED_GET: 0x06,
		SCALE_SUPPORTED_REPORT: 0x07,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	DMX: { id: 0x65,
		ADDRESS_GET: 0x02,
		ADDRESS_REPORT: 0x03,
		ADDRESS_SET: 0x01,
		CAPABILITY_GET: 0x04,
		CAPABILITY_REPORT: 0x05,
		DATA: 0x06 },
	BARRIER_OPERATOR: { id: 0x66,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SIGNAL_GET: 0x07,
		SIGNAL_REPORT: 0x08,
		SIGNAL_SET: 0x06,
		SIGNAL_SUPPORTED_GET: 0x04,
		SIGNAL_SUPPORTED_REPORT: 0x05 },
	NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE: { id: 0x67,
		LAST_WORKING_ROUTE_GET: 0x02,
		LAST_WORKING_ROUTE_REPORT: 0x03,
		LAST_WORKING_ROUTE_SET: 0x01,
		STATISTICS_CLEAR: 0x06,
		STATISTICS_GET: 0x04,
		STATISTICS_REPORT: 0x05 },
	ZIP_NAMING: { id: 0x68,
		LOCATION_GET: 0x05,
		LOCATION_REPORT: 0x06,
		LOCATION_SET: 0x04,
		NAME_GET: 0x02,
		NAME_REPORT: 0x03,
		NAME_SET: 0x01 },
	MAILBOX: { id: 0x69,
		CONFIGURATION_GET: 0x01,
		CONFIGURATION_REPORT: 0x03,
		CONFIGURATION_SET: 0x02,
		NODE_FAILING: 0x06,
		QUEUE: 0x04,
		WAKEUP_NOTIFICATION: 0x05 },
	WINDOW_COVERING: { id: 0x6a,
		GET: 0x03,
		REPORT: 0x04,
		SET: 0x05,
		START_LEVEL_CHANGE: 0x06,
		STOP_LEVEL_CHANGE: 0x07,
		SUPPORTED_GET: 0x01,
		SUPPORTED_REPORT: 0x02 },
	IRRIGATION: { id: 0x6b,
		SYSTEM_CONFIG_GET: 0x06,
		SYSTEM_CONFIG_REPORT: 0x07,
		SYSTEM_CONFIG_SET: 0x05,
		SYSTEM_INFO_GET: 0x01,
		SYSTEM_INFO_REPORT: 0x02,
		SYSTEM_SHUTOFF: 0x12,
		SYSTEM_STATUS_GET: 0x03,
		SYSTEM_STATUS_REPORT: 0x04,
		VALVE_CONFIG_GET: 0x0b,
		VALVE_CONFIG_REPORT: 0x0c,
		VALVE_CONFIG_SET: 0x0a,
		VALVE_INFO_GET: 0x08,
		VALVE_INFO_REPORT: 0x09,
		VALVE_RUN: 0x0d,
		VALVE_TABLE_GET: 0x0f,
		VALVE_TABLE_REPORT: 0x10,
		VALVE_TABLE_RUN: 0x11,
		VALVE_TABLE_SET: 0x0e },
	SUPERVISION: { id: 0x6c,
		GET: 0x01,
		REPORT: 0x02 },
	HUMIDITY_CONTROL_MODE: { id: 0x6d,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	HUMIDITY_CONTROL_OPERATING_STATE: { id: 0x6e,
		GET: 0x01,
		REPORT: 0x02 },
	ENTRY_CONTROL: { id: 0x6f,
		CONFIGURATION_GET: 0x07,
		CONFIGURATION_REPORT: 0x08,
		CONFIGURATION_SET: 0x06,
		EVENT_SUPPORTED_GET: 0x04,
		EVENT_SUPPORTED_REPORT: 0x05,
		KEY_SUPPORTED_GET: 0x02,
		KEY_SUPPORTED_REPORT: 0x03,
		NOTIFICATION: 0x01 },
	CONFIGURATION: { id: 0x70,
		GET: 0x05,
		REPORT: 0x06,
		SET: 0x04 },
	CONFIGURATIONV2: { id: 0x70,
		BULK_GET: 0x08,
		BULK_REPORT: 0x09,
		BULK_SET: 0x07,
		GET: 0x05,
		REPORT: 0x06,
		SET: 0x04 },
	CONFIGURATIONV3: { id: 0x70,
		BULK_GET: 0x08,
		BULK_REPORT: 0x09,
		BULK_SET: 0x07,
		GET: 0x05,
		INFO_GET: 0x0c,
		INFO_REPORT: 0x0d,
		NAME_GET: 0x0a,
		NAME_REPORT: 0x0b,
		PROPERTIES_GET: 0x0e,
		PROPERTIES_REPORT: 0x0f,
		REPORT: 0x06,
		SET: 0x04 },
	CONFIGURATIONV4: { id: 0x70,
		BULK_GET: 0x08,
		BULK_REPORT: 0x09,
		BULK_SET: 0x07,
		DEFAULT_RESET: 0x01,
		GET: 0x05,
		INFO_GET: 0x0c,
		INFO_REPORT: 0x0d,
		NAME_GET: 0x0a,
		NAME_REPORT: 0x0b,
		PROPERTIES_GET: 0x0e,
		PROPERTIES_REPORT: 0x0f,
		REPORT: 0x06,
		SET: 0x04 },
	ALARM: { id: 0x71,
		GET: 0x04,
		REPORT: 0x05 },
	ALARMV2: { id: 0x71,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		TYPE_SUPPORTED_GET: 0x07,
		TYPE_SUPPORTED_REPORT: 0x08 },
	NOTIFICATION: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	NOTIFICATIONV4: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	NOTIFICATIONV5: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	NOTIFICATIONV6: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	NOTIFICATIONV7: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	NOTIFICATIONV8: { id: 0x71,
		EVENT_SUPPORTED_GET: 0x01,
		EVENT_SUPPORTED_REPORT: 0x02,
		GET: 0x04,
		REPORT: 0x05,
		SET: 0x06,
		SUPPORTED_GET: 0x07,
		SUPPORTED_REPORT: 0x08 },
	MANUFACTURER_SPECIFIC: { id: 0x72,
		GET: 0x04,
		REPORT: 0x05 },
	MANUFACTURER_SPECIFICV2: { id: 0x72,
		DEVICE_SPECIFIC_GET: 0x06,
		DEVICE_SPECIFIC_REPORT: 0x07,
		GET: 0x04,
		REPORT: 0x05 },
	POWERLEVEL: { id: 0x73,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		TEST_NODE_GET: 0x05,
		TEST_NODE_REPORT: 0x06,
		TEST_NODE_SET: 0x04 },
	INCLUSION_CONTROLLER: { id: 0x74,
		COMPLETE: 0x02,
		INITIATE: 0x01 },
	PROTECTION: { id: 0x75,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	PROTECTIONV2: { id: 0x75,
		EC_GET: 0x07,
		EC_REPORT: 0x08,
		EC_SET: 0x06,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05,
		TIMEOUT_GET: 0x0a,
		TIMEOUT_REPORT: 0x0b,
		TIMEOUT_SET: 0x09 },
	LOCK: { id: 0x76,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	NODE_NAMING: { id: 0x77,
		NODE_LOCATION_GET: 0x05,
		NODE_LOCATION_REPORT: 0x06,
		NODE_LOCATION_SET: 0x04,
		NODE_NAME_GET: 0x02,
		NODE_NAME_REPORT: 0x03,
		NODE_NAME_SET: 0x01 },
	FIRMWARE_UPDATE_MD: { id: 0x7a,
		FIRMWARE_MD_GET: 0x01,
		FIRMWARE_MD_REPORT: 0x02,
		GET: 0x05,
		REPORT: 0x06,
		REQUEST_GET: 0x03,
		REQUEST_REPORT: 0x04,
		STATUS_REPORT: 0x07 },
	FIRMWARE_UPDATE_MDV2: { id: 0x7a,
		FIRMWARE_MD_GET: 0x01,
		FIRMWARE_MD_REPORT: 0x02,
		GET: 0x05,
		REPORT: 0x06,
		REQUEST_GET: 0x03,
		REQUEST_REPORT: 0x04,
		STATUS_REPORT: 0x07 },
	FIRMWARE_UPDATE_MDV3: { id: 0x7a,
		FIRMWARE_MD_GET: 0x01,
		FIRMWARE_MD_REPORT: 0x02,
		GET: 0x05,
		REPORT: 0x06,
		REQUEST_GET: 0x03,
		REQUEST_REPORT: 0x04,
		STATUS_REPORT: 0x07 },
	FIRMWARE_UPDATE_MDV4: { id: 0x7a,
		FIRMWARE_MD_GET: 0x01,
		FIRMWARE_MD_REPORT: 0x02,
		FIRMWARE_UPDATE_ACTIVATION_SET: 0x08,
		FIRMWARE_UPDATE_ACTIVATION_STATUS_REPORT: 0x09,
		GET: 0x05,
		REPORT: 0x06,
		REQUEST_GET: 0x03,
		REQUEST_REPORT: 0x04,
		STATUS_REPORT: 0x07 },
	FIRMWARE_UPDATE_MDV5: { id: 0x7a,
		FIRMWARE_MD_GET: 0x01,
		FIRMWARE_MD_REPORT: 0x02,
		FIRMWARE_UPDATE_ACTIVATION_SET: 0x08,
		FIRMWARE_UPDATE_ACTIVATION_STATUS_REPORT: 0x09,
		GET: 0x05,
		PREPARE_GET: 0x0a,
		PREPARE_REPORT: 0x0b,
		REPORT: 0x06,
		REQUEST_GET: 0x03,
		REQUEST_REPORT: 0x04,
		STATUS_REPORT: 0x07 },
	GROUPING_NAME: { id: 0x7b,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	REMOTE_ASSOCIATION_ACTIVATE: { id: 0x7c,
		REMOTE_ASSOCIATION_ACTIVATE: 0x01 },
	REMOTE_ASSOCIATION: { id: 0x7d,
		CONFIGURATION_GET: 0x02,
		CONFIGURATION_REPORT: 0x03,
		CONFIGURATION_SET: 0x01 },
	BATTERY: { id: 0x80,
		GET: 0x02,
		REPORT: 0x03 },
	CLOCK: { id: 0x81,
		GET: 0x05,
		REPORT: 0x06,
		SET: 0x04 },
	HAIL: { id: 0x82,
		HAIL: 0x01 },
	WAKE_UP: { id: 0x84,
		INTERVAL_GET: 0x05,
		INTERVAL_REPORT: 0x06,
		INTERVAL_SET: 0x04,
		NOTIFICATION: 0x07,
		NO_MORE_INFORMATION: 0x08 },
	WAKE_UPV2: { id: 0x84,
		INTERVAL_CAPABILITIES_GET: 0x09,
		INTERVAL_CAPABILITIES_REPORT: 0x0a,
		INTERVAL_GET: 0x05,
		INTERVAL_REPORT: 0x06,
		INTERVAL_SET: 0x04,
		NOTIFICATION: 0x07,
		NO_MORE_INFORMATION: 0x08 },
	ASSOCIATION: { id: 0x85,
		GET: 0x02,
		GROUPINGS_GET: 0x05,
		GROUPINGS_REPORT: 0x06,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	ASSOCIATIONV2: { id: 0x85,
		GET: 0x02,
		GROUPINGS_GET: 0x05,
		GROUPINGS_REPORT: 0x06,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01,
		SPECIFIC_GROUP_GET: 0x0b,
		SPECIFIC_GROUP_REPORT: 0x0c },
	VERSION: { id: 0x86,
		GET: 0x13,
		GET: 0x11,
		REPORT: 0x14,
		REPORT: 0x12 },
	VERSIONV2: { id: 0x86,
		GET: 0x13,
		GET: 0x11,
		REPORT: 0x14,
		REPORT: 0x12 },
	INDICATOR: { id: 0x87,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	INDICATORV2: { id: 0x87,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	PROPRIETARY: { id: 0x88,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	LANGUAGE: { id: 0x89,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	TIME: { id: 0x8a,
		DATE_GET: 0x03,
		DATE_REPORT: 0x04,
		GET: 0x01,
		REPORT: 0x02 },
	TIMEV2: { id: 0x8a,
		DATE_GET: 0x03,
		DATE_REPORT: 0x04,
		GET: 0x01,
		OFFSET_GET: 0x06,
		OFFSET_REPORT: 0x07,
		OFFSET_SET: 0x05,
		REPORT: 0x02 },
	TIME_PARAMETERS: { id: 0x8b,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	GEOGRAPHIC_LOCATION: { id: 0x8c,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01 },
	MULTI_INSTANCE_ASSOCIATION: { id: 0x8e,
		GET: 0x02,
		GROUPINGS_GET: 0x05,
		GROUPINGS_REPORT: 0x06,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	MULTI_CHANNEL_ASSOCIATION: { id: 0x8e,
		GET: 0x02,
		GROUPINGS_GET: 0x05,
		GROUPINGS_REPORT: 0x06,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	MULTI_CHANNEL_ASSOCIATIONV3: { id: 0x8e,
		GET: 0x02,
		GROUPINGS_GET: 0x05,
		GROUPINGS_REPORT: 0x06,
		REMOVE: 0x04,
		REPORT: 0x03,
		SET: 0x01 },
	MULTI_CMD: { id: 0x8f,
		ENCAP: 0x01 },
	ENERGY_PRODUCTION: { id: 0x90,
		GET: 0x02,
		REPORT: 0x03 },
	MANUFACTURER_PROPRIETARY: { id: 0x91 },
	SCREEN_MD: { id: 0x92,
		GET: 0x01,
		REPORT: 0x02 },
	SCREEN_MDV2: { id: 0x92,
		GET: 0x01,
		REPORT: 0x03 },
	SCREEN_ATTRIBUTES: { id: 0x93,
		GET: 0x01,
		REPORT: 0x02 },
	SCREEN_ATTRIBUTESV2: { id: 0x93,
		GET: 0x01,
		REPORT: 0x03 },
	SIMPLE_AV_CONTROL: { id: 0x94,
		GET: 0x02,
		REPORT: 0x03,
		SET: 0x01,
		SUPPORTED_GET: 0x04,
		SUPPORTED_REPORT: 0x05 },
	AV_CONTENT_DIRECTORY_MD: { id: 0x95,
		AV_CONTENT_BROWSE_MD_BY_LETTER_GET: 0x03,
		AV_CONTENT_BROWSE_MD_BY_LETTER_REPORT: 0x04,
		AV_CONTENT_BROWSE_MD_CHILD_COUNT_GET: 0x05,
		AV_CONTENT_BROWSE_MD_CHILD_COUNT_REPORT: 0x06,
		AV_CONTENT_BROWSE_MD_GET: 0x01,
		AV_CONTENT_BROWSE_MD_REPORT: 0x02,
		AV_MATCH_ITEM_TO_RENDERER_MD_GET: 0x07,
		AV_MATCH_ITEM_TO_RENDERER_MD_REPORT: 0x08 },
	AV_RENDERER_STATUS: { id: 0x96,
		GET: 0x01,
		REPORT: 0x02 },
	AV_CONTENT_SEARCH_MD: { id: 0x97,
		GET: 0x01,
		REPORT: 0x02 },
	SECURITY: { id: 0x98,
		COMMANDS_SUPPORTED_GET: 0x02,
		COMMANDS_SUPPORTED_REPORT: 0x03,
		MESSAGE_ENCAPSULATION: 0x81,
		MESSAGE_ENCAPSULATION_NONCE_GET: 0xc1,
		NETWORK_KEY_SET: 0x06,
		NETWORK_KEY_VERIFY: 0x07,
		NONCE_GET: 0x40,
		NONCE_REPORT: 0x80,
		SCHEME_GET: 0x04,
		SCHEME_INHERIT: 0x08,
		SCHEME_REPORT: 0x05 },
	AV_TAGGING_MD: { id: 0x99,
		GET: 0x01,
		REPORT: 0x02 },
	IP_CONFIGURATION: { id: 0x9a,
		GET: 0x02,
		RELEASE: 0x04,
		RENEW: 0x05,
		REPORT: 0x03,
		SET: 0x01 },
	ASSOCIATION_COMMAND_CONFIGURATION: { id: 0x9b,
		COMMAND_CONFIGURATION_GET: 0x04,
		COMMAND_CONFIGURATION_REPORT: 0x05,
		COMMAND_CONFIGURATION_SET: 0x03,
		COMMAND_RECORDS_SUPPORTED_GET: 0x01,
		COMMAND_RECORDS_SUPPORTED_REPORT: 0x02 },
	SENSOR_ALARM: { id: 0x9c,
		GET: 0x01,
		REPORT: 0x02,
		SUPPORTED_GET: 0x03,
		SUPPORTED_REPORT: 0x04 },
	SILENCE_ALARM: { id: 0x9d,
		SENSOR_ALARM_SET: 0x01 },
	SENSOR_CONFIGURATION: { id: 0x9e,
		SENSOR_TRIGGER_LEVEL_GET: 0x02,
		SENSOR_TRIGGER_LEVEL_REPORT: 0x03,
		SENSOR_TRIGGER_LEVEL_SET: 0x01 },
	SECURITY_2: { id: 0x9f,
		CAPABILITIES_GET: 0x0f,
		CAPABILITIES_REPORT: 0x10,
		COMMANDS_SUPPORTED_GET: 0x0d,
		COMMANDS_SUPPORTED_REPORT: 0x0e,
		KEX_FAIL: 0x07,
		KEX_GET: 0x04,
		KEX_REPORT: 0x05,
		KEX_SET: 0x06,
		MESSAGE_ENCAPSULATION: 0x03,
		NETWORK_KEY_GET: 0x09,
		NETWORK_KEY_REPORT: 0x0a,
		NETWORK_KEY_VERIFY: 0x0b,
		NONCE_GET: 0x01,
		NONCE_REPORT: 0x02,
		PUBLIC_KEY_REPORT: 0x08,
		TRANSFER_END: 0x0c },
	MARK: { id: 0xef },
	NON_INTEROPERABLE: { id: 0xf0 },
	enum: {
		0x00: { version: 1, name: "NO_OPERATION", help: "NOP", command: {  /* none */ } },
		0x01: { version: 1, name: "ZWAVE_CMD_CLASS", help: "Z-Wave protocol Command Class", command: {  /* see below */ } },
		0x02: { version: 1, name: "ZENSOR_NET", help: "Command Class Zensor Net", command: {  /* see below */ } },
		0x20: { version: 2, name: "BASIC", help: "Command Class Basic", command: {  /* see below */ } },
		0x21: { version: 1, name: "CONTROLLER_REPLICATION", help: "Command Class Controller Replication", command: {  /* see below */ } },
		0x22: { version: 1, name: "APPLICATION_STATUS", help: "Command Class Application Status", command: {  /* see below */ } },
		0x23: { version: 3, name: "ZIP", help: "Command Class Z/IP", command: {  /* see below */ } },
		0x24: { version: 1, name: "SECURITY_PANEL_MODE", help: "Command Class Security Panel Mode", command: {  /* see below */ } },
		0x25: { version: 2, name: "SWITCH_BINARY", help: "Command Class Switch Binary", command: {  /* see below */ } },
		0x26: { version: 4, name: "SWITCH_MULTILEVEL", help: "Command Class Switch Multilevel", command: {  /* see below */ } },
		0x27: { version: 1, name: "SWITCH_ALL", help: "Command Class Switch All", command: {  /* see below */ } },
		0x28: { version: 1, name: "SWITCH_TOGGLE_BINARY", help: "Command Class Switch Toggle Binary", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x29: { version: 1, name: "SWITCH_TOGGLE_MULTILEVEL", help: "Command Class Switch Toggle Multilevel", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x2a: { version: 1, name: "CHIMNEY_FAN", help: "Command Class Chimney Fan", command: {  /* see below */ } },
		0x2b: { version: 1, name: "SCENE_ACTIVATION", help: "Command Class Scene Activation", command: {  /* see below */ } },
		0x2c: { version: 1, name: "SCENE_ACTUATOR_CONF", help: "Command Class Scene Actuator Conf", command: {  /* see below */ } },
		0x2d: { version: 1, name: "SCENE_CONTROLLER_CONF", help: "Command Class Scene Controller Conf", command: {  /* see below */ } },
		0x2e: { version: 1, name: "SECURITY_PANEL_ZONE", help: "Command Class Security Panel Zone", command: {  /* see below */ } },
		0x2f: { version: 1, name: "SECURITY_PANEL_ZONE_SENSOR", help: "Command Class Security Panel Zone Sensor", command: {  /* see below */ } },
		0x30: { version: 2, name: "SENSOR_BINARY", help: "Command Class Sensor Binary", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x31: { version: 9, name: "SENSOR_MULTILEVEL", help: "Command Class Sensor Multilevel", command: {  /* see below */ } },
		0x32: { version: 4, name: "METER", help: "Command Class Meter", command: {  /* see below */ } },
		0x33: { version: 3, name: "SWITCH_COLOR", help: "Command Class Switch Color", command: {  /* see below */ } },
		0x34: { version: 2, name: "NETWORK_MANAGEMENT_INCLUSION", help: "Command Class Network Management Inclusion", command: {  /* see below */ } },
		0x35: { version: 1, name: "METER_PULSE", help: "Command Class Meter Pulse", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x36: { version: 1, name: "BASIC_TARIFF_INFO", help: "Command Class Basic Tariff Info", command: {  /* see below */ } },
		0x37: { version: 1, name: "HRV_STATUS", help: "Command Class Hrv Status", command: {  /* see below */ } },
		0x38: { version: 1, name: "THERMOSTAT_HEATING", help: "Command Class Thermostat Heating", command: {  /* see below */ } },
		0x39: { version: 1, name: "HRV_CONTROL", help: "Command Class Hrv Control", command: {  /* see below */ } },
		0x3a: { version: 1, name: "DCP_CONFIG", help: "Command Class Dcp Config", command: {  /* see below */ } },
		0x3b: { version: 1, name: "DCP_MONITOR", help: "Command Class Dcp Monitor", command: {  /* see below */ } },
		0x3c: { version: 1, name: "METER_TBL_CONFIG", help: "Command Class Meter Tbl Config", command: {  /* see below */ } },
		0x3d: { version: 2, name: "METER_TBL_MONITOR", help: "Command Class Meter Tbl Monitor", command: {  /* see below */ } },
		0x3e: { version: 1, name: "METER_TBL_PUSH", help: "Command Class Meter Tbl Push", command: {  /* see below */ } },
		0x3f: { version: 1, name: "PREPAYMENT", help: "Command Class Prepayment", command: {  /* see below */ } },
		0x40: { version: 3, name: "THERMOSTAT_MODE", help: "Command Class Thermostat Mode", command: {  /* see below */ } },
		0x41: { version: 1, name: "PREPAYMENT_ENCAPSULATION", help: "Command Class Prepayment Encapsulation", command: {  /* see below */ } },
		0x42: { version: 2, name: "THERMOSTAT_OPERATING_STATE", help: "Command Class Thermostat Operating State", command: {  /* see below */ } },
		0x43: { version: 3, name: "THERMOSTAT_SETPOINT", help: "Command Class Thermostat Setpoint", command: {  /* see below */ } },
		0x44: { version: 4, name: "THERMOSTAT_FAN_MODE", help: "Command Class Thermostat Fan Mode", command: {  /* see below */ } },
		0x45: { version: 2, name: "THERMOSTAT_FAN_STATE", help: "Command Class Thermostat Fan State", command: {  /* see below */ } },
		0x46: { version: 1, name: "CLIMATE_CONTROL_SCHEDULE", help: "Command Class Climate Control Schedule", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x47: { version: 1, name: "THERMOSTAT_SETBACK", help: "Command Class Thermostat Setback", command: {  /* see below */ } },
		0x48: { version: 1, name: "RATE_TBL_CONFIG", help: "Command Class Rate Tbl Config", command: {  /* see below */ } },
		0x49: { version: 1, name: "RATE_TBL_MONITOR", help: "Command Class Rate Tbl Monitor", command: {  /* see below */ } },
		0x4a: { version: 1, name: "TARIFF_CONFIG", help: "Command Class Tariff Config", command: {  /* see below */ } },
		0x4b: { version: 1, name: "TARIFF_TBL_MONITOR", help: "Command Class Tariff Tbl Monitor", command: {  /* see below */ } },
		0x4c: { version: 1, name: "DOOR_LOCK_LOGGING", help: "Command Class Door Lock Logging", command: {  /* see below */ } },
		0x4d: { version: 2, name: "NETWORK_MANAGEMENT_BASIC", help: "Command Class Network Management Basic", command: {  /* see below */ } },
		0x4e: { version: 3, name: "SCHEDULE_ENTRY_LOCK", help: "Command Class Schedule Entry Lock", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x4f: { version: 1, name: "ZIP_6LOWPAN", help: "Command Class Z/IP 6lowpan", command: {  /* see below */ } },
		0x50: { version: 1, name: "BASIC_WINDOW_COVERING", help: "Command Class Basic Window Covering", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x51: { version: 1, name: "MTP_WINDOW_COVERING", help: "Command Class Mtp Window Covering", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x52: { version: 2, name: "NETWORK_MANAGEMENT_PROXY", help: "Command Class Network Management Proxy", command: {  /* see below */ } },
		0x53: { version: 3, name: "SCHEDULE", help: "Command Class Schedule", command: {  /* see below */ } },
		0x54: { version: 1, name: "NETWORK_MANAGEMENT_PRIMARY", help: "Command Class Network Management Primary", command: {  /* see below */ } },
		0x55: { version: 2, name: "TRANSPORT_SERVICE", help: "Command Class Transport Service", command: {  /* see below */ } },
		0x56: { version: 1, name: "CRC_16_ENCAP", help: "Command Class CRC16 Encap", command: {  /* see below */ } },
		0x57: { version: 1, name: "APPLICATION_CAPABILITY", help: "Command Class Application Capability", command: {  /* see below */ } },
		0x58: { version: 1, name: "ZIP_ND", help: "Command Class Z/IP-ND", command: {  /* see below */ } },
		0x59: { version: 3, name: "ASSOCIATION_GRP_INFO", help: "Command Class Association Group Info", command: {  /* see below */ } },
		0x5a: { version: 1, name: "DEVICE_RESET_LOCALLY", help: "Command Class Device Reset Locally", command: {  /* see below */ } },
		0x5b: { version: 3, name: "CENTRAL_SCENE", help: "Command Class Central Scene", command: {  /* see below */ } },
		0x5c: { version: 1, name: "IP_ASSOCIATION", help: "Command Class Ip Association", command: {  /* see below */ } },
		0x5d: { version: 2, name: "ANTITHEFT", help: "Command Class Anti-theft", command: {  /* see below */ } },
		0x5e: { version: 2, name: "ZWAVEPLUS_INFO", help: "Command Class Z-Wave+ Info", comment: "SDS11907-3", command: {  /* see below */ } },
		0x5f: { version: 1, name: "ZIP_GATEWAY", help: "Command Class Z/IP Gateway", command: {  /* see below */ } },
		0x60: { version: 4, name: "MULTI_CHANNEL", help: "Command Class Multi Channel", command: {  /* see below */ } },
		0x61: { version: 1, name: "ZIP_PORTAL", help: "Command Class Z/IP Portal", command: {  /* see below */ } },
		0x62: { version: 3, name: "DOOR_LOCK", help: "Command Class Door Lock", command: {  /* see below */ } },
		0x63: { version: 1, name: "USER_CODE", help: "Command Class User Code", command: {  /* see below */ } },
		0x64: { version: 1, name: "HUMIDITY_CONTROL_SETPOINT", help: "Command Class Humidity Control Setpoint", command: {  /* see below */ } },
		0x65: { version: 1, name: "DMX", help: "Command Class DMX", command: {  /* see below */ } },
		0x66: { version: 1, name: "BARRIER_OPERATOR", help: "Command Class Barrier Operator", command: {  /* see below */ } },
		0x67: { version: 1, name: "NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE", help: "Command Class Network Management Installation and Maintenance", command: {  /* see below */ } },
		0x68: { version: 1, name: "ZIP_NAMING", help: "Command Class Z/IP Naming and Location", command: {  /* see below */ } },
		0x69: { version: 1, name: "MAILBOX", help: "Command Class Mailbox", command: {  /* see below */ } },
		0x6a: { version: 1, name: "WINDOW_COVERING", help: "Command Class Window Covering", command: {  /* see below */ } },
		0x6b: { version: 1, name: "IRRIGATION", help: "Command Class Irrigation", command: {  /* see below */ } },
		0x6c: { version: 1, name: "SUPERVISION", help: "Command Class Supervision", command: {  /* see below */ } },
		0x6d: { version: 1, name: "HUMIDITY_CONTROL_MODE", help: "Command Class Humidity Control Mode", command: {  /* see below */ } },
		0x6e: { version: 1, name: "HUMIDITY_CONTROL_OPERATING_STATE", help: "Command Class Humidity Control Operating State", command: {  /* see below */ } },
		0x6f: { version: 1, name: "ENTRY_CONTROL", help: "Command Class Entry Control", command: {  /* see below */ } },
		0x70: { version: 4, name: "CONFIGURATION", help: "Command Class Configuration", command: {  /* see below */ } },
		0x71: { version: 8, name: "NOTIFICATION", help: "Command Class Notification", command: {  /* see below */ } },
		0x72: { version: 2, name: "MANUFACTURER_SPECIFIC", help: "Command Class Manufacturer Specific", command: {  /* see below */ } },
		0x73: { version: 1, name: "POWERLEVEL", help: "Command Class Powerlevel", command: {  /* see below */ } },
		0x74: { version: 1, name: "INCLUSION_CONTROLLER", help: "Command Class Inclusion Controller", command: {  /* see below */ } },
		0x75: { version: 2, name: "PROTECTION", help: "Command Class Protection", command: {  /* see below */ } },
		0x76: { version: 1, name: "LOCK", help: "Command Class Lock", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x77: { version: 1, name: "NODE_NAMING", help: "Command Class Node Naming", command: {  /* see below */ } },
		0x7a: { version: 5, name: "FIRMWARE_UPDATE_MD", help: "Command Class Firmware Update Md", command: {  /* see below */ } },
		0x7b: { version: 1, name: "GROUPING_NAME", help: "Command Class Grouping Name", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x7c: { version: 1, name: "REMOTE_ASSOCIATION_ACTIVATE", help: "Command Class Remote Association Activate", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x7d: { version: 1, name: "REMOTE_ASSOCIATION", help: "Command Class Remote Association", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x80: { version: 1, name: "BATTERY", help: "Command Class Battery", command: {  /* see below */ } },
		0x81: { version: 1, name: "CLOCK", help: "Command Class Clock", command: {  /* see below */ } },
		0x82: { version: 1, name: "HAIL", help: "Command Class Hail", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x84: { version: 2, name: "WAKE_UP", help: "Command Class Wake Up", command: {  /* see below */ } },
		0x85: { version: 2, name: "ASSOCIATION", help: "Command Class Association", command: {  /* see below */ } },
		0x86: { version: 2, name: "VERSION", help: "Command Class Version", command: {  /* see below */ } },
		0x87: { version: 2, name: "INDICATOR", help: "Command Class Indicator", command: {  /* see below */ } },
		0x88: { version: 1, name: "PROPRIETARY", help: "Command Class Proprietary", comment: "[DEPRECATED]", command: {  /* see below */ } },
		0x89: { version: 1, name: "LANGUAGE", help: "Command Class Language", command: {  /* see below */ } },
		0x8a: { version: 2, name: "TIME", help: "Command Class Time", command: {  /* see below */ } },
		0x8b: { version: 1, name: "TIME_PARAMETERS", help: "Command Class Time Parameters", command: {  /* see below */ } },
		0x8c: { version: 1, name: "GEOGRAPHIC_LOCATION", help: "Command Class Geographic Location", command: {  /* see below */ } },
		0x8e: { version: 3, name: "MULTI_CHANNEL_ASSOCIATION", help: "Command Class Multi Channel Association", command: {  /* see below */ } },
		0x8f: { version: 1, name: "MULTI_CMD", help: "Command Class Multi Cmd", command: {  /* see below */ } },
		0x90: { version: 1, name: "ENERGY_PRODUCTION", help: "Command Class Energy Production", command: {  /* see below */ } },
		0x91: { version: 1, name: "MANUFACTURER_PROPRIETARY", help: "Command Class Manufacturer Proprietary", command: {  /* none */ } },
		0x92: { version: 2, name: "SCREEN_MD", help: "Command Class Screen Md", command: {  /* see below */ } },
		0x93: { version: 2, name: "SCREEN_ATTRIBUTES", help: "Command Class Screen Attributes", command: {  /* see below */ } },
		0x94: { version: 1, name: "SIMPLE_AV_CONTROL", help: "Command Class Simple Av Control", command: {  /* see below */ } },
		0x95: { version: 1, name: "AV_CONTENT_DIRECTORY_MD", help: "Command Class Av Content Directory Md", command: {  /* see below */ } },
		0x96: { version: 1, name: "AV_RENDERER_STATUS", help: "Command Class Av Renderer Status", command: {  /* see below */ } },
		0x97: { version: 1, name: "AV_CONTENT_SEARCH_MD", help: "Command Class Av Content Search Md", command: {  /* see below */ } },
		0x98: { version: 1, name: "SECURITY", help: "Command Class Security", command: {  /* see below */ } },
		0x99: { version: 1, name: "AV_TAGGING_MD", help: "Command Class Av Tagging Md", command: {  /* see below */ } },
		0x9a: { version: 1, name: "IP_CONFIGURATION", help: "Command Class Ip Configuration", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x9b: { version: 1, name: "ASSOCIATION_COMMAND_CONFIGURATION", help: "Command Class Association Command Configuration", command: {  /* see below */ } },
		0x9c: { version: 1, name: "SENSOR_ALARM", help: "Command Class Sensor Alarm", comment: "SDS10963-4 The Sensor Alarm command class can be used to realize Sensor Alarms.", command: {  /* see below */ } },
		0x9d: { version: 1, name: "SILENCE_ALARM", help: "Command Class Silence Alarm", comment: "SDS10963-4 The Alarm Silence command class can be used to nuisance silence to temporarily disable the sounding", command: {  /* see below */ } },
		0x9e: { version: 1, name: "SENSOR_CONFIGURATION", help: "Command Class Sensor Configuration", comment: "[OBSOLETED]", command: {  /* see below */ } },
		0x9f: { version: 1, name: "SECURITY_2", help: "Command Class Security 2", command: {  /* see below */ } },
		0xef: { version: 1, name: "MARK", help: "Command Class Mark", command: {  /* none */ } },
		0xf0: { version: 1, name: "NON_INTEROPERABLE", help: "Command Class Non Interoperable", command: {  /* none */ } },
	}
};

module.exports.COMMAND_CLASS = COMMAND_CLASS;


/*
 * COMMAND_CLASS 0x01 ZWAVE_CMD_CLASS COMMANDS
 */

// ZWAVE_CMD_CLASS [0x01] NOP [0x00] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x00] = {
	name: "NOP",
	help: "NOP",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NODE_INFO [0x01] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x01] = {
	name: "NODE_INFO",
	help: "Node Info",
	comment: "SDS10264-2",
	param: { 
		'0x00a': {name: "ProtocolVersion" /* Capability STRUCT_BYTE */ }, 
		'0x00b': {name: "MaxBaudRate" /* Capability STRUCT_BYTE */ }, 
		'0x00c': {name: "Routing" /* Capability STRUCT_BYTE */ }, 
		'0x00d': {name: "Listening" /* Capability STRUCT_BYTE */ }, 
		'0x01a': {name: "Security" /* Security STRUCT_BYTE */ }, 
		'0x01b': {name: "Controller" /* Security STRUCT_BYTE */ }, 
		'0x01c': {name: "SpecificDevice" /* Security STRUCT_BYTE */ }, 
		'0x01d': {name: "RoutingSlave" /* Security STRUCT_BYTE */ }, 
		'0x01e': {name: "BeamCapability" /* Security STRUCT_BYTE */ }, 
		'0x01f': {name: "Sensor250ms" /* Security STRUCT_BYTE */ }, 
		'0x01g': {name: "Sensor1000ms" /* Security STRUCT_BYTE */ }, 
		'0x01h': {name: "OptionalFunctionality" /* Security STRUCT_BYTE */ }, 
		'0x02a': {name: "SpeedExtension" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved2" /* Properties1 STRUCT_BYTE */ }, 
		'0x03': {name: "BasicDeviceClass" /* CONST */ }, 
		'0x04': {name: "zwave.GenericDevice", alias: "zwaveGenericDevice", encaptype: "GEN_DEV_REF" /* CONST */ }, 
		'0x05': {name: "zwave.SpecificDevice", alias: "zwaveSpecificDevice", encaptype: "SPEC_DEV_REF" /* MULTI_ARRAY */ }, 
		'0x06': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* ENUM_ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ProtocolVersion' in context || 'MaxBaudRate' in context || 'Routing' in context || 'Listening' in context) {
			let _capability = 0x00;
			if ('ProtocolVersion' in context) _capability = _capability | ((helpers.getValue(context, 'ProtocolVersion', ENUM_NODE_INFO_PROTOCOL_VERSION)) & 0x07); 
			if ('MaxBaudRate' in context) _capability = _capability | ((helpers.getValue(context, 'MaxBaudRate', ENUM_NODE_INFO_MAX_BAUD_RATE) << 3) & 0x38); 
			if (context['Routing']) _capability = _capability | 0x40;
			if (context['Listening']) _capability = _capability | 0x80;
			payload.writeBYTE(_capability);
		} else return payload.asBuffer();;
		if ('Security' in context || 'Controller' in context || 'SpecificDevice' in context || 'RoutingSlave' in context || 'BeamCapability' in context || 'Sensor250ms' in context || 'Sensor1000ms' in context || 'OptionalFunctionality' in context) {
			let _security = 0x00;
			if (context['Security']) _security = _security | 0x01;
			if (context['Controller']) _security = _security | 0x02;
			if (context['SpecificDevice']) _security = _security | 0x04;
			if (context['RoutingSlave']) _security = _security | 0x08;
			if (context['BeamCapability']) _security = _security | 0x10;
			if (context['Sensor250ms']) _security = _security | 0x20;
			if (context['Sensor1000ms']) _security = _security | 0x40;
			if (context['OptionalFunctionality']) _security = _security | 0x80;
			payload.writeBYTE(_security);
		} else return payload.asBuffer();;
		if ('SpeedExtension' in context || 'Reserved2' in context) {
			let _properties1 = 0x00;
			if ('SpeedExtension' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SpeedExtension', ENUM_NODE_INFO_SPEED_EXTENSION)) & 0x07); 
			if ('Reserved2' in context) _properties1 = _properties1 | ((context['Reserved2'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ((payload.at(1) & 0x02) !== 0) /* optional flag for BasicDeviceClass */ {
			if ('BasicDeviceClass' in context) payload.writeBYTE(helpers.getValue(context, 'BasicDeviceClass', ENUM_NODE_INFO_BASIC_DEVICE_CLASS)); else return payload.asBuffer();
		}
		if ('zwave.GenericDevice' in context) payload.writeBYTE(helpers.getValue(context, 'zwave.GenericDevice', ENUM_NODE_INFO_ZWAVE_GENERIC_DEVICE)); else return payload.asBuffer();
		if ('zwave.SpecificDevice' in context) payload.writeBYTE(helpers.getValue(context, 'zwave.SpecificDevice', MULTI_ARRAY_ZWAVE_CMD_CLASS_NODE_INFO_ZWAVE_SPECIFIC_DEVICE[payload.at(4)])); else return payload.asBuffer();
		if ('zwave.CommandClass' in context) payload.writeBUFFER(helpers.getValueArray(context, 'zwave.CommandClass', ENUM_NODE_INFO_ZWAVE_COMMAND_CLASS), {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _capability = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ProtocolVersion'] = helpers.lookupNameValue((_capability & 0x07), ENUM_NODE_INFO_PROTOCOL_VERSION.enum); else return context;
			if (!payload.insufficientBytes(1)) context['MaxBaudRate'] = helpers.lookupNameValue((_capability & 0x38) >> 3, ENUM_NODE_INFO_MAX_BAUD_RATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Routing'] = ((_capability & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Listening'] = ((_capability & 0x80) == 0) ? false : true; else return context;
		}
		{
			let _security = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Security'] = ((_security & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Controller'] = ((_security & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SpecificDevice'] = ((_security & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RoutingSlave'] = ((_security & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['BeamCapability'] = ((_security & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Sensor250ms'] = ((_security & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Sensor1000ms'] = ((_security & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['OptionalFunctionality'] = ((_security & 0x80) == 0) ? false : true; else return context;
		}
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SpeedExtension'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_NODE_INFO_SPEED_EXTENSION.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['BasicDeviceClass'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NODE_INFO_BASIC_DEVICE_CLASS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.GenericDevice'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NODE_INFO_ZWAVE_GENERIC_DEVICE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.SpecificDevice'] = helpers.lookupNameValue(payload.readBYTE(), MULTI_ARRAY_ZWAVE_CMD_CLASS_NODE_INFO_ZWAVE_SPECIFIC_DEVICE[payload.at(4)].enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = helpers.lookupNameValueArray(payload.readBUFFER({}),  ENUM_NODE_INFO_ZWAVE_COMMAND_CLASS.enum); else return context;
		return context;
	}
};

const ENUM_NODE_INFO_PROTOCOL_VERSION = {
	Reserved: 0x00, 
	Version20: 0x01, 
	VersionZdk50xZdk42x: 0x02, 
	VersionZdk45xAndZdk60x: 0x03, 
	Reserved: 0x04, 
	Reserved: 0x05, 
	Reserved: 0x06, 
	Reserved: 0x07, 
	enum: {
		0x00: "Reserved", 
		0x01: "Version20", 
		0x02: "VersionZdk50xZdk42x", 
		0x03: "VersionZdk45xAndZdk60x", 
		0x04: "Reserved", 
		0x05: "Reserved", 
		0x06: "Reserved", 
		0x07: "Reserved"
	}
};

const ENUM_NODE_INFO_MAX_BAUD_RATE = {
	Reserved: 0x00, 
	'96Kbps': 0x01, 
	'40Kbps': 0x02, 
	enum: {
		0x00: "Reserved", 
		0x01: "96Kbps", 
		0x02: "40Kbps"
	}
};

const ENUM_NODE_INFO_SPEED_EXTENSION = {
	Reserved: 0x00, 
	'100Kbps': 0x01, 
	'200Kbps': 0x02, 
	enum: {
		0x00: "Reserved", 
		0x01: "100Kbps", 
		0x02: "200Kbps"
	}
};

const ENUM_NODE_INFO_BASIC_DEVICE_CLASS = {
	Controller: 0x01, 
	StaticController: 0x02, 
	Slave: 0x03, 
	RoutingSlave: 0x04, 
	enum: {
		0x01: "Controller", 
		0x02: "StaticController", 
		0x03: "Slave", 
		0x04: "RoutingSlave"
	}
};

const ENUM_NODE_INFO_ZWAVE_GENERIC_DEVICE = {
	GenericController: 0x01, 
	StaticController: 0x02, 
	AvControlPoint: 0x03, 
	Display: 0x04, 
	NetworkExtender: 0x05, 
	Appliance: 0x06, 
	SensorNotification: 0x07, 
	Thermostat: 0x08, 
	WindowCovering: 0x09, 
	RepeaterSlave: 0x0f, 
	SwitchBinary: 0x10, 
	SwitchMultilevel: 0x11, 
	SwitchRemote: 0x12, 
	SwitchToggle: 0x13, 
	ZipNode: 0x15, 
	Ventilation: 0x16, 
	SecurityPanel: 0x17, 
	WallController: 0x18, 
	SensorBinary: 0x20, 
	SensorMultilevel: 0x21, 
	MeterPulse: 0x30, 
	Meter: 0x31, 
	EntryControl: 0x40, 
	SemiInteroperable: 0x50, 
	SensorAlarm: 0xa1, 
	NonInteroperable: 0xff, 
	enum: {
		0x01: "GenericController", 
		0x02: "StaticController", 
		0x03: "AvControlPoint", 
		0x04: "Display", 
		0x05: "NetworkExtender", 
		0x06: "Appliance", 
		0x07: "SensorNotification", 
		0x08: "Thermostat", 
		0x09: "WindowCovering", 
		0x0f: "RepeaterSlave", 
		0x10: "SwitchBinary", 
		0x11: "SwitchMultilevel", 
		0x12: "SwitchRemote", 
		0x13: "SwitchToggle", 
		0x15: "ZipNode", 
		0x16: "Ventilation", 
		0x17: "SecurityPanel", 
		0x18: "WallController", 
		0x20: "SensorBinary", 
		0x21: "SensorMultilevel", 
		0x30: "MeterPulse", 
		0x31: "Meter", 
		0x40: "EntryControl", 
		0x50: "SemiInteroperable", 
		0xa1: "SensorAlarm", 
		0xff: "NonInteroperable"
	}
};

const ENUM_NODE_INFO_ZWAVE_COMMAND_CLASS = {
	NoOperation: 0x00, 
	Class: 0x01, 
	ZensorNet: 0x02, 
	Basic: 0x20, 
	ControllerReplication: 0x21, 
	ApplicationStatus: 0x22, 
	Zip: 0x23, 
	SecurityPanelMode: 0x24, 
	SwitchBinary: 0x25, 
	SwitchMultilevel: 0x26, 
	SwitchAll: 0x27, 
	SwitchToggleBinary: 0x28, 
	SwitchToggleMultilevel: 0x29, 
	ChimneyFan: 0x2a, 
	SceneActivation: 0x2b, 
	SceneActuatorConf: 0x2c, 
	SceneControllerConf: 0x2d, 
	SecurityPanelZone: 0x2e, 
	SecurityPanelZoneSensor: 0x2f, 
	SensorBinary: 0x30, 
	SensorMultilevel: 0x31, 
	Meter: 0x32, 
	SwitchColor: 0x33, 
	NetworkManagementInclusion: 0x34, 
	MeterPulse: 0x35, 
	BasicTariffInfo: 0x36, 
	HrvStatus: 0x37, 
	ThermostatHeating: 0x38, 
	HrvControl: 0x39, 
	DcpConfig: 0x3a, 
	DcpMonitor: 0x3b, 
	MeterTblConfig: 0x3c, 
	MeterTblMonitor: 0x3d, 
	MeterTblPush: 0x3e, 
	Prepayment: 0x3f, 
	ThermostatMode: 0x40, 
	PrepaymentEncapsulation: 0x41, 
	ThermostatOperatingState: 0x42, 
	ThermostatSetpoint: 0x43, 
	ThermostatFanMode: 0x44, 
	ThermostatFanState: 0x45, 
	ClimateControlSchedule: 0x46, 
	ThermostatSetback: 0x47, 
	RateTblConfig: 0x48, 
	RateTblMonitor: 0x49, 
	TariffConfig: 0x4a, 
	TariffTblMonitor: 0x4b, 
	DoorLockLogging: 0x4c, 
	NetworkManagementBasic: 0x4d, 
	ScheduleEntryLock: 0x4e, 
	Zip6lowpan: 0x4f, 
	BasicWindowCovering: 0x50, 
	MtpWindowCovering: 0x51, 
	NetworkManagementProxy: 0x52, 
	Schedule: 0x53, 
	NetworkManagementPrimary: 0x54, 
	TransportService: 0x55, 
	Crc16Encap: 0x56, 
	ApplicationCapability: 0x57, 
	ZipNd: 0x58, 
	AssociationGrpInfo: 0x59, 
	DeviceResetLocally: 0x5a, 
	CentralScene: 0x5b, 
	IpAssociation: 0x5c, 
	Antitheft: 0x5d, 
	ZwaveplusInfo: 0x5e, 
	ZipGateway: 0x5f, 
	MultiChannel: 0x60, 
	ZipPortal: 0x61, 
	DoorLock: 0x62, 
	UserCode: 0x63, 
	HumidityControlSetpoint: 0x64, 
	Dmx: 0x65, 
	BarrierOperator: 0x66, 
	NetworkManagementInstallationMaintenance: 0x67, 
	ZipNaming: 0x68, 
	Mailbox: 0x69, 
	WindowCovering: 0x6a, 
	Irrigation: 0x6b, 
	Supervision: 0x6c, 
	HumidityControlMode: 0x6d, 
	HumidityControlOperatingState: 0x6e, 
	EntryControl: 0x6f, 
	Configuration: 0x70, 
	Alarm: 0x71, 
	ManufacturerSpecific: 0x72, 
	Powerlevel: 0x73, 
	InclusionController: 0x74, 
	Protection: 0x75, 
	Lock: 0x76, 
	NodeNaming: 0x77, 
	FirmwareUpdateMd: 0x7a, 
	GroupingName: 0x7b, 
	RemoteAssociationActivate: 0x7c, 
	RemoteAssociation: 0x7d, 
	Battery: 0x80, 
	Clock: 0x81, 
	Hail: 0x82, 
	WakeUp: 0x84, 
	Association: 0x85, 
	Version: 0x86, 
	Indicator: 0x87, 
	Proprietary: 0x88, 
	Language: 0x89, 
	Time: 0x8a, 
	TimeParameters: 0x8b, 
	GeographicLocation: 0x8c, 
	MultiChannelAssociation: 0x8e, 
	MultiCmd: 0x8f, 
	EnergyProduction: 0x90, 
	ManufacturerProprietary: 0x91, 
	ScreenMd: 0x92, 
	ScreenAttributes: 0x93, 
	SimpleAvControl: 0x94, 
	AvContentDirectoryMd: 0x95, 
	AvRendererStatus: 0x96, 
	AvContentSearchMd: 0x97, 
	Security: 0x98, 
	AvTaggingMd: 0x99, 
	IpConfiguration: 0x9a, 
	AssociationCommandConfiguration: 0x9b, 
	SensorAlarm: 0x9c, 
	SilenceAlarm: 0x9d, 
	SensorConfiguration: 0x9e, 
	Security2: 0x9f, 
	Mark: 0xef, 
	NonInteroperable: 0xf0, 
	enum: {
		0x00: "NoOperation", 
		0x01: "Class", 
		0x02: "ZensorNet", 
		0x20: "Basic", 
		0x21: "ControllerReplication", 
		0x22: "ApplicationStatus", 
		0x23: "Zip", 
		0x24: "SecurityPanelMode", 
		0x25: "SwitchBinary", 
		0x26: "SwitchMultilevel", 
		0x27: "SwitchAll", 
		0x28: "SwitchToggleBinary", 
		0x29: "SwitchToggleMultilevel", 
		0x2a: "ChimneyFan", 
		0x2b: "SceneActivation", 
		0x2c: "SceneActuatorConf", 
		0x2d: "SceneControllerConf", 
		0x2e: "SecurityPanelZone", 
		0x2f: "SecurityPanelZoneSensor", 
		0x30: "SensorBinary", 
		0x31: "SensorMultilevel", 
		0x32: "Meter", 
		0x33: "SwitchColor", 
		0x34: "NetworkManagementInclusion", 
		0x35: "MeterPulse", 
		0x36: "BasicTariffInfo", 
		0x37: "HrvStatus", 
		0x38: "ThermostatHeating", 
		0x39: "HrvControl", 
		0x3a: "DcpConfig", 
		0x3b: "DcpMonitor", 
		0x3c: "MeterTblConfig", 
		0x3d: "MeterTblMonitor", 
		0x3e: "MeterTblPush", 
		0x3f: "Prepayment", 
		0x40: "ThermostatMode", 
		0x41: "PrepaymentEncapsulation", 
		0x42: "ThermostatOperatingState", 
		0x43: "ThermostatSetpoint", 
		0x44: "ThermostatFanMode", 
		0x45: "ThermostatFanState", 
		0x46: "ClimateControlSchedule", 
		0x47: "ThermostatSetback", 
		0x48: "RateTblConfig", 
		0x49: "RateTblMonitor", 
		0x4a: "TariffConfig", 
		0x4b: "TariffTblMonitor", 
		0x4c: "DoorLockLogging", 
		0x4d: "NetworkManagementBasic", 
		0x4e: "ScheduleEntryLock", 
		0x4f: "Zip6lowpan", 
		0x50: "BasicWindowCovering", 
		0x51: "MtpWindowCovering", 
		0x52: "NetworkManagementProxy", 
		0x53: "Schedule", 
		0x54: "NetworkManagementPrimary", 
		0x55: "TransportService", 
		0x56: "Crc16Encap", 
		0x57: "ApplicationCapability", 
		0x58: "ZipNd", 
		0x59: "AssociationGrpInfo", 
		0x5a: "DeviceResetLocally", 
		0x5b: "CentralScene", 
		0x5c: "IpAssociation", 
		0x5d: "Antitheft", 
		0x5e: "ZwaveplusInfo", 
		0x5f: "ZipGateway", 
		0x60: "MultiChannel", 
		0x61: "ZipPortal", 
		0x62: "DoorLock", 
		0x63: "UserCode", 
		0x64: "HumidityControlSetpoint", 
		0x65: "Dmx", 
		0x66: "BarrierOperator", 
		0x67: "NetworkManagementInstallationMaintenance", 
		0x68: "ZipNaming", 
		0x69: "Mailbox", 
		0x6a: "WindowCovering", 
		0x6b: "Irrigation", 
		0x6c: "Supervision", 
		0x6d: "HumidityControlMode", 
		0x6e: "HumidityControlOperatingState", 
		0x6f: "EntryControl", 
		0x70: "Configuration", 
		0x71: "Alarm", 
		0x72: "ManufacturerSpecific", 
		0x73: "Powerlevel", 
		0x74: "InclusionController", 
		0x75: "Protection", 
		0x76: "Lock", 
		0x77: "NodeNaming", 
		0x7a: "FirmwareUpdateMd", 
		0x7b: "GroupingName", 
		0x7c: "RemoteAssociationActivate", 
		0x7d: "RemoteAssociation", 
		0x80: "Battery", 
		0x81: "Clock", 
		0x82: "Hail", 
		0x84: "WakeUp", 
		0x85: "Association", 
		0x86: "Version", 
		0x87: "Indicator", 
		0x88: "Proprietary", 
		0x89: "Language", 
		0x8a: "Time", 
		0x8b: "TimeParameters", 
		0x8c: "GeographicLocation", 
		0x8e: "MultiChannelAssociation", 
		0x8f: "MultiCmd", 
		0x90: "EnergyProduction", 
		0x91: "ManufacturerProprietary", 
		0x92: "ScreenMd", 
		0x93: "ScreenAttributes", 
		0x94: "SimpleAvControl", 
		0x95: "AvContentDirectoryMd", 
		0x96: "AvRendererStatus", 
		0x97: "AvContentSearchMd", 
		0x98: "Security", 
		0x99: "AvTaggingMd", 
		0x9a: "IpConfiguration", 
		0x9b: "AssociationCommandConfiguration", 
		0x9c: "SensorAlarm", 
		0x9d: "SilenceAlarm", 
		0x9e: "SensorConfiguration", 
		0x9f: "Security2", 
		0xef: "Mark", 
		0xf0: "NonInteroperable"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_AV_CONTROL_POINT = {
	NotUsed: 0x00, 
	SatelliteReceiver: 0x04, 
	SatelliteReceiverV2: 0x11, 
	Doorbell: 0x12, 
	enum: {
		0x00: "NotUsed", 
		0x04: "SatelliteReceiver", 
		0x11: "SatelliteReceiverV2", 
		0x12: "Doorbell"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_DISPLAY = {
	NotUsed: 0x00, 
	SimpleDisplay: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SimpleDisplay"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ENTRY_CONTROL = {
	NotUsed: 0x00, 
	DoorLock: 0x01, 
	AdvancedDoorLock: 0x02, 
	SecureKeypadDoorLock: 0x03, 
	SecureKeypadDoorLockDeadbolt: 0x04, 
	SecureDoor: 0x05, 
	SecureGate: 0x06, 
	SecureBarrierAddon: 0x07, 
	SecureBarrierOpenOnly: 0x08, 
	SecureBarrierCloseOnly: 0x09, 
	SecureLockbox: 0x0a, 
	SecureKeypad: 0x0b, 
	enum: {
		0x00: "NotUsed", 
		0x01: "DoorLock", 
		0x02: "AdvancedDoorLock", 
		0x03: "SecureKeypadDoorLock", 
		0x04: "SecureKeypadDoorLockDeadbolt", 
		0x05: "SecureDoor", 
		0x06: "SecureGate", 
		0x07: "SecureBarrierAddon", 
		0x08: "SecureBarrierOpenOnly", 
		0x09: "SecureBarrierCloseOnly", 
		0x0a: "SecureLockbox", 
		0x0b: "SecureKeypad"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_GENERIC_CONTROLLER = {
	NotUsed: 0x00, 
	PortableRemoteController: 0x01, 
	PortableSceneController: 0x02, 
	PortableInstallerTool: 0x03, 
	RemoteControlAv: 0x04, 
	RemoteControlSimple: 0x06, 
	enum: {
		0x00: "NotUsed", 
		0x01: "PortableRemoteController", 
		0x02: "PortableSceneController", 
		0x03: "PortableInstallerTool", 
		0x04: "RemoteControlAv", 
		0x06: "RemoteControlSimple"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER = {
	NotUsed: 0x00, 
	SimpleMeter: 0x01, 
	AdvEnergyControl: 0x02, 
	WholeHomeMeterSimple: 0x03, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SimpleMeter", 
		0x02: "AdvEnergyControl", 
		0x03: "WholeHomeMeterSimple"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER_PULSE = {
	NotUsed: 0x00, 
	enum: {
		0x00: "NotUsed"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_REPEATER_SLAVE = {
	NotUsed: 0x00, 
	RepeaterSlave: 0x01, 
	VirtualNode: 0x02, 
	enum: {
		0x00: "NotUsed", 
		0x01: "RepeaterSlave", 
		0x02: "VirtualNode"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SECURITY_PANEL = {
	NotUsed: 0x00, 
	ZonedSecurityPanel: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "ZonedSecurityPanel"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SEMI_INTEROPERABLE = {
	NotUsed: 0x00, 
	EnergyProduction: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "EnergyProduction"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_ALARM = {
	NotUsed: 0x00, 
	BasicRoutingAlarmSensor: 0x01, 
	RoutingAlarmSensor: 0x02, 
	BasicZensorNetAlarmSensor: 0x03, 
	ZensorNetAlarmSensor: 0x04, 
	AdvZensorNetAlarmSensor: 0x05, 
	BasicRoutingSmokeSensor: 0x06, 
	RoutingSmokeSensor: 0x07, 
	BasicZensorNetSmokeSensor: 0x08, 
	ZensorNetSmokeSensor: 0x09, 
	AdvZensorNetSmokeSensor: 0x0a, 
	AlarmSensor: 0x0b, 
	enum: {
		0x00: "NotUsed", 
		0x01: "BasicRoutingAlarmSensor", 
		0x02: "RoutingAlarmSensor", 
		0x03: "BasicZensorNetAlarmSensor", 
		0x04: "ZensorNetAlarmSensor", 
		0x05: "AdvZensorNetAlarmSensor", 
		0x06: "BasicRoutingSmokeSensor", 
		0x07: "RoutingSmokeSensor", 
		0x08: "BasicZensorNetSmokeSensor", 
		0x09: "ZensorNetSmokeSensor", 
		0x0a: "AdvZensorNetSmokeSensor", 
		0x0b: "AlarmSensor"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_BINARY = {
	NotUsed: 0x00, 
	RoutingSensorBinary: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "RoutingSensorBinary"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_MULTILEVEL = {
	NotUsed: 0x00, 
	RoutingSensorMultilevel: 0x01, 
	ChimneyFan: 0x02, 
	enum: {
		0x00: "NotUsed", 
		0x01: "RoutingSensorMultilevel", 
		0x02: "ChimneyFan"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_STATIC_CONTROLLER = {
	NotUsed: 0x00, 
	PcController: 0x01, 
	SceneController: 0x02, 
	StaticInstallerTool: 0x03, 
	SetTopBox: 0x04, 
	SubSystemController: 0x05, 
	Tv: 0x06, 
	Gateway: 0x07, 
	enum: {
		0x00: "NotUsed", 
		0x01: "PcController", 
		0x02: "SceneController", 
		0x03: "StaticInstallerTool", 
		0x04: "SetTopBox", 
		0x05: "SubSystemController", 
		0x06: "Tv", 
		0x07: "Gateway"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_BINARY = {
	NotUsed: 0x00, 
	PowerSwitchBinary: 0x01, 
	ColorTunableBinary: 0x02, 
	SceneSwitchBinary: 0x03, 
	PowerStrip: 0x04, 
	Siren: 0x05, 
	ValveOpenClose: 0x06, 
	IrrigationController: 0x07, 
	enum: {
		0x00: "NotUsed", 
		0x01: "PowerSwitchBinary", 
		0x02: "ColorTunableBinary", 
		0x03: "SceneSwitchBinary", 
		0x04: "PowerStrip", 
		0x05: "Siren", 
		0x06: "ValveOpenClose", 
		0x07: "IrrigationController"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_MULTILEVEL = {
	NotUsed: 0x00, 
	PowerSwitchMultilevel: 0x01, 
	ColorTunableMultilevel: 0x02, 
	MotorMultiposition: 0x03, 
	SceneSwitchMultilevel: 0x04, 
	ClassAMotorControl: 0x05, 
	ClassBMotorControl: 0x06, 
	ClassCMotorControl: 0x07, 
	FanSwitch: 0x08, 
	enum: {
		0x00: "NotUsed", 
		0x01: "PowerSwitchMultilevel", 
		0x02: "ColorTunableMultilevel", 
		0x03: "MotorMultiposition", 
		0x04: "SceneSwitchMultilevel", 
		0x05: "ClassAMotorControl", 
		0x06: "ClassBMotorControl", 
		0x07: "ClassCMotorControl", 
		0x08: "FanSwitch"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_REMOTE = {
	NotUsed: 0x00, 
	SwitchRemoteBinary: 0x01, 
	SwitchRemoteMultilevel: 0x02, 
	SwitchRemoteToggleBinary: 0x03, 
	SwitchRemoteToggleMultilevel: 0x04, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SwitchRemoteBinary", 
		0x02: "SwitchRemoteMultilevel", 
		0x03: "SwitchRemoteToggleBinary", 
		0x04: "SwitchRemoteToggleMultilevel"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_TOGGLE = {
	NotUsed: 0x00, 
	SwitchToggleBinary: 0x01, 
	SwitchToggleMultilevel: 0x02, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SwitchToggleBinary", 
		0x02: "SwitchToggleMultilevel"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_THERMOSTAT = {
	NotUsed: 0x00, 
	ThermostatHeating: 0x01, 
	ThermostatGeneral: 0x02, 
	SetbackScheduleThermostat: 0x03, 
	SetpointThermostat: 0x04, 
	SetbackThermostat: 0x05, 
	ThermostatGeneralV2: 0x06, 
	enum: {
		0x00: "NotUsed", 
		0x01: "ThermostatHeating", 
		0x02: "ThermostatGeneral", 
		0x03: "SetbackScheduleThermostat", 
		0x04: "SetpointThermostat", 
		0x05: "SetbackThermostat", 
		0x06: "ThermostatGeneralV2"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_VENTILATION = {
	NotUsed: 0x00, 
	ResidentialHrv: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "ResidentialHrv"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WINDOW_COVERING = {
	NotUsed: 0x00, 
	SimpleWindowCovering: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SimpleWindowCovering"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ZIP_NODE = {
	NotUsed: 0x00, 
	ZipTunNode: 0x01, 
	ZipAdvNode: 0x02, 
	enum: {
		0x00: "NotUsed", 
		0x01: "ZipTunNode", 
		0x02: "ZipAdvNode"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WALL_CONTROLLER = {
	NotUsed: 0x00, 
	BasicWallController: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "BasicWallController"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_NETWORK_EXTENDER = {
	NotUsed: 0x00, 
	SecureExtender: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "SecureExtender"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_APPLIANCE = {
	NotUsed: 0x00, 
	GeneralAppliance: 0x01, 
	KitchenAppliance: 0x02, 
	LaundryAppliance: 0x03, 
	enum: {
		0x00: "NotUsed", 
		0x01: "GeneralAppliance", 
		0x02: "KitchenAppliance", 
		0x03: "LaundryAppliance"
	}
};

const ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_NOTIFICATION = {
	NotUsed: 0x00, 
	NotificationSensor: 0x01, 
	enum: {
		0x00: "NotUsed", 
		0x01: "NotificationSensor"
	}
};

const MULTI_ARRAY_ZWAVE_CMD_CLASS_NODE_INFO_ZWAVE_SPECIFIC_DEVICE = {
	0x00: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER_PULSE,
	0x01: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_GENERIC_CONTROLLER,
	0x02: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_STATIC_CONTROLLER,
	0x03: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_AV_CONTROL_POINT,
	0x04: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_DISPLAY,
	0x05: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_NETWORK_EXTENDER,
	0x06: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_APPLIANCE,
	0x07: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_NOTIFICATION,
	0x08: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_THERMOSTAT,
	0x09: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WINDOW_COVERING,
	0x0f: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_REPEATER_SLAVE,
	0x10: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_BINARY,
	0x11: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_MULTILEVEL,
	0x12: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_REMOTE,
	0x13: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_TOGGLE,
	0x15: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ZIP_NODE,
	0x16: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_VENTILATION,
	0x17: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SECURITY_PANEL,
	0x18: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WALL_CONTROLLER,
	0x20: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_BINARY,
	0x21: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_MULTILEVEL,
	0x30: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER_PULSE,
	0x31: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER,
	0x40: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ENTRY_CONTROL,
	0x50: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SEMI_INTEROPERABLE,
	0xa1: ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_ALARM
};
// ZWAVE_CMD_CLASS [0x01] REQUEST_NODE_INFO [0x02] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x02] = {
	name: "REQUEST_NODE_INFO",
	help: "Request Node Info",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ASSIGN_ID [0x03] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x03] = {
	name: "ASSIGN_ID",
	help: "Assign Id",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] FIND_NODES_IN_RANGE [0x04] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x04] = {
	name: "FIND_NODES_IN_RANGE",
	help: "Find Nodes In Range",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] GET_NODES_IN_RANGE [0x05] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x05] = {
	name: "GET_NODES_IN_RANGE",
	help: "Get Nodes In Range",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NODE_RANGE_INFO [0x06] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x06] = {
	name: "NODE_RANGE_INFO",
	help: "Node Range Info",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] COMMAND_COMPLETE [0x07] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x07] = {
	name: "COMMAND_COMPLETE",
	help: "Command Complete",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] TRANSFER_PRESENTATION [0x08] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x08] = {
	name: "TRANSFER_PRESENTATION",
	help: "Transfer Presentation",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] TRANSFER_NODE_INFO [0x09] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x09] = {
	name: "TRANSFER_NODE_INFO",
	help: "Transfer Node Info",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] TRANSFER_RANGE_INFO [0x0a] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0a] = {
	name: "TRANSFER_RANGE_INFO",
	help: "Transfer Range Info",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] TRANSFER_END [0x0b] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0b] = {
	name: "TRANSFER_END",
	help: "Transfer End",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ASSIGN_RETURN_ROUTE [0x0c] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0c] = {
	name: "ASSIGN_RETURN_ROUTE",
	help: "Assign Return Route",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NEW_NODE_REGISTERED [0x0d] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0d] = {
	name: "NEW_NODE_REGISTERED",
	help: "New Node Registered",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NEW_RANGE_REGISTERED [0x0e] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0e] = {
	name: "NEW_RANGE_REGISTERED",
	help: "New Range Registered",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] TRANSFER_NEW_PRIMARY_COMPLETE [0x0f] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x0f] = {
	name: "TRANSFER_NEW_PRIMARY_COMPLETE",
	help: "Transfer New Primary Complete",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] AUTOMATIC_CONTROLLER_UPDATE_START [0x10] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x10] = {
	name: "AUTOMATIC_CONTROLLER_UPDATE_START",
	help: "Automatic Controller Update Start",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] SUC_NODE_ID [0x11] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x11] = {
	name: "SUC_NODE_ID",
	help: "SUC Node ID",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] SET_SUC [0x12] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x12] = {
	name: "SET_SUC",
	help: "Set SUC",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] SET_SUC_ACK [0x13] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x13] = {
	name: "SET_SUC_ACK",
	help: "Set SUC ACK",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ASSIGN_SUC_RETURN_ROUTE [0x14] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x14] = {
	name: "ASSIGN_SUC_RETURN_ROUTE",
	help: "Assign SUC Return Route",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] STATIC_ROUTE_REQUEST [0x15] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x15] = {
	name: "STATIC_ROUTE_REQUEST",
	help: "Static Route Request",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] LOST [0x16] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x16] = {
	name: "LOST",
	help: "Lost",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ACCEPT_LOST [0x17] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x17] = {
	name: "ACCEPT_LOST",
	help: "Accept Lost",
	comment: "SDS10264-2",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NOP_POWER [0x18] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x18] = {
	name: "NOP_POWER",
	help: "NOP Power",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] RESERVE_NODE_IDS [0x19] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x19] = {
	name: "RESERVE_NODE_IDS",
	help: "Reserve Node ID",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] RESERVED_IDS [0x1a] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x1a] = {
	name: "RESERVED_IDS",
	help: "Reserved ID",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NODES_EXIST [0x1f] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x1f] = {
	name: "NODES_EXIST",
	help: "Cmd Nodes Exist",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] NODES_EXIST_REPLY [0x20] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x20] = {
	name: "NODES_EXIST_REPLY",
	help: "Cmd Nodes Exist Reply",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] SET_NWI_MODE [0x22] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x22] = {
	name: "SET_NWI_MODE",
	help: "Cmd Set Nwi Mode",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] EXCLUDE_REQUEST [0x23] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x23] = {
	name: "EXCLUDE_REQUEST",
	help: "Exclude Request",
	comment: "INS13044",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ASSIGN_RETURN_ROUTE_PRIORITY [0x24] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x24] = {
	name: "ASSIGN_RETURN_ROUTE_PRIORITY",
	help: "Assign Return Route Priority",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVE_CMD_CLASS [0x01] ASSIGN_SUC_RETURN_ROUTE_PRIORITY [0x25] COMMAND 
COMMAND_CLASS.enum[0x01].command[0x25] = {
	name: "ASSIGN_SUC_RETURN_ROUTE_PRIORITY",
	help: "Assign SUC Return Route Priority",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x02 ZENSOR_NET COMMANDS
 */

// ZENSOR_NET [0x02] BIND_REQUEST [0x01] COMMAND 
COMMAND_CLASS.enum[0x02].command[0x01] = {
	name: "BIND_REQUEST",
	help: "Bind Request",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZENSOR_NET [0x02] BIND_ACCEPT [0x02] COMMAND 
COMMAND_CLASS.enum[0x02].command[0x02] = {
	name: "BIND_ACCEPT",
	help: "Bind Accept",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZENSOR_NET [0x02] BIND_COMPLETE [0x03] COMMAND 
COMMAND_CLASS.enum[0x02].command[0x03] = {
	name: "BIND_COMPLETE",
	help: "Bind Complete",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x20 BASIC COMMANDS
 */

// BASIC [0x20] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x20].command[0x01] = {
	name: "SET",
	help: "Basic Set",
	param: { 
		'0x00': {name: "Value" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(context['Value']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readBYTE(); else return context;
		return context;
	}
};

// BASIC [0x20] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x20].command[0x02] = {
	name: "GET",
	help: "Basic Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// BASIC [0x20] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x20].command[0x03] = {
	name: "REPORT",
	help: "Basic Report",
	param: { 
		'0x00': {name: "CurrentValue" /* BYTE */ }, 
		'0x01': {name: "TargetValue" /* BYTE */ }, 
		'0x02': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CurrentValue' in context) payload.writeBYTE(context['CurrentValue']); else return payload.asBuffer();
		if ('TargetValue' in context) payload.writeBYTE(context['TargetValue']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['CurrentValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['TargetValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x21 CONTROLLER_REPLICATION COMMANDS
 */

// CONTROLLER_REPLICATION [0x21] CTRL_REPLICATION_TRANSFER_GROUP [0x31] COMMAND 
COMMAND_CLASS.enum[0x21].command[0x31] = {
	name: "CTRL_REPLICATION_TRANSFER_GROUP",
	help: "Ctrl Replication Transfer Group",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01': {name: "GroupId" /* BYTE */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('GroupId' in context) payload.writeBYTE(context['GroupId']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GroupId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CONTROLLER_REPLICATION [0x21] CTRL_REPLICATION_TRANSFER_GROUP_NAME [0x32] COMMAND 
COMMAND_CLASS.enum[0x21].command[0x32] = {
	name: "CTRL_REPLICATION_TRANSFER_GROUP_NAME",
	help: "Ctrl Replication Transfer Group Name",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01': {name: "GroupId" /* BYTE */ }, 
		'0x02': {name: "GroupName" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('GroupId' in context) payload.writeBYTE(context['GroupId']); else return payload.asBuffer();
		if ('GroupName' in context) payload.writeSTRING(context['GroupName'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GroupId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GroupName'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};

// CONTROLLER_REPLICATION [0x21] CTRL_REPLICATION_TRANSFER_SCENE [0x33] COMMAND 
COMMAND_CLASS.enum[0x21].command[0x33] = {
	name: "CTRL_REPLICATION_TRANSFER_SCENE",
	help: "Ctrl Replication Transfer Scene",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01': {name: "SceneId" /* BYTE */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x03': {name: "Level" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('Level' in context) payload.writeBYTE(context['Level']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Level'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CONTROLLER_REPLICATION [0x21] CTRL_REPLICATION_TRANSFER_SCENE_NAME [0x34] COMMAND 
COMMAND_CLASS.enum[0x21].command[0x34] = {
	name: "CTRL_REPLICATION_TRANSFER_SCENE_NAME",
	help: "Ctrl Replication Transfer Scene Name",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01': {name: "SceneId" /* BYTE */ }, 
		'0x02': {name: "SceneName" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('SceneName' in context) payload.writeSTRING(context['SceneName'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SceneName'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x22 APPLICATION_STATUS COMMANDS
 */

// APPLICATION_STATUS [0x22] APPLICATION_BUSY [0x01] COMMAND 
COMMAND_CLASS.enum[0x22].command[0x01] = {
	name: "APPLICATION_BUSY",
	help: "Application Busy",
	param: { 
		'0x00': {name: "Status" /* CONST */ }, 
		'0x01': {name: "WaitTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_APPLICATION_STATUS_APPLICATION_BUSY_STATUS)); else return payload.asBuffer();
		if ('WaitTime' in context) payload.writeBYTE(context['WaitTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_APPLICATION_STATUS_APPLICATION_BUSY_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['WaitTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_APPLICATION_STATUS_APPLICATION_BUSY_STATUS = {
	TryAgainLater: 0x00, 
	TryAgainInWaitTimeSeconds: 0x01, 
	RequestQueuedExecutedLater: 0x02, 
	enum: {
		0x00: "TryAgainLater", 
		0x01: "TryAgainInWaitTimeSeconds", 
		0x02: "RequestQueuedExecutedLater"
	}
};

// APPLICATION_STATUS [0x22] APPLICATION_REJECTED_REQUEST [0x02] COMMAND 
COMMAND_CLASS.enum[0x22].command[0x02] = {
	name: "APPLICATION_REJECTED_REQUEST",
	help: "Application Rejected Request",
	param: { 
		'0x00': {name: "Status" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(context['Status']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x23 ZIP COMMANDS
 */

// ZIP [0x23] COMMAND_ZIP_PACKET [0x02] COMMAND 
COMMAND_CLASS.enum[0x23].command[0x02] = {
	name: "COMMAND_ZIP_PACKET",
	help: "Zip Packet",
	param: { 
		'0x00a': {name: "NackOptionError" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "NackQueueFull" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "NackWaiting" /* Properties1 STRUCT_BYTE */ }, 
		'0x00d': {name: "NackResponse" /* Properties1 STRUCT_BYTE */ }, 
		'0x00e': {name: "AckResponse" /* Properties1 STRUCT_BYTE */ }, 
		'0x00f': {name: "AckRequest" /* Properties1 STRUCT_BYTE */ }, 
		'0x00g': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "SecureOrigin" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "MoreInformation" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "CmdIncluded" /* Properties2 STRUCT_BYTE */ }, 
		'0x01d': {name: "HeaderExtIncluded" /* Properties2 STRUCT_BYTE */ }, 
		'0x01e': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "SeqNo" /* BYTE */ }, 
		'0x03a': {name: "Reserved3" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "SourceEndPoint" /* Properties3 STRUCT_BYTE */ }, 
		'0x04a': {name: "BitAddress" /* Properties4 STRUCT_BYTE */ }, 
		'0x04b': {name: "DestinationEndPoint" /* Properties4 STRUCT_BYTE */ }, 
		'0x05': {name: "HeaderLength" /* BYTE */ }, 
		'0x06': {name: "HeaderExtension" /* VARIANT */ }, 
		'0x07': {name: "Command" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NackOptionError' in context || 'NackQueueFull' in context || 'NackWaiting' in context || 'NackResponse' in context || 'AckResponse' in context || 'AckRequest' in context || 'Reserved1' in context) {
			let _properties1 = 0x00;
			if (context['NackOptionError']) _properties1 = _properties1 | 0x04;
			if (context['NackQueueFull']) _properties1 = _properties1 | 0x08;
			if (context['NackWaiting']) _properties1 = _properties1 | 0x10;
			if (context['NackResponse']) _properties1 = _properties1 | 0x20;
			if (context['AckResponse']) _properties1 = _properties1 | 0x40;
			if (context['AckRequest']) _properties1 = _properties1 | 0x80;
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1']) & 0x03);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SecureOrigin' in context || 'MoreInformation' in context || 'CmdIncluded' in context || 'HeaderExtIncluded' in context || 'Reserved2' in context) {
			let _properties2 = 0x00;
			if (context['SecureOrigin']) _properties2 = _properties2 | 0x10;
			if (context['MoreInformation']) _properties2 = _properties2 | 0x20;
			if (context['CmdIncluded']) _properties2 = _properties2 | 0x40;
			if (context['HeaderExtIncluded']) _properties2 = _properties2 | 0x80;
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2']) & 0x0f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved3' in context || 'SourceEndPoint' in context) {
			let _properties3 = 0x00;
			if (context['Reserved3']) _properties3 = _properties3 | 0x80;
			if ('SourceEndPoint' in context) _properties3 = _properties3 | ((context['SourceEndPoint']) & 0x7f);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('BitAddress' in context || 'DestinationEndPoint' in context) {
			let _properties4 = 0x00;
			if (context['BitAddress']) _properties4 = _properties4 | 0x80;
			if ('DestinationEndPoint' in context) _properties4 = _properties4 | ((context['DestinationEndPoint']) & 0x7f);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ((payload.at(1) & 0x80) !== 0) /* optional flag for HeaderLength */ {
			if ('HeaderLength' in context) payload.writeBYTE(context['HeaderLength']); else return payload.asBuffer();
		}
		if ((payload.at(1) & 0x80) !== 0) /* optional flag for HeaderExtension */ {
			if ('HeaderExtension' in context) payload.writeSTRING(context['HeaderExtension'], { encoding: 'hex', length: (payload.at(5) & 0xff) -1 }); else return payload.asBuffer();
		}
		if ((payload.at(1) & 0x40) !== 0) /* optional flag for Command */ {
			if ('Command' in context) payload.writeSTRING(context['Command'], { encoding: 'hex' }); else return payload.asBuffer();
		}
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NackOptionError'] = ((_properties1 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NackQueueFull'] = ((_properties1 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NackWaiting'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NackResponse'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AckResponse'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AckRequest'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0x03); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SecureOrigin'] = ((_properties2 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MoreInformation'] = ((_properties2 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['CmdIncluded'] = ((_properties2 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HeaderExtIncluded'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0x0f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved3'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SourceEndPoint'] = (_properties3 & 0x7f); else return context;
		}
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['BitAddress'] = ((_properties4 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['DestinationEndPoint'] = (_properties4 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['HeaderLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HeaderExtension'] = payload.readSTRING({ encoding: 'hex', length: payload.at(5) & 0xff }); else return context;
		if (!payload.insufficientBytes(1)) context['Command'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x24 SECURITY_PANEL_MODE COMMANDS
 */

// SECURITY_PANEL_MODE [0x24] SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x24].command[0x01] = {
	name: "SUPPORTED_GET",
	help: "Security Panel Mode Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_PANEL_MODE [0x24] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x24].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Security Panel Mode Supported Report",
	param: { 
		'0x00': {name: "SupportedModeBitMask" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedModeBitMask' in context) payload.writeWORD(context['SupportedModeBitMask']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedModeBitMask'] = payload.readWORD(); else return context;
		return context;
	}
};

// SECURITY_PANEL_MODE [0x24] GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x24].command[0x03] = {
	name: "GET",
	help: "Security Panel Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_PANEL_MODE [0x24] REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x24].command[0x04] = {
	name: "REPORT",
	help: "Security Panel Mode Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SECURITY_PANEL_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_PANEL_MODE.enum); else return context;
		return context;
	}
};

const ENUM_SECURITY_PANEL_MODE = {
	ArmHome: 0x01, 
	ArmAwayNoDelay: 0x02, 
	ArmAwayDelayed: 0x03, 
	Disarm: 0x04, 
	AlarmTrigger: 0x05, 
	enum: {
		0x01: "ArmHome", 
		0x02: "ArmAwayNoDelay", 
		0x03: "ArmAwayDelayed", 
		0x04: "Disarm", 
		0x05: "AlarmTrigger"
	}
};

// SECURITY_PANEL_MODE [0x24] SET [0x05] COMMAND 
COMMAND_CLASS.enum[0x24].command[0x05] = {
	name: "SET",
	help: "Security Panel Mode Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SECURITY_PANEL_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_PANEL_MODE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x25 SWITCH_BINARY COMMANDS
 */

// SWITCH_BINARY [0x25] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x25].command[0x01] = {
	name: "SET",
	help: "Switch Binary Set",
	param: { 
		'0x00': {name: "TargetValue" /* CONST */ }, 
		'0x01': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('TargetValue' in context) payload.writeBYTE(helpers.getValue(context, 'TargetValue', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['TargetValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_DURATION.enum); else return context;
		return context;
	}
};

const ENUM_SWITCH_BINARY_TARGET_VALUE = {
	OffDisable: 0x00, 
	OnEnable: 0xff, 
	enum: {
		0x00: "OffDisable", 
		0xff: "OnEnable"
	}
};

const ENUM_SWITCH_BINARY_DURATION = {
	Instantly: 0x00, 
	Default: 0xff, 
	enum: {
		0x00: "Instantly", 
		0xff: "Default"
	}
};

// SWITCH_BINARY [0x25] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x25].command[0x02] = {
	name: "GET",
	help: "Switch Binary Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_BINARY [0x25] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x25].command[0x03] = {
	name: "REPORT",
	help: "Switch Binary Report",
	param: { 
		'0x00': {name: "CurrentValue" /* CONST */ }, 
		'0x01': {name: "TargetValue" /* CONST */ }, 
		'0x02': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CurrentValue' in context) payload.writeBYTE(helpers.getValue(context, 'CurrentValue', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('TargetValue' in context) payload.writeBYTE(helpers.getValue(context, 'TargetValue', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_REPORT_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['CurrentValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['TargetValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_REPORT_DURATION.enum); else return context;
		return context;
	}
};

const ENUM_SWITCH_BINARY_REPORT_DURATION = {
	AlreadyAtTheTargetValue: 0x00, 
	UnknownDuration: 0xfe, 
	Reserved: 0xff, 
	enum: {
		0x00: "AlreadyAtTheTargetValue", 
		0xfe: "UnknownDuration", 
		0xff: "Reserved"
	}
};



/*
 * COMMAND_CLASS 0x26 SWITCH_MULTILEVEL COMMANDS
 */

// SWITCH_MULTILEVEL [0x26] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x01] = {
	name: "SET",
	help: "Switch Multilevel Set",
	param: { 
		'0x00': {name: "Value" /* CONST */ }, 
		'0x01': {name: "DimmingDuration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(helpers.getValue(context, 'Value', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SWITCH_BINARY_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_DURATION.enum); else return context;
		return context;
	}
};

// SWITCH_MULTILEVEL [0x26] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x02] = {
	name: "GET",
	help: "Switch Multilevel Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_MULTILEVEL [0x26] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x03] = {
	name: "REPORT",
	help: "Switch Multilevel Report",
	param: { 
		'0x00': {name: "CurrentValue" /* CONST */ }, 
		'0x01': {name: "TargetValue" /* BYTE */ }, 
		'0x02': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CurrentValue' in context) payload.writeBYTE(helpers.getValue(context, 'CurrentValue', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('TargetValue' in context) payload.writeBYTE(context['TargetValue']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_REPORT_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['CurrentValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['TargetValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_REPORT_DURATION.enum); else return context;
		return context;
	}
};

// SWITCH_MULTILEVEL [0x26] START_LEVEL_CHANGE [0x04] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x04] = {
	name: "START_LEVEL_CHANGE",
	help: "Switch Multilevel Start Level Change",
	param: { 
		'0x00a': {name: "IncDec" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "UpDown" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "IgnoreStartLevel" /* Properties1 STRUCT_BYTE */ }, 
		'0x00d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "StartLevel" /* BYTE */ }, 
		'0x02': {name: "DimmingDuration" /* BYTE */ }, 
		'0x03': {name: "StepSize" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IncDec' in context || 'UpDown' in context || 'IgnoreStartLevel' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('IncDec' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'IncDec', ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_INC_DEC) << 3) & 0x18); 
			if ('UpDown' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'UpDown', ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_UP_DOWN) << 6) & 0xc0); 
			if (context['IgnoreStartLevel']) _properties1 = _properties1 | 0x20;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StartLevel' in context) payload.writeBYTE(context['StartLevel']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(context['DimmingDuration']); else return payload.asBuffer();
		if ('StepSize' in context) payload.writeBYTE(context['StepSize']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IncDec'] = helpers.lookupNameValue((_properties1 & 0x18) >> 3, ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_INC_DEC.enum); else return context;
			if (!payload.insufficientBytes(1)) context['UpDown'] = helpers.lookupNameValue((_properties1 & 0xc0) >> 6, ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_UP_DOWN.enum); else return context;
			if (!payload.insufficientBytes(1)) context['IgnoreStartLevel'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['StartLevel'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StepSize'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_INC_DEC = {
	Increment: 0x00, 
	Decrement: 0x01, 
	Reserved: 0x02, 
	None: 0x03, 
	enum: {
		0x00: "Increment", 
		0x01: "Decrement", 
		0x02: "Reserved", 
		0x03: "None"
	}
};

const ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_UP_DOWN = {
	Up: 0x00, 
	Down: 0x01, 
	Reserved: 0x02, 
	None: 0x03, 
	enum: {
		0x00: "Up", 
		0x01: "Down", 
		0x02: "Reserved", 
		0x03: "None"
	}
};

// SWITCH_MULTILEVEL [0x26] STOP_LEVEL_CHANGE [0x05] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x05] = {
	name: "STOP_LEVEL_CHANGE",
	help: "Switch Multilevel Stop Level Change",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_MULTILEVEL [0x26] SUPPORTED_GET [0x06] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x06] = {
	name: "SUPPORTED_GET",
	help: "Switch Multilevel Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_MULTILEVEL [0x26] SUPPORTED_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x26].command[0x07] = {
	name: "SUPPORTED_REPORT",
	help: "Switch Multilevel Supported Report",
	param: { 
		'0x00a': {name: "PrimarySwitchType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "SecondarySwitchType" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PrimarySwitchType' in context || 'Reserved1' in context) {
			let _properties1 = 0x00;
			if ('PrimarySwitchType' in context) _properties1 = _properties1 | ((context['PrimarySwitchType']) & 0x1f);
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SecondarySwitchType' in context || 'Reserved2' in context) {
			let _properties2 = 0x00;
			if ('SecondarySwitchType' in context) _properties2 = _properties2 | ((context['SecondarySwitchType']) & 0x1f);
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PrimarySwitchType'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SecondarySwitchType'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x27 SWITCH_ALL COMMANDS
 */

// SWITCH_ALL [0x27] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x27].command[0x01] = {
	name: "SET",
	help: "Switch All Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_ALL_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_ALL_MODE.enum); else return context;
		return context;
	}
};

const ENUM_SWITCH_ALL_MODE = {
	ExcludedFromTheAllOnallOffFunctionality: 0x00, 
	ExcludedFromTheAllOnFunctionalityButNotAllOff: 0x01, 
	ExcludedFromTheAllOffFunctionalityButNotAllOn: 0x02, 
	IncludedInTheAllOnallOffFunctionality: 0xff, 
	enum: {
		0x00: "ExcludedFromTheAllOnallOffFunctionality", 
		0x01: "ExcludedFromTheAllOnFunctionalityButNotAllOff", 
		0x02: "ExcludedFromTheAllOffFunctionalityButNotAllOn", 
		0xff: "IncludedInTheAllOnallOffFunctionality"
	}
};

// SWITCH_ALL [0x27] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x27].command[0x02] = {
	name: "GET",
	help: "Switch All Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_ALL [0x27] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x27].command[0x03] = {
	name: "REPORT",
	help: "Switch All Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_ALL_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_ALL_MODE.enum); else return context;
		return context;
	}
};

// SWITCH_ALL [0x27] ON [0x04] COMMAND 
COMMAND_CLASS.enum[0x27].command[0x04] = {
	name: "ON",
	help: "Switch All On",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_ALL [0x27] OFF [0x05] COMMAND 
COMMAND_CLASS.enum[0x27].command[0x05] = {
	name: "OFF",
	help: "Switch All Off",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x28 SWITCH_TOGGLE_BINARY COMMANDS
 */

// SWITCH_TOGGLE_BINARY [0x28] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x28].command[0x01] = {
	name: "SET",
	help: "Switch Toggle Binary Set",
	comment: "SWITCH_TOGGLE_BINARY_SET",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_TOGGLE_BINARY [0x28] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x28].command[0x02] = {
	name: "GET",
	help: "Switch Toggle Binary Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_TOGGLE_BINARY [0x28] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x28].command[0x03] = {
	name: "REPORT",
	help: "Switch Toggle Binary Report",
	param: { 
		'0x00': {name: "Value" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(helpers.getValue(context, 'Value', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		return context;
	}
};

const ENUM_SWITCH_TOGGLE_BINARY_VALUE = {
	Off: 0x00, 
	On: 0xff, 
	enum: {
		0x00: "Off", 
		0xff: "On"
	}
};



/*
 * COMMAND_CLASS 0x29 SWITCH_TOGGLE_MULTILEVEL COMMANDS
 */

// SWITCH_TOGGLE_MULTILEVEL [0x29] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x29].command[0x01] = {
	name: "SET",
	help: "Switch Toggle Multilevel Set",
	comment: "SWITCH_TOGGLE_MULTILEVEL_SET",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_TOGGLE_MULTILEVEL [0x29] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x29].command[0x02] = {
	name: "GET",
	help: "Switch Toggle Multilevel Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_TOGGLE_MULTILEVEL [0x29] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x29].command[0x03] = {
	name: "REPORT",
	help: "Switch Toggle Multilevel Report",
	param: { 
		'0x00': {name: "Value" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(helpers.getValue(context, 'Value', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		return context;
	}
};

// SWITCH_TOGGLE_MULTILEVEL [0x29] START_LEVEL_CHANGE [0x04] COMMAND 
COMMAND_CLASS.enum[0x29].command[0x04] = {
	name: "START_LEVEL_CHANGE",
	help: "Switch Toggle Multilevel Start Level Change",
	param: { 
		'0x00a': {name: "IgnoreStartLevel" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved2" /* Level STRUCT_BYTE */ }, 
		'0x00c': {name: "RollOver" /* Level STRUCT_BYTE */ }, 
		'0x00d': {name: "Reserved1" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "StartLevel" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IgnoreStartLevel' in context || 'Reserved2' in context || 'RollOver' in context || 'Reserved1' in context) {
			let _level = 0x00;
			if (context['IgnoreStartLevel']) _level = _level | 0x20;
			if (context['Reserved2']) _level = _level | 0x40;
			if (context['RollOver']) _level = _level | 0x80;
			if ('Reserved1' in context) _level = _level | ((context['Reserved1']) & 0x1f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('StartLevel' in context) payload.writeBYTE(context['StartLevel']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IgnoreStartLevel'] = ((_level & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = ((_level & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RollOver'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_level & 0x1f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['StartLevel'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SWITCH_TOGGLE_MULTILEVEL [0x29] STOP_LEVEL_CHANGE [0x05] COMMAND 
COMMAND_CLASS.enum[0x29].command[0x05] = {
	name: "STOP_LEVEL_CHANGE",
	help: "Switch Toggle Multilevel Stop Level Change",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x2a CHIMNEY_FAN COMMANDS
 */

// CHIMNEY_FAN [0x2a] STATE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x01] = {
	name: "STATE_SET",
	help: "Chimney Fan State Set",
	param: { 
		'0x00': {name: "State" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('State' in context) payload.writeBYTE(helpers.getValue(context, 'State', ENUM_CHIMNEY_FAN_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['State'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CHIMNEY_FAN_STATE.enum); else return context;
		return context;
	}
};

const ENUM_CHIMNEY_FAN_STATE = {
	NextState: 0x01, 
	enum: {
		0x01: "NextState"
	}
};

// CHIMNEY_FAN [0x2a] STATE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x02] = {
	name: "STATE_GET",
	help: "Chimney Fan State Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] STATE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x03] = {
	name: "STATE_REPORT",
	help: "Chimney Fan State Report",
	param: { 
		'0x00': {name: "State" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('State' in context) payload.writeBYTE(helpers.getValue(context, 'State', ENUM_CHIMNEY_FAN_STATE_REPORT_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['State'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CHIMNEY_FAN_STATE_REPORT_STATE.enum); else return context;
		return context;
	}
};

const ENUM_CHIMNEY_FAN_STATE_REPORT_STATE = {
	Off: 0x00, 
	Boost: 0x01, 
	Exhaust: 0x02, 
	Reload: 0x03, 
	Venting: 0x04, 
	Stop: 0x05, 
	VentingEx: 0x06, 
	Service: 0x07, 
	SensorFailure: 0x08, 
	ChimneyFire: 0x09, 
	ExternalAlarm: 0x0a, 
	enum: {
		0x00: "Off", 
		0x01: "Boost", 
		0x02: "Exhaust", 
		0x03: "Reload", 
		0x04: "Venting", 
		0x05: "Stop", 
		0x06: "VentingEx", 
		0x07: "Service", 
		0x08: "SensorFailure", 
		0x09: "ChimneyFire", 
		0x0a: "ExternalAlarm"
	}
};

// CHIMNEY_FAN [0x2a] SPEED_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x04] = {
	name: "SPEED_SET",
	help: "Chimney Fan Speed Set",
	param: { 
		'0x00': {name: "Speed" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Speed' in context) payload.writeBYTE(helpers.getValue(context, 'Speed', ENUM_CHIMNEY_FAN_SPEED)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Speed'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CHIMNEY_FAN_SPEED.enum); else return context;
		return context;
	}
};

const ENUM_CHIMNEY_FAN_SPEED = {
	SpeedDown: 0x65, 
	SpeedUp: 0xc8, 
	enum: {
		0x65: "SpeedDown", 
		0xc8: "SpeedUp"
	}
};

// CHIMNEY_FAN [0x2a] SPEED_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x05] = {
	name: "SPEED_GET",
	help: "Chimney Fan Speed Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] SPEED_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x06] = {
	name: "SPEED_REPORT",
	help: "Chimney Fan Speed Report",
	param: { 
		'0x00': {name: "Speed" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Speed' in context) payload.writeBYTE(context['Speed']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Speed'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] START_TEMP_SET [0x07] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x07] = {
	name: "START_TEMP_SET",
	help: "Chimney Fan Start Temp Set",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] START_TEMP_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x08] = {
	name: "START_TEMP_GET",
	help: "Chimney Fan Start Temp Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] START_TEMP_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x09] = {
	name: "START_TEMP_REPORT",
	help: "Chimney Fan Start Temp Report",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] STOP_TEMP_SET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0a] = {
	name: "STOP_TEMP_SET",
	help: "Chimney Fan Stop Temp Set",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] STOP_TEMP_GET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0b] = {
	name: "STOP_TEMP_GET",
	help: "Chimney Fan Stop Temp Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] STOP_TEMP_REPORT [0x0c] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0c] = {
	name: "STOP_TEMP_REPORT",
	help: "Chimney Fan Stop Temp Report",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] ALARM_TEMP_SET [0x0d] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0d] = {
	name: "ALARM_TEMP_SET",
	help: "Chimney Fan Alarm Temp Set",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] ALARM_TEMP_GET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0e] = {
	name: "ALARM_TEMP_GET",
	help: "Chimney Fan Alarm Temp Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] ALARM_TEMP_REPORT [0x0f] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x0f] = {
	name: "ALARM_TEMP_REPORT",
	help: "Chimney Fan Alarm Temp Report",
	param: { 
		'0x00a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(0) & 0x07, precision: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] BOOST_TIME_SET [0x10] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x10] = {
	name: "BOOST_TIME_SET",
	help: "Chimney Fan Boost Time Set",
	param: { 
		'0x00': {name: "Time" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Time' in context) payload.writeBYTE(context['Time']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Time'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] BOOST_TIME_GET [0x11] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x11] = {
	name: "BOOST_TIME_GET",
	help: "Chimney Fan Boost Time Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] BOOST_TIME_REPORT [0x12] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x12] = {
	name: "BOOST_TIME_REPORT",
	help: "Chimney Fan Boost Time Report",
	param: { 
		'0x00': {name: "Time" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Time' in context) payload.writeBYTE(context['Time']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Time'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] STOP_TIME_SET [0x13] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x13] = {
	name: "STOP_TIME_SET",
	help: "Chimney Fan Stop Time Set",
	param: { 
		'0x00': {name: "Time" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Time' in context) payload.writeBYTE(context['Time']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Time'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] STOP_TIME_GET [0x14] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x14] = {
	name: "STOP_TIME_GET",
	help: "Chimney Fan Stop Time Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] STOP_TIME_REPORT [0x15] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x15] = {
	name: "STOP_TIME_REPORT",
	help: "Chimney Fan Stop Time Report",
	param: { 
		'0x00': {name: "Time" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Time' in context) payload.writeBYTE(context['Time']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Time'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] MODE_SET [0x16] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x16] = {
	name: "MODE_SET",
	help: "Chimney Fan Mode Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] MODE_GET [0x17] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x17] = {
	name: "MODE_GET",
	help: "Chimney Fan Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] MODE_REPORT [0x18] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x18] = {
	name: "MODE_REPORT",
	help: "Chimney Fan Mode Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] SETUP_SET [0x19] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x19] = {
	name: "SETUP_SET",
	help: "Chimney Fan Setup Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }, 
		'0x01': {name: "BoostTime" /* BYTE */ }, 
		'0x02': {name: "StopTime" /* BYTE */ }, 
		'0x03': {name: "MinSpeed" /* BYTE */ }, 
		'0x04a': {name: "Size1" /* Properties1 STRUCT_BYTE */ }, 
		'0x04b': {name: "Scale1" /* Properties1 STRUCT_BYTE */ }, 
		'0x04c': {name: "Precision1" /* Properties1 STRUCT_BYTE */ }, 
		'0x05': {name: "StartTemperature" /* VARIANT */ }, 
		'0x06a': {name: "Size2" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "Scale2" /* Properties2 STRUCT_BYTE */ }, 
		'0x06c': {name: "Precision2" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "StopTemperature" /* VARIANT */ }, 
		'0x08a': {name: "Size3" /* Properties3 STRUCT_BYTE */ }, 
		'0x08b': {name: "Scale3" /* Properties3 STRUCT_BYTE */ }, 
		'0x08c': {name: "Precision3" /* Properties3 STRUCT_BYTE */ }, 
		'0x09': {name: "AlarmTemperatureValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('StartTemperature' in context) && !(('Precision1' in context) && ('Size1' in context))) helpers.updateFLOATINGSizePrecision(context, 'StartTemperature', 'Precision1', 'Size1');
		if (('StopTemperature' in context) && !(('Precision2' in context) && ('Size2' in context))) helpers.updateFLOATINGSizePrecision(context, 'StopTemperature', 'Precision2', 'Size2');
		if (('AlarmTemperatureValue' in context) && !(('Precision3' in context) && ('Size3' in context))) helpers.updateFLOATINGSizePrecision(context, 'AlarmTemperatureValue', 'Precision3', 'Size3');
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		if ('BoostTime' in context) payload.writeBYTE(context['BoostTime']); else return payload.asBuffer();
		if ('StopTime' in context) payload.writeBYTE(context['StopTime']); else return payload.asBuffer();
		if ('MinSpeed' in context) payload.writeBYTE(context['MinSpeed']); else return payload.asBuffer();
		if ('Size1' in context || 'Scale1' in context || 'Precision1' in context) {
			let _properties1 = 0x00;
			if ('Size1' in context) _properties1 = _properties1 | ((context['Size1']) & 0x07);
			if ('Scale1' in context) _properties1 = _properties1 | ((context['Scale1'] << 3) & 0x18);
			if ('Precision1' in context) _properties1 = _properties1 | ((context['Precision1'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StartTemperature' in context) payload.writeFLOATING(context['StartTemperature'], {size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Size2' in context || 'Scale2' in context || 'Precision2' in context) {
			let _properties2 = 0x00;
			if ('Size2' in context) _properties2 = _properties2 | ((context['Size2']) & 0x07);
			if ('Scale2' in context) _properties2 = _properties2 | ((context['Scale2'] << 3) & 0x18);
			if ('Precision2' in context) _properties2 = _properties2 | ((context['Precision2'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('StopTemperature' in context) payload.writeFLOATING(context['StopTemperature'], {size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Size3' in context || 'Scale3' in context || 'Precision3' in context) {
			let _properties3 = 0x00;
			if ('Size3' in context) _properties3 = _properties3 | ((context['Size3']) & 0x07);
			if ('Scale3' in context) _properties3 = _properties3 | ((context['Scale3'] << 3) & 0x18);
			if ('Precision3' in context) _properties3 = _properties3 | ((context['Precision3'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('AlarmTemperatureValue' in context) payload.writeFLOATING(context['AlarmTemperatureValue'], {size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['BoostTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinSpeed'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size1'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale1'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision1'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StartTemperature'] = payload.readFLOATING({size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size2'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale2'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision2'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StopTemperature'] = payload.readFLOATING({size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size3'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale3'] = (_properties3 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision3'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['AlarmTemperatureValue'] = payload.readFLOATING({size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] SETUP_GET [0x1a] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x1a] = {
	name: "SETUP_GET",
	help: "Chimney Fan Setup Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] SETUP_REPORT [0x1b] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x1b] = {
	name: "SETUP_REPORT",
	help: "Chimney Fan Setup Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }, 
		'0x01': {name: "BoostTime" /* BYTE */ }, 
		'0x02': {name: "StopTime" /* BYTE */ }, 
		'0x03': {name: "MinSpeed" /* BYTE */ }, 
		'0x04a': {name: "Size1" /* Properties1 STRUCT_BYTE */ }, 
		'0x04b': {name: "Scale1" /* Properties1 STRUCT_BYTE */ }, 
		'0x04c': {name: "Precision1" /* Properties1 STRUCT_BYTE */ }, 
		'0x05': {name: "StartTemperature" /* VARIANT */ }, 
		'0x06a': {name: "Size2" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "Scale2" /* Properties2 STRUCT_BYTE */ }, 
		'0x06c': {name: "Precision2" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "StopTemperature" /* VARIANT */ }, 
		'0x08a': {name: "Size3" /* Properties3 STRUCT_BYTE */ }, 
		'0x08b': {name: "Scale3" /* Properties3 STRUCT_BYTE */ }, 
		'0x08c': {name: "Precision3" /* Properties3 STRUCT_BYTE */ }, 
		'0x09': {name: "AlarmTemperatureValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('StartTemperature' in context) && !(('Precision1' in context) && ('Size1' in context))) helpers.updateFLOATINGSizePrecision(context, 'StartTemperature', 'Precision1', 'Size1');
		if (('StopTemperature' in context) && !(('Precision2' in context) && ('Size2' in context))) helpers.updateFLOATINGSizePrecision(context, 'StopTemperature', 'Precision2', 'Size2');
		if (('AlarmTemperatureValue' in context) && !(('Precision3' in context) && ('Size3' in context))) helpers.updateFLOATINGSizePrecision(context, 'AlarmTemperatureValue', 'Precision3', 'Size3');
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		if ('BoostTime' in context) payload.writeBYTE(context['BoostTime']); else return payload.asBuffer();
		if ('StopTime' in context) payload.writeBYTE(context['StopTime']); else return payload.asBuffer();
		if ('MinSpeed' in context) payload.writeBYTE(context['MinSpeed']); else return payload.asBuffer();
		if ('Size1' in context || 'Scale1' in context || 'Precision1' in context) {
			let _properties1 = 0x00;
			if ('Size1' in context) _properties1 = _properties1 | ((context['Size1']) & 0x07);
			if ('Scale1' in context) _properties1 = _properties1 | ((context['Scale1'] << 3) & 0x18);
			if ('Precision1' in context) _properties1 = _properties1 | ((context['Precision1'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StartTemperature' in context) payload.writeFLOATING(context['StartTemperature'], {size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Size2' in context || 'Scale2' in context || 'Precision2' in context) {
			let _properties2 = 0x00;
			if ('Size2' in context) _properties2 = _properties2 | ((context['Size2']) & 0x07);
			if ('Scale2' in context) _properties2 = _properties2 | ((context['Scale2'] << 3) & 0x18);
			if ('Precision2' in context) _properties2 = _properties2 | ((context['Precision2'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('StopTemperature' in context) payload.writeFLOATING(context['StopTemperature'], {size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Size3' in context || 'Scale3' in context || 'Precision3' in context) {
			let _properties3 = 0x00;
			if ('Size3' in context) _properties3 = _properties3 | ((context['Size3']) & 0x07);
			if ('Scale3' in context) _properties3 = _properties3 | ((context['Scale3'] << 3) & 0x18);
			if ('Precision3' in context) _properties3 = _properties3 | ((context['Precision3'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('AlarmTemperatureValue' in context) payload.writeFLOATING(context['AlarmTemperatureValue'], {size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['BoostTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinSpeed'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size1'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale1'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision1'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StartTemperature'] = payload.readFLOATING({size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size2'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale2'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision2'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StopTemperature'] = payload.readFLOATING({size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size3'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale3'] = (_properties3 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision3'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['AlarmTemperatureValue'] = payload.readFLOATING({size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] STATUS_GET [0x1d] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x1d] = {
	name: "STATUS_GET",
	help: "Chimney Fan Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] STATUS_REPORT [0x1e] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x1e] = {
	name: "STATUS_REPORT",
	help: "Chimney Fan Status Report",
	param: { 
		'0x00': {name: "State" /* CONST */ }, 
		'0x01': {name: "Speed" /* BYTE */ }, 
		'0x02a': {name: "Service" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02b': {name: "ExternalAlarm" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02c': {name: "SensorError" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02d': {name: "AlarmTemperatureExceeded" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02e': {name: "SpeedChangeEnable" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02f': {name: "StartTemperatureExceeded" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x02g': {name: "NotUsed" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x03a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x03b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x03c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x04': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('State' in context) payload.writeBYTE(helpers.getValue(context, 'State', ENUM_CHIMNEY_FAN_STATE_REPORT_STATE)); else return payload.asBuffer();
		if ('Speed' in context) payload.writeBYTE(context['Speed']); else return payload.asBuffer();
		if ('Service' in context || 'ExternalAlarm' in context || 'SensorError' in context || 'AlarmTemperatureExceeded' in context || 'SpeedChangeEnable' in context || 'StartTemperatureExceeded' in context || 'NotUsed' in context) {
			let _alarmstatus = 0x00;
			if (context['Service']) _alarmstatus = _alarmstatus | 0x01;
			if (context['ExternalAlarm']) _alarmstatus = _alarmstatus | 0x02;
			if (context['SensorError']) _alarmstatus = _alarmstatus | 0x04;
			if (context['AlarmTemperatureExceeded']) _alarmstatus = _alarmstatus | 0x08;
			if (context['SpeedChangeEnable']) _alarmstatus = _alarmstatus | 0x40;
			if (context['StartTemperatureExceeded']) _alarmstatus = _alarmstatus | 0x80;
			if ('NotUsed' in context) _alarmstatus = _alarmstatus | ((context['NotUsed'] << 4) & 0x30);
			payload.writeBYTE(_alarmstatus);
		} else return payload.asBuffer();;
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['State'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CHIMNEY_FAN_STATE_REPORT_STATE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Speed'] = payload.readBYTE(); else return context;
		{
			let _alarmstatus = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Service'] = ((_alarmstatus & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm'] = ((_alarmstatus & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError'] = ((_alarmstatus & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded'] = ((_alarmstatus & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SpeedChangeEnable'] = ((_alarmstatus & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartTemperatureExceeded'] = ((_alarmstatus & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NotUsed'] = (_alarmstatus & 0x30) >> 4; else return context;
		}
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] ALARM_LOG_SET [0x1f] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x1f] = {
	name: "ALARM_LOG_SET",
	help: "Chimney Fan Alarm Log Set",
	param: { 
		'0x00': {name: "Message" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Message' in context) payload.writeBYTE(helpers.getValue(context, 'Message', ENUM_CHIMNEY_FAN_ALARM_LOG_MESSAGE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Message'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CHIMNEY_FAN_ALARM_LOG_MESSAGE.enum); else return context;
		return context;
	}
};

const ENUM_CHIMNEY_FAN_ALARM_LOG_MESSAGE = {
	ResetLog: 0x08, 
	enum: {
		0x08: "ResetLog"
	}
};

// CHIMNEY_FAN [0x2a] ALARM_LOG_GET [0x20] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x20] = {
	name: "ALARM_LOG_GET",
	help: "Chimney Fan Alarm Log Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] ALARM_LOG_REPORT [0x21] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x21] = {
	name: "ALARM_LOG_REPORT",
	help: "Chimney Fan Alarm Log Report",
	param: { 
		'0x00a': {name: "Reserved11" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x00b': {name: "ExternalAlarm1" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x00c': {name: "SensorError1" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x00d': {name: "AlarmTemperatureExceeded1" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x00e': {name: "AlarmStillActive1" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x00f': {name: "Reserved12" /* AlarmEvent1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Reserved21" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x01b': {name: "ExternalAlarm2" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x01c': {name: "SensorError2" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x01d': {name: "AlarmTemperatureExceeded2" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x01e': {name: "AlarmStillActive2" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x01f': {name: "Reserved22" /* AlarmEvent2 STRUCT_BYTE */ }, 
		'0x02a': {name: "Reserved31" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x02b': {name: "ExternalAlarm3" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x02c': {name: "SensorError3" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x02d': {name: "AlarmTemperatureExceeded3" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x02e': {name: "AlarmStillActive3" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x02f': {name: "Reserved32" /* AlarmEvent3 STRUCT_BYTE */ }, 
		'0x03a': {name: "Reserved41" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x03b': {name: "ExternalAlarm4" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x03c': {name: "SensorError4" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x03d': {name: "AlarmTemperatureExceeded4" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x03e': {name: "AlarmStillActive4" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x03f': {name: "Reserved42" /* AlarmEvent4 STRUCT_BYTE */ }, 
		'0x04a': {name: "Reserved51" /* AlarmEvent5 STRUCT_BYTE */ }, 
		'0x04b': {name: "ExternalAlarm5" /* AlarmEvent5 STRUCT_BYTE */ }, 
		'0x04c': {name: "SensorError5" /* AlarmEvent5 STRUCT_BYTE */ }, 
		'0x04d': {name: "AlarmTemperatureExceeded5" /* AlarmEvent5 STRUCT_BYTE */ }, 
		'0x04e': {name: "AlarmStillActive5" /* AlarmEvent5 STRUCT_BYTE */ }, 
		'0x04f': {name: "Reserved52" /* AlarmEvent5 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved11' in context || 'ExternalAlarm1' in context || 'SensorError1' in context || 'AlarmTemperatureExceeded1' in context || 'AlarmStillActive1' in context || 'Reserved12' in context) {
			let _alarmevent1 = 0x00;
			if (context['Reserved11']) _alarmevent1 = _alarmevent1 | 0x01;
			if (context['ExternalAlarm1']) _alarmevent1 = _alarmevent1 | 0x02;
			if (context['SensorError1']) _alarmevent1 = _alarmevent1 | 0x04;
			if (context['AlarmTemperatureExceeded1']) _alarmevent1 = _alarmevent1 | 0x08;
			if (context['AlarmStillActive1']) _alarmevent1 = _alarmevent1 | 0x80;
			if ('Reserved12' in context) _alarmevent1 = _alarmevent1 | ((context['Reserved12'] << 4) & 0x70);
			payload.writeBYTE(_alarmevent1);
		} else return payload.asBuffer();;
		if ('Reserved21' in context || 'ExternalAlarm2' in context || 'SensorError2' in context || 'AlarmTemperatureExceeded2' in context || 'AlarmStillActive2' in context || 'Reserved22' in context) {
			let _alarmevent2 = 0x00;
			if (context['Reserved21']) _alarmevent2 = _alarmevent2 | 0x01;
			if (context['ExternalAlarm2']) _alarmevent2 = _alarmevent2 | 0x02;
			if (context['SensorError2']) _alarmevent2 = _alarmevent2 | 0x04;
			if (context['AlarmTemperatureExceeded2']) _alarmevent2 = _alarmevent2 | 0x08;
			if (context['AlarmStillActive2']) _alarmevent2 = _alarmevent2 | 0x80;
			if ('Reserved22' in context) _alarmevent2 = _alarmevent2 | ((context['Reserved22'] << 4) & 0x70);
			payload.writeBYTE(_alarmevent2);
		} else return payload.asBuffer();;
		if ('Reserved31' in context || 'ExternalAlarm3' in context || 'SensorError3' in context || 'AlarmTemperatureExceeded3' in context || 'AlarmStillActive3' in context || 'Reserved32' in context) {
			let _alarmevent3 = 0x00;
			if (context['Reserved31']) _alarmevent3 = _alarmevent3 | 0x01;
			if (context['ExternalAlarm3']) _alarmevent3 = _alarmevent3 | 0x02;
			if (context['SensorError3']) _alarmevent3 = _alarmevent3 | 0x04;
			if (context['AlarmTemperatureExceeded3']) _alarmevent3 = _alarmevent3 | 0x08;
			if (context['AlarmStillActive3']) _alarmevent3 = _alarmevent3 | 0x80;
			if ('Reserved32' in context) _alarmevent3 = _alarmevent3 | ((context['Reserved32'] << 4) & 0x70);
			payload.writeBYTE(_alarmevent3);
		} else return payload.asBuffer();;
		if ('Reserved41' in context || 'ExternalAlarm4' in context || 'SensorError4' in context || 'AlarmTemperatureExceeded4' in context || 'AlarmStillActive4' in context || 'Reserved42' in context) {
			let _alarmevent4 = 0x00;
			if (context['Reserved41']) _alarmevent4 = _alarmevent4 | 0x01;
			if (context['ExternalAlarm4']) _alarmevent4 = _alarmevent4 | 0x02;
			if (context['SensorError4']) _alarmevent4 = _alarmevent4 | 0x04;
			if (context['AlarmTemperatureExceeded4']) _alarmevent4 = _alarmevent4 | 0x08;
			if (context['AlarmStillActive4']) _alarmevent4 = _alarmevent4 | 0x80;
			if ('Reserved42' in context) _alarmevent4 = _alarmevent4 | ((context['Reserved42'] << 4) & 0x70);
			payload.writeBYTE(_alarmevent4);
		} else return payload.asBuffer();;
		if ('Reserved51' in context || 'ExternalAlarm5' in context || 'SensorError5' in context || 'AlarmTemperatureExceeded5' in context || 'AlarmStillActive5' in context || 'Reserved52' in context) {
			let _alarmevent5 = 0x00;
			if (context['Reserved51']) _alarmevent5 = _alarmevent5 | 0x01;
			if (context['ExternalAlarm5']) _alarmevent5 = _alarmevent5 | 0x02;
			if (context['SensorError5']) _alarmevent5 = _alarmevent5 | 0x04;
			if (context['AlarmTemperatureExceeded5']) _alarmevent5 = _alarmevent5 | 0x08;
			if (context['AlarmStillActive5']) _alarmevent5 = _alarmevent5 | 0x80;
			if ('Reserved52' in context) _alarmevent5 = _alarmevent5 | ((context['Reserved52'] << 4) & 0x70);
			payload.writeBYTE(_alarmevent5);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _alarmevent1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved11'] = ((_alarmevent1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm1'] = ((_alarmevent1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError1'] = ((_alarmevent1 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded1'] = ((_alarmevent1 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmStillActive1'] = ((_alarmevent1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved12'] = (_alarmevent1 & 0x70) >> 4; else return context;
		}
		{
			let _alarmevent2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved21'] = ((_alarmevent2 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm2'] = ((_alarmevent2 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError2'] = ((_alarmevent2 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded2'] = ((_alarmevent2 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmStillActive2'] = ((_alarmevent2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved22'] = (_alarmevent2 & 0x70) >> 4; else return context;
		}
		{
			let _alarmevent3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved31'] = ((_alarmevent3 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm3'] = ((_alarmevent3 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError3'] = ((_alarmevent3 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded3'] = ((_alarmevent3 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmStillActive3'] = ((_alarmevent3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved32'] = (_alarmevent3 & 0x70) >> 4; else return context;
		}
		{
			let _alarmevent4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved41'] = ((_alarmevent4 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm4'] = ((_alarmevent4 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError4'] = ((_alarmevent4 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded4'] = ((_alarmevent4 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmStillActive4'] = ((_alarmevent4 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved42'] = (_alarmevent4 & 0x70) >> 4; else return context;
		}
		{
			let _alarmevent5 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved51'] = ((_alarmevent5 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm5'] = ((_alarmevent5 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError5'] = ((_alarmevent5 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded5'] = ((_alarmevent5 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmStillActive5'] = ((_alarmevent5 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved52'] = (_alarmevent5 & 0x70) >> 4; else return context;
		}
		return context;
	}
};

// CHIMNEY_FAN [0x2a] ALARM_STATUS_SET [0x22] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x22] = {
	name: "ALARM_STATUS_SET",
	help: "Chimney Fan Alarm Status Set",
	param: { 
		'0x00a': {name: "NotUsed1" /* Message STRUCT_BYTE */ }, 
		'0x00b': {name: "AcknowledgeExternalAlarm" /* Message STRUCT_BYTE */ }, 
		'0x00c': {name: "AcknowledgeSensorError" /* Message STRUCT_BYTE */ }, 
		'0x00d': {name: "AcknowledgeAlarmTemperatureExceeded" /* Message STRUCT_BYTE */ }, 
		'0x00e': {name: "NotUsed2" /* Message STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NotUsed1' in context || 'AcknowledgeExternalAlarm' in context || 'AcknowledgeSensorError' in context || 'AcknowledgeAlarmTemperatureExceeded' in context || 'NotUsed2' in context) {
			let _message = 0x00;
			if (context['NotUsed1']) _message = _message | 0x01;
			if (context['AcknowledgeExternalAlarm']) _message = _message | 0x02;
			if (context['AcknowledgeSensorError']) _message = _message | 0x04;
			if (context['AcknowledgeAlarmTemperatureExceeded']) _message = _message | 0x08;
			if ('NotUsed2' in context) _message = _message | ((context['NotUsed2'] << 4) & 0xf0);
			payload.writeBYTE(_message);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _message = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NotUsed1'] = ((_message & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AcknowledgeExternalAlarm'] = ((_message & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AcknowledgeSensorError'] = ((_message & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AcknowledgeAlarmTemperatureExceeded'] = ((_message & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NotUsed2'] = (_message & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// CHIMNEY_FAN [0x2a] ALARM_STATUS_GET [0x23] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x23] = {
	name: "ALARM_STATUS_GET",
	help: "Chimney Fan Alarm Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] ALARM_STATUS_REPORT [0x24] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x24] = {
	name: "ALARM_STATUS_REPORT",
	help: "Chimney Fan Alarm Status Report",
	param: { 
		'0x00a': {name: "Service" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00b': {name: "ExternalAlarm" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00c': {name: "SensorError" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00d': {name: "AlarmTemperatureExceeded" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00e': {name: "SpeedChangeEnable" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00f': {name: "StartTemperatureExceeded" /* AlarmStatus STRUCT_BYTE */ }, 
		'0x00g': {name: "NotUsed" /* AlarmStatus STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Service' in context || 'ExternalAlarm' in context || 'SensorError' in context || 'AlarmTemperatureExceeded' in context || 'SpeedChangeEnable' in context || 'StartTemperatureExceeded' in context || 'NotUsed' in context) {
			let _alarmstatus = 0x00;
			if (context['Service']) _alarmstatus = _alarmstatus | 0x01;
			if (context['ExternalAlarm']) _alarmstatus = _alarmstatus | 0x02;
			if (context['SensorError']) _alarmstatus = _alarmstatus | 0x04;
			if (context['AlarmTemperatureExceeded']) _alarmstatus = _alarmstatus | 0x08;
			if (context['SpeedChangeEnable']) _alarmstatus = _alarmstatus | 0x40;
			if (context['StartTemperatureExceeded']) _alarmstatus = _alarmstatus | 0x80;
			if ('NotUsed' in context) _alarmstatus = _alarmstatus | ((context['NotUsed'] << 4) & 0x30);
			payload.writeBYTE(_alarmstatus);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _alarmstatus = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Service'] = ((_alarmstatus & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExternalAlarm'] = ((_alarmstatus & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SensorError'] = ((_alarmstatus & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AlarmTemperatureExceeded'] = ((_alarmstatus & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SpeedChangeEnable'] = ((_alarmstatus & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartTemperatureExceeded'] = ((_alarmstatus & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NotUsed'] = (_alarmstatus & 0x30) >> 4; else return context;
		}
		return context;
	}
};

// CHIMNEY_FAN [0x2a] MIN_SPEED_SET [0x25] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x25] = {
	name: "MIN_SPEED_SET",
	help: "Chimney Fan Min Speed Set",
	param: { 
		'0x00': {name: "MinSpeed" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MinSpeed' in context) payload.writeBYTE(context['MinSpeed']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MinSpeed'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] MIN_SPEED_GET [0x26] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x26] = {
	name: "MIN_SPEED_GET",
	help: "Chimney Fan Min Speed Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CHIMNEY_FAN [0x2a] MIN_SPEED_REPORT [0x27] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x27] = {
	name: "MIN_SPEED_REPORT",
	help: "Chimney Fan Min Speed Report",
	param: { 
		'0x00': {name: "MinSpeed" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MinSpeed' in context) payload.writeBYTE(context['MinSpeed']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MinSpeed'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CHIMNEY_FAN [0x2a] DEFAULT_SET [0x28] COMMAND 
COMMAND_CLASS.enum[0x2a].command[0x28] = {
	name: "DEFAULT_SET",
	help: "Chimney Fan Default Set",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x2b SCENE_ACTIVATION COMMANDS
 */

// SCENE_ACTIVATION [0x2b] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2b].command[0x01] = {
	name: "SET",
	help: "Scene Activation Set",
	param: { 
		'0x00': {name: "SceneId" /* BYTE */ }, 
		'0x01': {name: "DimmingDuration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SCENE_ACTIVATION_DIMMING_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCENE_ACTIVATION_DIMMING_DURATION.enum); else return context;
		return context;
	}
};

const ENUM_SCENE_ACTIVATION_DIMMING_DURATION = {
	Instantly: 0x00, 
	ConfiguredDimmingDuration: 0xff, 
	enum: {
		0x00: "Instantly", 
		0xff: "ConfiguredDimmingDuration"
	}
};



/*
 * COMMAND_CLASS 0x2c SCENE_ACTUATOR_CONF COMMANDS
 */

// SCENE_ACTUATOR_CONF [0x2c] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2c].command[0x01] = {
	name: "SET",
	help: "Scene Actuator Conf Set",
	param: { 
		'0x00': {name: "SceneId" /* BYTE */ }, 
		'0x01': {name: "DimmingDuration" /* CONST */ }, 
		'0x02a': {name: "Override" /* Level2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved" /* Level2 STRUCT_BYTE */ }, 
		'0x03': {name: "Level" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SCENE_ACTUATOR_CONF_DIMMING_DURATION)); else return payload.asBuffer();
		if ('Override' in context || 'Reserved' in context) {
			let _level2 = 0x00;
			if (context['Override']) _level2 = _level2 | 0x80;
			if ('Reserved' in context) _level2 = _level2 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		if ('Level' in context) payload.writeBYTE(context['Level']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCENE_ACTUATOR_CONF_DIMMING_DURATION.enum); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Override'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['Level'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_SCENE_ACTUATOR_CONF_DIMMING_DURATION = {
	SpecifyInstantly: 0x00, 
	FactoryDefault: 0xff, 
	enum: {
		0x00: "SpecifyInstantly", 
		0xff: "FactoryDefault"
	}
};

// SCENE_ACTUATOR_CONF [0x2c] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x2c].command[0x02] = {
	name: "GET",
	help: "Scene Actuator Conf Get",
	param: { 
		'0x00': {name: "SceneId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCENE_ACTUATOR_CONF [0x2c] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x2c].command[0x03] = {
	name: "REPORT",
	help: "Scene Actuator Conf Report",
	param: { 
		'0x00': {name: "SceneId" /* BYTE */ }, 
		'0x01': {name: "Level" /* BYTE */ }, 
		'0x02': {name: "DimmingDuration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('Level' in context) payload.writeBYTE(context['Level']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Level'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION.enum); else return context;
		return context;
	}
};

const ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION = {
	Instantly: 0x00, 
	enum: {
		0x00: "Instantly"
	}
};



/*
 * COMMAND_CLASS 0x2d SCENE_CONTROLLER_CONF COMMANDS
 */

// SCENE_CONTROLLER_CONF [0x2d] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2d].command[0x01] = {
	name: "SET",
	help: "Scene Controller Conf Set",
	param: { 
		'0x00': {name: "GroupId" /* BYTE */ }, 
		'0x01': {name: "SceneId" /* BYTE */ }, 
		'0x02': {name: "DimmingDuration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupId' in context) payload.writeBYTE(context['GroupId']); else return payload.asBuffer();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SCENE_CONTROLLER_CONF_DIMMING_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCENE_CONTROLLER_CONF_DIMMING_DURATION.enum); else return context;
		return context;
	}
};

const ENUM_SCENE_CONTROLLER_CONF_DIMMING_DURATION = {
	Instantly: 0x00, 
	FactoryDefault: 0xff, 
	enum: {
		0x00: "Instantly", 
		0xff: "FactoryDefault"
	}
};

// SCENE_CONTROLLER_CONF [0x2d] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x2d].command[0x02] = {
	name: "GET",
	help: "Scene Controller Conf Get",
	param: { 
		'0x00': {name: "GroupId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupId' in context) payload.writeBYTE(context['GroupId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCENE_CONTROLLER_CONF [0x2d] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x2d].command[0x03] = {
	name: "REPORT",
	help: "Scene Controller Conf Report",
	param: { 
		'0x00': {name: "GroupId" /* BYTE */ }, 
		'0x01': {name: "SceneId" /* BYTE */ }, 
		'0x02': {name: "DimmingDuration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupId' in context) payload.writeBYTE(context['GroupId']); else return payload.asBuffer();
		if ('SceneId' in context) payload.writeBYTE(context['SceneId']); else return payload.asBuffer();
		if ('DimmingDuration' in context) payload.writeBYTE(helpers.getValue(context, 'DimmingDuration', ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SceneId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DimmingDuration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x2e SECURITY_PANEL_ZONE COMMANDS
 */

// SECURITY_PANEL_ZONE [0x2e] NUMBER_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x01] = {
	name: "NUMBER_SUPPORTED_GET",
	help: "Security Panel Zone Number Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_PANEL_ZONE [0x2e] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Security Panel Zone Supported Report",
	param: { 
		'0x00a': {name: "ZM" /* Parameters1 STRUCT_BYTE */ }, 
		'0x00b': {name: "ZonesSupported" /* Parameters1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZM' in context || 'ZonesSupported' in context) {
			let _parameters1 = 0x00;
			if (context['ZM']) _parameters1 = _parameters1 | 0x80;
			if ('ZonesSupported' in context) _parameters1 = _parameters1 | ((context['ZonesSupported']) & 0x7f);
			payload.writeBYTE(_parameters1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _parameters1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ZM'] = ((_parameters1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ZonesSupported'] = (_parameters1 & 0x7f); else return context;
		}
		return context;
	}
};

// SECURITY_PANEL_ZONE [0x2e] TYPE_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x03] = {
	name: "TYPE_GET",
	help: "Security Panel Zone Type Get",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE [0x2e] TYPE_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x04] = {
	name: "TYPE_REPORT",
	help: "Security Panel Zone Type Report",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "ZoneType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('ZoneType' in context) payload.writeBYTE(helpers.getValue(context, 'ZoneType', ENUM_SECURITY_PANEL_ZONE_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ZoneType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_PANEL_ZONE_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SECURITY_PANEL_ZONE_TYPE = {
	AlarmZone: 0x01, 
	NotificationZone: 0x02, 
	enum: {
		0x01: "AlarmZone", 
		0x02: "NotificationZone"
	}
};

// SECURITY_PANEL_ZONE [0x2e] STATE_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x05] = {
	name: "STATE_GET",
	help: "Security Panel Zone State Get",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE [0x2e] STATE_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x2e].command[0x06] = {
	name: "STATE_REPORT",
	help: "Security Panel Zone State Report",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "ZoneState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('ZoneState' in context) payload.writeBYTE(helpers.getValue(context, 'ZoneState', ENUM_SECURITY_PANEL_ZONE_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ZoneState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_PANEL_ZONE_STATE.enum); else return context;
		return context;
	}
};

const ENUM_SECURITY_PANEL_ZONE_STATE = {
	Faulted: 0x00, 
	NotFaulted: 0x01, 
	BypassFaulted: 0x02, 
	BypassNotfaulted: 0x03, 
	enum: {
		0x00: "Faulted", 
		0x01: "NotFaulted", 
		0x02: "BypassFaulted", 
		0x03: "BypassNotfaulted"
	}
};



/*
 * COMMAND_CLASS 0x2f SECURITY_PANEL_ZONE_SENSOR COMMANDS
 */

// SECURITY_PANEL_ZONE_SENSOR [0x2f] INSTALLED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x01] = {
	name: "INSTALLED_GET",
	help: "Security Panel Zone Sensor Installed Get",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE_SENSOR [0x2f] SECURITY_PANEL_ZONE_SENSOR_INSTALLED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x02] = {
	name: "SECURITY_PANEL_ZONE_SENSOR_INSTALLED_REPORT",
	help: "Command Class Security Panel Zone Sensor Installed Report",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "NumberOfSensors" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('NumberOfSensors' in context) payload.writeBYTE(context['NumberOfSensors']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfSensors'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE_SENSOR [0x2f] TYPE_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x03] = {
	name: "TYPE_GET",
	help: "Security Panel Zone Sensor Type Get",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "SensorNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('SensorNumber' in context) payload.writeBYTE(context['SensorNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE_SENSOR [0x2f] TYPE_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x04] = {
	name: "TYPE_REPORT",
	help: "Security Panel Zone Sensor Type Report",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "SensorNumber" /* BYTE */ }, 
		'0x02': {name: "AlarmType" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('SensorNumber' in context) payload.writeBYTE(context['SensorNumber']); else return payload.asBuffer();
		if ('AlarmType' in context) payload.writeBYTE(context['AlarmType']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AlarmType'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE_SENSOR [0x2f] STATE_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x05] = {
	name: "STATE_GET",
	help: "Security Panel Zone Sensor State Get",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "SensorNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('SensorNumber' in context) payload.writeBYTE(context['SensorNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_PANEL_ZONE_SENSOR [0x2f] STATE_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x2f].command[0x06] = {
	name: "STATE_REPORT",
	help: "Security Panel Zone Sensor State Report",
	param: { 
		'0x00': {name: "ZoneNumber" /* BYTE */ }, 
		'0x01': {name: "SensorNumber" /* BYTE */ }, 
		'0x02': {name: "AlarmType" /* BYTE */ }, 
		'0x03': {name: "AlarmEvent" /* BYTE */ }, 
		'0x04': {name: "EventParameters" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ZoneNumber' in context) payload.writeBYTE(context['ZoneNumber']); else return payload.asBuffer();
		if ('SensorNumber' in context) payload.writeBYTE(context['SensorNumber']); else return payload.asBuffer();
		if ('AlarmType' in context) payload.writeBYTE(context['AlarmType']); else return payload.asBuffer();
		if ('AlarmEvent' in context) payload.writeBYTE(context['AlarmEvent']); else return payload.asBuffer();
		if ('EventParameters' in context) payload.writeBYTE(context['EventParameters']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ZoneNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AlarmType'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AlarmEvent'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventParameters'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x30 SENSOR_BINARY COMMANDS
 */

// SENSOR_BINARY [0x30] SUPPORTED_GET_SENSOR [0x01] COMMAND 
COMMAND_CLASS.enum[0x30].command[0x01] = {
	name: "SUPPORTED_GET_SENSOR",
	help: "Sensor Binary Supported Get Sensor",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SENSOR_BINARY [0x30] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x30].command[0x02] = {
	name: "GET",
	help: "Sensor Binary Get",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_BINARY_SENSOR_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_BINARY_SENSOR_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SENSOR_BINARY_SENSOR_TYPE = {
	Reserved: 0x00, 
	General: 0x01, 
	Smoke: 0x02, 
	CO: 0x03, 
	CO2: 0x04, 
	Heat: 0x05, 
	Water: 0x06, 
	Freeze: 0x07, 
	Tamper: 0x08, 
	Aux: 0x09, 
	DoorWindow: 0x0a, 
	Tilt: 0x0b, 
	Motion: 0x0c, 
	GlassBreak: 0x0d, 
	First: 0xff, 
	enum: {
		0x00: "Reserved", 
		0x01: "General", 
		0x02: "Smoke", 
		0x03: "CO", 
		0x04: "CO2", 
		0x05: "Heat", 
		0x06: "Water", 
		0x07: "Freeze", 
		0x08: "Tamper", 
		0x09: "Aux", 
		0x0a: "DoorWindow", 
		0x0b: "Tilt", 
		0x0c: "Motion", 
		0x0d: "GlassBreak", 
		0xff: "First"
	}
};

// SENSOR_BINARY [0x30] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x30].command[0x03] = {
	name: "REPORT",
	help: "Sensor Binary Report",
	param: { 
		'0x00': {name: "SensorValue" /* CONST */ }, 
		'0x01': {name: "SensorType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorValue' in context) payload.writeBYTE(helpers.getValue(context, 'SensorValue', ENUM_SENSOR_BINARY_SENSOR_VALUE)); else return payload.asBuffer();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_BINARY_SENSOR_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_BINARY_SENSOR_VALUE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_BINARY_SENSOR_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SENSOR_BINARY_SENSOR_VALUE = {
	Idle: 0x00, 
	DetectedAnEvent: 0xff, 
	enum: {
		0x00: "Idle", 
		0xff: "DetectedAnEvent"
	}
};

// SENSOR_BINARY [0x30] SUPPORTED_SENSOR_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x30].command[0x04] = {
	name: "SUPPORTED_SENSOR_REPORT",
	help: "Sensor Binary Supported Sensor Report",
	param: { 
		'0x00-0': {name: "Reserved" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "General" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Smoke" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "CO" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "CO2" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "Heat" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "Water" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "Freeze" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "Tamper" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "Aux" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "DoorWindow" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "Tilt" /* BitMask BITMASK */ }, 
		'0x00-12': {name: "Motion" /* BitMask BITMASK */ }, 
		'0x00-13': {name: "GlassBreak" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_SENSOR_BINARY_SENSOR_TYPE), {length: 14});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 14}), ENUM_SENSOR_BINARY_SENSOR_TYPE.enum);
		return context;
	}
};



/*
 * COMMAND_CLASS 0x31 SENSOR_MULTILEVEL COMMANDS
 */

// SENSOR_MULTILEVEL [0x31] SUPPORTED_GET_SENSOR [0x01] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x01] = {
	name: "SUPPORTED_GET_SENSOR",
	help: "Multilevel Sensor Get Supported Sensor",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SENSOR_MULTILEVEL [0x31] SUPPORTED_SENSOR_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x02] = {
	name: "SUPPORTED_SENSOR_REPORT",
	help: "Multilevel Sensor Supported Sensor Report",
	param: { 
		'0x00-0': {name: "AirTemperature" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "GeneralPurposeValue" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Luminance" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "Power" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "Humidity" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "Velocity" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "Direction" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "AtmosphericPressure" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "BarometricPressure" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "SolarRadiation" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "DewPoint" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "RainRate" /* BitMask BITMASK */ }, 
		'0x00-12': {name: "TideLevel" /* BitMask BITMASK */ }, 
		'0x00-13': {name: "Weight" /* BitMask BITMASK */ }, 
		'0x00-14': {name: "Voltage" /* BitMask BITMASK */ }, 
		'0x00-15': {name: "Current" /* BitMask BITMASK */ }, 
		'0x00-16': {name: "CO2level" /* BitMask BITMASK */ }, 
		'0x00-17': {name: "AirFlow" /* BitMask BITMASK */ }, 
		'0x00-18': {name: "TankCapacity" /* BitMask BITMASK */ }, 
		'0x00-19': {name: "Distance" /* BitMask BITMASK */ }, 
		'0x00-20': {name: "AnglePosition" /* BitMask BITMASK */ }, 
		'0x00-21': {name: "Rotation" /* BitMask BITMASK */ }, 
		'0x00-22': {name: "WaterTemperature" /* BitMask BITMASK */ }, 
		'0x00-23': {name: "SoilTemperature" /* BitMask BITMASK */ }, 
		'0x00-24': {name: "SeismicIntensity" /* BitMask BITMASK */ }, 
		'0x00-25': {name: "SeismicMagnitude" /* BitMask BITMASK */ }, 
		'0x00-26': {name: "Ultraviolet" /* BitMask BITMASK */ }, 
		'0x00-27': {name: "ElectricalResistivity" /* BitMask BITMASK */ }, 
		'0x00-28': {name: "ElectricalConductivity" /* BitMask BITMASK */ }, 
		'0x00-29': {name: "Loudness" /* BitMask BITMASK */ }, 
		'0x00-30': {name: "Moisture" /* BitMask BITMASK */ }, 
		'0x00-31': {name: "Frequency" /* BitMask BITMASK */ }, 
		'0x00-32': {name: "Time" /* BitMask BITMASK */ }, 
		'0x00-33': {name: "TargetTemperature" /* BitMask BITMASK */ }, 
		'0x00-34': {name: "ParticulateMatter25" /* BitMask BITMASK */ }, 
		'0x00-35': {name: "FormaldehydeCh2olevel" /* BitMask BITMASK */ }, 
		'0x00-36': {name: "RadonConcentration" /* BitMask BITMASK */ }, 
		'0x00-37': {name: "MethaneDensityCh4" /* BitMask BITMASK */ }, 
		'0x00-38': {name: "VolatileOrganicCompound" /* BitMask BITMASK */ }, 
		'0x00-39': {name: "CarbonMonoxideColevel" /* BitMask BITMASK */ }, 
		'0x00-40': {name: "SoilHumidity" /* BitMask BITMASK */ }, 
		'0x00-41': {name: "SoilReactivity" /* BitMask BITMASK */ }, 
		'0x00-42': {name: "SoilSalinity" /* BitMask BITMASK */ }, 
		'0x00-43': {name: "HeartRate" /* BitMask BITMASK */ }, 
		'0x00-44': {name: "BloodPressure" /* BitMask BITMASK */ }, 
		'0x00-45': {name: "MuscleMass" /* BitMask BITMASK */ }, 
		'0x00-46': {name: "FatMass" /* BitMask BITMASK */ }, 
		'0x00-47': {name: "BoneMass" /* BitMask BITMASK */ }, 
		'0x00-48': {name: "TotalBodyWaterTbw" /* BitMask BITMASK */ }, 
		'0x00-49': {name: "BasicMetabolicRateBmr" /* BitMask BITMASK */ }, 
		'0x00-50': {name: "BodyMassIndexBmi" /* BitMask BITMASK */ }, 
		'0x00-51': {name: "AccelerationXaxisv8" /* BitMask BITMASK */ }, 
		'0x00-52': {name: "AccelerationYaxisv8" /* BitMask BITMASK */ }, 
		'0x00-53': {name: "AccelerationZaxisv8" /* BitMask BITMASK */ }, 
		'0x00-54': {name: "SmokeDensityv8" /* BitMask BITMASK */ }, 
		'0x00-55': {name: "WaterFlowv9" /* BitMask BITMASK */ }, 
		'0x00-56': {name: "WaterPressurev9" /* BitMask BITMASK */ }, 
		'0x00-57': {name: "RfSignalStrengthv9" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_SENSOR_MULTILEVEL_SUPPORTED_SENSOR_), {length: 58});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 58}), ENUM_SENSOR_MULTILEVEL_SUPPORTED_SENSOR_.enum);
		return context;
	}
};

const ENUM_SENSOR_MULTILEVEL_SUPPORTED_SENSOR_ = {
	AirTemperature: 0x01, 
	GeneralPurposeValue: 0x02, 
	Luminance: 0x03, 
	Power: 0x04, 
	Humidity: 0x05, 
	Velocity: 0x06, 
	Direction: 0x07, 
	AtmosphericPressure: 0x08, 
	BarometricPressure: 0x09, 
	SolarRadiation: 0x0a, 
	DewPoint: 0x0b, 
	RainRate: 0x0c, 
	TideLevel: 0x0d, 
	Weight: 0x0e, 
	Voltage: 0x0f, 
	Current: 0x10, 
	CO2level: 0x11, 
	AirFlow: 0x12, 
	TankCapacity: 0x13, 
	Distance: 0x14, 
	AnglePosition: 0x15, 
	Rotation: 0x16, 
	WaterTemperature: 0x17, 
	SoilTemperature: 0x18, 
	SeismicIntensity: 0x19, 
	SeismicMagnitude: 0x1a, 
	Ultraviolet: 0x1b, 
	ElectricalResistivity: 0x1c, 
	ElectricalConductivity: 0x1d, 
	Loudness: 0x1e, 
	Moisture: 0x1f, 
	Frequency: 0x20, 
	Time: 0x21, 
	TargetTemperature: 0x22, 
	ParticulateMatter25: 0x23, 
	FormaldehydeCh2olevel: 0x24, 
	RadonConcentration: 0x25, 
	MethaneDensityCh4: 0x26, 
	VolatileOrganicCompound: 0x27, 
	CarbonMonoxideColevel: 0x28, 
	SoilHumidity: 0x29, 
	SoilReactivity: 0x2a, 
	SoilSalinity: 0x2b, 
	HeartRate: 0x2c, 
	BloodPressure: 0x2d, 
	MuscleMass: 0x2e, 
	FatMass: 0x2f, 
	BoneMass: 0x30, 
	TotalBodyWaterTbw: 0x31, 
	BasicMetabolicRateBmr: 0x32, 
	BodyMassIndexBmi: 0x33, 
	AccelerationXaxisv8: 0x34, 
	AccelerationYaxisv8: 0x35, 
	AccelerationZaxisv8: 0x36, 
	SmokeDensityv8: 0x37, 
	WaterFlowv9: 0x38, 
	WaterPressurev9: 0x39, 
	RfSignalStrengthv9: 0x3a, 
	enum: {
		0x01: "AirTemperature", 
		0x02: "GeneralPurposeValue", 
		0x03: "Luminance", 
		0x04: "Power", 
		0x05: "Humidity", 
		0x06: "Velocity", 
		0x07: "Direction", 
		0x08: "AtmosphericPressure", 
		0x09: "BarometricPressure", 
		0x0a: "SolarRadiation", 
		0x0b: "DewPoint", 
		0x0c: "RainRate", 
		0x0d: "TideLevel", 
		0x0e: "Weight", 
		0x0f: "Voltage", 
		0x10: "Current", 
		0x11: "CO2level", 
		0x12: "AirFlow", 
		0x13: "TankCapacity", 
		0x14: "Distance", 
		0x15: "AnglePosition", 
		0x16: "Rotation", 
		0x17: "WaterTemperature", 
		0x18: "SoilTemperature", 
		0x19: "SeismicIntensity", 
		0x1a: "SeismicMagnitude", 
		0x1b: "Ultraviolet", 
		0x1c: "ElectricalResistivity", 
		0x1d: "ElectricalConductivity", 
		0x1e: "Loudness", 
		0x1f: "Moisture", 
		0x20: "Frequency", 
		0x21: "Time", 
		0x22: "TargetTemperature", 
		0x23: "ParticulateMatter25", 
		0x24: "FormaldehydeCh2olevel", 
		0x25: "RadonConcentration", 
		0x26: "MethaneDensityCh4", 
		0x27: "VolatileOrganicCompound", 
		0x28: "CarbonMonoxideColevel", 
		0x29: "SoilHumidity", 
		0x2a: "SoilReactivity", 
		0x2b: "SoilSalinity", 
		0x2c: "HeartRate", 
		0x2d: "BloodPressure", 
		0x2e: "MuscleMass", 
		0x2f: "FatMass", 
		0x30: "BoneMass", 
		0x31: "TotalBodyWaterTbw", 
		0x32: "BasicMetabolicRateBmr", 
		0x33: "BodyMassIndexBmi", 
		0x34: "AccelerationXaxisv8", 
		0x35: "AccelerationYaxisv8", 
		0x36: "AccelerationZaxisv8", 
		0x37: "SmokeDensityv8", 
		0x38: "WaterFlowv9", 
		0x39: "WaterPressurev9", 
		0x3a: "RfSignalStrengthv9"
	}
};

// SENSOR_MULTILEVEL [0x31] SUPPORTED_GET_SCALE [0x03] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x03] = {
	name: "SUPPORTED_GET_SCALE",
	help: "Multilevel Sensor Get Supported Scale",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE = {
	Temperatureversion1: 0x01, 
	GeneralPurposeValueversion1: 0x02, 
	Luminanceversion1: 0x03, 
	Powerversion2: 0x04, 
	RelativeHumidityversion2: 0x05, 
	Velocityversion2: 0x06, 
	Directionversion2: 0x07, 
	AtmosphericPressureversion2: 0x08, 
	BarometricPressureversion2: 0x09, 
	SolarRadiationversion2: 0x0a, 
	DewPointversion2: 0x0b, 
	RainRateversion2: 0x0c, 
	TideLevelversion2: 0x0d, 
	Weightversion3: 0x0e, 
	Voltageversion3: 0x0f, 
	Currentversion3: 0x10, 
	Co2levelversion3: 0x11, 
	AirFlowversion3: 0x12, 
	TankCapacityversion3: 0x13, 
	Distanceversion3: 0x14, 
	AnglePositionversion4: 0x15, 
	Rotationv5: 0x16, 
	WaterTemperaturev5: 0x17, 
	SoilTemperaturev5: 0x18, 
	SeismicIntensityv5: 0x19, 
	SeismicMagnitudev5: 0x1a, 
	Ultravioletv5: 0x1b, 
	ElectricalResistivityv5: 0x1c, 
	ElectricalConductivityv5: 0x1d, 
	Loudnessv5: 0x1e, 
	Moisturev5: 0x1f, 
	Frequencyv6: 0x20, 
	Timev6: 0x21, 
	TargetTemperaturev6: 0x22, 
	ParticulateMatter25v7: 0x23, 
	FormaldehydeCh2olevelv7: 0x24, 
	RadonConcentrationv7: 0x25, 
	MethaneDensityCh4v7: 0x26, 
	VolatileOrganicCompoundv7: 0x27, 
	CarbonMonoxideColevelv7: 0x28, 
	SoilHumidityv7: 0x29, 
	SoilReactivityv7: 0x2a, 
	SoilSalinityv7: 0x2b, 
	HeartRatev7: 0x2c, 
	BloodPressurev7: 0x2d, 
	MuscleMassv7: 0x2e, 
	FatMassv7: 0x2f, 
	BoneMassv7: 0x30, 
	TotalBodyWaterTbwv7: 0x31, 
	BasicMetabolicRateBmrv7: 0x32, 
	BodyMassIndexBmiv7: 0x33, 
	AccelerationXaxisv8: 0x34, 
	AccelerationYaxisv8: 0x35, 
	AccelerationZaxisv8: 0x36, 
	SmokeDensityv8: 0x37, 
	WaterFlowv9: 0x38, 
	WaterPressurev9: 0x39, 
	RfSignalStrengthv9: 0x3a, 
	enum: {
		0x01: "Temperatureversion1", 
		0x02: "GeneralPurposeValueversion1", 
		0x03: "Luminanceversion1", 
		0x04: "Powerversion2", 
		0x05: "RelativeHumidityversion2", 
		0x06: "Velocityversion2", 
		0x07: "Directionversion2", 
		0x08: "AtmosphericPressureversion2", 
		0x09: "BarometricPressureversion2", 
		0x0a: "SolarRadiationversion2", 
		0x0b: "DewPointversion2", 
		0x0c: "RainRateversion2", 
		0x0d: "TideLevelversion2", 
		0x0e: "Weightversion3", 
		0x0f: "Voltageversion3", 
		0x10: "Currentversion3", 
		0x11: "Co2levelversion3", 
		0x12: "AirFlowversion3", 
		0x13: "TankCapacityversion3", 
		0x14: "Distanceversion3", 
		0x15: "AnglePositionversion4", 
		0x16: "Rotationv5", 
		0x17: "WaterTemperaturev5", 
		0x18: "SoilTemperaturev5", 
		0x19: "SeismicIntensityv5", 
		0x1a: "SeismicMagnitudev5", 
		0x1b: "Ultravioletv5", 
		0x1c: "ElectricalResistivityv5", 
		0x1d: "ElectricalConductivityv5", 
		0x1e: "Loudnessv5", 
		0x1f: "Moisturev5", 
		0x20: "Frequencyv6", 
		0x21: "Timev6", 
		0x22: "TargetTemperaturev6", 
		0x23: "ParticulateMatter25v7", 
		0x24: "FormaldehydeCh2olevelv7", 
		0x25: "RadonConcentrationv7", 
		0x26: "MethaneDensityCh4v7", 
		0x27: "VolatileOrganicCompoundv7", 
		0x28: "CarbonMonoxideColevelv7", 
		0x29: "SoilHumidityv7", 
		0x2a: "SoilReactivityv7", 
		0x2b: "SoilSalinityv7", 
		0x2c: "HeartRatev7", 
		0x2d: "BloodPressurev7", 
		0x2e: "MuscleMassv7", 
		0x2f: "FatMassv7", 
		0x30: "BoneMassv7", 
		0x31: "TotalBodyWaterTbwv7", 
		0x32: "BasicMetabolicRateBmrv7", 
		0x33: "BodyMassIndexBmiv7", 
		0x34: "AccelerationXaxisv8", 
		0x35: "AccelerationYaxisv8", 
		0x36: "AccelerationZaxisv8", 
		0x37: "SmokeDensityv8", 
		0x38: "WaterFlowv9", 
		0x39: "WaterPressurev9", 
		0x3a: "RfSignalStrengthv9"
	}
};

// SENSOR_MULTILEVEL [0x31] GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x04] = {
	name: "GET",
	help: "Multilevel Sensor Get",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }, 
		'0x01a': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved2" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE)); else return payload.asBuffer();
		if ('Reserved1' in context || 'Scale' in context || 'Reserved2' in context) {
			let _properties1 = 0x00;
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Reserved2' in context) _properties1 = _properties1 | ((context['Reserved2'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		return context;
	}
};

// SENSOR_MULTILEVEL [0x31] REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x05] = {
	name: "REPORT",
	help: "Multilevel Sensor Report",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }, 
		'0x01a': {name: "Size" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Level STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "SensorValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('SensorValue' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'SensorValue', 'Precision', 'Size');
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE)); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _level = 0x00;
			if ('Size' in context) _level = _level | ((context['Size']) & 0x07);
			if ('Scale' in context) _level = _level | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _level = _level | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('SensorValue' in context) payload.writeFLOATING(context['SensorValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE.enum); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_level & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SensorValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// SENSOR_MULTILEVEL [0x31] SUPPORTED_SCALE_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x31].command[0x06] = {
	name: "SUPPORTED_SCALE_REPORT",
	help: "Multilevel Sensor Supported Scale Report",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }, 
		'0x01a': {name: "ScaleBitMask" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE)); else return payload.asBuffer();
		if ('ScaleBitMask' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('ScaleBitMask' in context) _properties1 = _properties1 | ((context['ScaleBitMask']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ScaleBitMask'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x32 METER COMMANDS
 */

// METER [0x32] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x32].command[0x01] = {
	name: "GET",
	help: "Meter Get",
	param: { 
		'0x00a': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Scale2" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateType' in context || 'Reserved' in context || 'Scale' in context) {
			let _properties1 = 0x00;
			if ('RateType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'RateType', ENUM_METER_RATE_TYPE) << 6) & 0xc0); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x38);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Scale2' in context) payload.writeBYTE(context['Scale2']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RateType'] = helpers.lookupNameValue((_properties1 & 0xc0) >> 6, ENUM_METER_RATE_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x38) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Scale2'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_METER_RATE_TYPE = {
	Reserved: 0x00, 
	Import: 0x01, 
	Export: 0x02, 
	NotToBeUsed: 0x03, 
	enum: {
		0x00: "Reserved", 
		0x01: "Import", 
		0x02: "Export", 
		0x03: "NotToBeUsed"
	}
};

// METER [0x32] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x32].command[0x02] = {
	name: "REPORT",
	help: "Meter Report",
	param: { 
		'0x00a': {name: "MeterType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "ScaleBit2" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Size" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "ScaleBits10" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "MeterValue" /* VARIANT */ }, 
		'0x03': {name: "DeltaTime" /* WORD */ }, 
		'0x04': {name: "PreviousMeterValue" /* VARIANT */ }, 
		'0x05': {name: "Scale2" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('MeterValue' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'MeterValue', 'Precision', 'Size');
		if (('PreviousMeterValue' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'PreviousMeterValue', 'Precision', 'Size');
		if ('MeterType' in context || 'RateType' in context || 'ScaleBit2' in context) {
			let _properties1 = 0x00;
			if ('MeterType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'MeterType', ENUM_METER_METER_TYPE)) & 0x1f); 
			if ('RateType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'RateType', ENUM_METER_RATE_TYPE) << 5) & 0x60); 
			if (context['ScaleBit2']) _properties1 = _properties1 | 0x80;
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Size' in context || 'ScaleBits10' in context || 'Precision' in context) {
			let _properties2 = 0x00;
			if ('Size' in context) _properties2 = _properties2 | ((context['Size']) & 0x07);
			if ('ScaleBits10' in context) _properties2 = _properties2 | ((context['ScaleBits10'] << 3) & 0x18);
			if ('Precision' in context) _properties2 = _properties2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MeterValue' in context) payload.writeFLOATING(context['MeterValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('DeltaTime' in context) payload.writeWORD(context['DeltaTime']); else return payload.asBuffer();
		if ((payload.at(3) & 0xff) !== 0) /* optional flag for PreviousMeterValue */ {
			if ('PreviousMeterValue' in context) payload.writeFLOATING(context['PreviousMeterValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		}
		if ('Scale2' in context) payload.writeBYTE(context['Scale2']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MeterType'] = helpers.lookupNameValue((_properties1 & 0x1f), ENUM_METER_METER_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = helpers.lookupNameValue((_properties1 & 0x60) >> 5, ENUM_METER_RATE_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['ScaleBit2'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['ScaleBits10'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MeterValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		if (!payload.insufficientBytes(1)) context['DeltaTime'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['PreviousMeterValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		if (!payload.insufficientBytes(1)) context['Scale2'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_METER_METER_TYPE = {
	Reserved: 0x00, 
	ElectricMeter: 0x01, 
	GasMeter: 0x02, 
	WaterMeter: 0x03, 
	enum: {
		0x00: "Reserved", 
		0x01: "ElectricMeter", 
		0x02: "GasMeter", 
		0x03: "WaterMeter"
	}
};

// METER [0x32] SUPPORTED_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x32].command[0x03] = {
	name: "SUPPORTED_GET",
	help: "Meter Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER [0x32] SUPPORTED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x32].command[0x04] = {
	name: "SUPPORTED_REPORT",
	help: "Meter Supported Report",
	param: { 
		'0x00a': {name: "MeterType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "MeterReset" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "MST" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "ScaleSupported0" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "NumberOfScaleSupportedBytesToFollow" /* BYTE */ }, 
		'0x03': {name: "ScaleSupported" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MeterType' in context || 'RateType' in context || 'MeterReset' in context) {
			let _properties1 = 0x00;
			if ('MeterType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'MeterType', ENUM_METER_METER_TYPE)) & 0x1f); 
			if ('RateType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'RateType', ENUM_METER_SUPPORTED_RATE_TYPE) << 5) & 0x60); 
			if (context['MeterReset']) _properties1 = _properties1 | 0x80;
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MST' in context || 'ScaleSupported0' in context) {
			let _properties2 = 0x00;
			if (context['MST']) _properties2 = _properties2 | 0x80;
			if ('ScaleSupported0' in context) _properties2 = _properties2 | ((context['ScaleSupported0']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('NumberOfScaleSupportedBytesToFollow' in context) payload.writeBYTE(context['NumberOfScaleSupportedBytesToFollow']); else return payload.asBuffer();
		if ('ScaleSupported' in context) payload.writeSTRING(context['ScaleSupported'], { encoding: 'hex', length: (payload.at(2) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MeterType'] = helpers.lookupNameValue((_properties1 & 0x1f), ENUM_METER_METER_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = helpers.lookupNameValue((_properties1 & 0x60) >> 5, ENUM_METER_SUPPORTED_RATE_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['MeterReset'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MST'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ScaleSupported0'] = (_properties2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['NumberOfScaleSupportedBytesToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScaleSupported'] = payload.readSTRING({ encoding: 'hex', length: payload.at(2) & 0xff }); else return context;
		return context;
	}
};

const ENUM_METER_SUPPORTED_RATE_TYPE = {
	Reserved: 0x00, 
	ImportOnly: 0x01, 
	ExportOnly: 0x02, 
	ImportAndExport: 0x03, 
	enum: {
		0x00: "Reserved", 
		0x01: "ImportOnly", 
		0x02: "ExportOnly", 
		0x03: "ImportAndExport"
	}
};

// METER [0x32] RESET [0x05] COMMAND 
COMMAND_CLASS.enum[0x32].command[0x05] = {
	name: "RESET",
	help: "Meter Reset",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x33 SWITCH_COLOR COMMANDS
 */

// SWITCH_COLOR [0x33] SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x01] = {
	name: "SUPPORTED_GET",
	help: "Color Switch Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SWITCH_COLOR [0x33] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Color Switch Supported Report",
	param: { 
		'0x00': {name: "ColorComponentMask" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ColorComponentMask' in context) payload.writeWORD(context['ColorComponentMask']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ColorComponentMask'] = payload.readWORD(); else return context;
		return context;
	}
};

// SWITCH_COLOR [0x33] GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x03] = {
	name: "GET",
	help: "Color Switch Get",
	param: { 
		'0x00': {name: "ColorComponentId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ColorComponentId' in context) payload.writeBYTE(context['ColorComponentId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ColorComponentId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SWITCH_COLOR [0x33] REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x04] = {
	name: "REPORT",
	help: "Color Switch Report",
	param: { 
		'0x00': {name: "ColorComponentId" /* BYTE */ }, 
		'0x01': {name: "CurrentValue" /* BYTE */ }, 
		'0x02': {name: "TargetValue" /* BYTE */ }, 
		'0x03': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ColorComponentId' in context) payload.writeBYTE(context['ColorComponentId']); else return payload.asBuffer();
		if ('CurrentValue' in context) payload.writeBYTE(context['CurrentValue']); else return payload.asBuffer();
		if ('TargetValue' in context) payload.writeBYTE(context['TargetValue']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_REPORT_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ColorComponentId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CurrentValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['TargetValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_REPORT_DURATION.enum); else return context;
		return context;
	}
};

// SWITCH_COLOR [0x33] SET [0x05] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x05] = {
	name: "SET",
	help: "Color Switch Set",
	param: { 
		'0x00a': {name: "ColorComponentCount" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "ColorComponentId" /* BYTE */ },
				'0x01-0x01': {name: "Value" /* BYTE */ }, 
		'0x02': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ColorComponentCount' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('ColorComponentCount' in context) _properties1 = _properties1 | ((context['ColorComponentCount']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0) & 0x1f)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('ColorComponentId' in context) payload.writeBYTE(context['ColorComponentId']); else return payload.asBuffer();
				if ('Value' in context) payload.writeBYTE(context['Value']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ColorComponentCount'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(0) & 0x1f; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['ColorComponentId'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Value'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_DURATION.enum); else return context;
		return context;
	}
};

// SWITCH_COLOR [0x33] START_LEVEL_CHANGE [0x06] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x06] = {
	name: "START_LEVEL_CHANGE",
	help: "Color Switch Start Level Change",
	param: { 
		'0x00a': {name: "IgnoreStartState" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "UpDown" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Res2" /* Properties1 STRUCT_BYTE */ }, 
		'0x00d': {name: "Res1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ColorComponentId" /* BYTE */ }, 
		'0x02': {name: "StartLevel" /* BYTE */ }, 
		'0x03': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IgnoreStartState' in context || 'UpDown' in context || 'Res2' in context || 'Res1' in context) {
			let _properties1 = 0x00;
			if (context['IgnoreStartState']) _properties1 = _properties1 | 0x20;
			if (context['UpDown']) _properties1 = _properties1 | 0x40;
			if (context['Res2']) _properties1 = _properties1 | 0x80;
			if ('Res1' in context) _properties1 = _properties1 | ((context['Res1']) & 0x1f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ColorComponentId' in context) payload.writeBYTE(context['ColorComponentId']); else return payload.asBuffer();
		if ('StartLevel' in context) payload.writeBYTE(context['StartLevel']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IgnoreStartState'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['UpDown'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Res2'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Res1'] = (_properties1 & 0x1f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['ColorComponentId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartLevel'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_DURATION.enum); else return context;
		return context;
	}
};

// SWITCH_COLOR [0x33] STOP_LEVEL_CHANGE [0x07] COMMAND 
COMMAND_CLASS.enum[0x33].command[0x07] = {
	name: "STOP_LEVEL_CHANGE",
	help: "Color Switch Stop Level Change",
	param: { 
		'0x00': {name: "ColorComponentId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ColorComponentId' in context) payload.writeBYTE(context['ColorComponentId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ColorComponentId'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x34 NETWORK_MANAGEMENT_INCLUSION COMMANDS
 */

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD [0x01] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x01] = {
	name: "NODE_ADD",
	help: "Node Add",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Reserved" /* BYTE */ }, 
		'0x02': {name: "Mode" /* CONST */ }, 
		'0x03-0': {name: "Ack" /* TxOptions BITMASK */ }, 
		'0x03-1': {name: "LowPower" /* TxOptions BITMASK */ }, 
		'0x03-2': {name: "AutoRoute" /* TxOptions BITMASK */ }, 
		'0x03-3': {name: "Reserved" /* TxOptions BITMASK */ }, 
		'0x03-4': {name: "NoRoute" /* TxOptions BITMASK */ }, 
		'0x03-5': {name: "Explore" /* TxOptions BITMASK */ }, 
		'0x03-6': {name: "NoRetransmission" /* TxOptions BITMASK */ }, 
		'0x03-7': {name: "HighPower" /* TxOptions BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_MODE)); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_MODE.enum); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS.enum);
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_MODE = {
	NodeAddAny: 0x01, 
	NodeAddController: 0x02, 
	NodeAddSlave: 0x03, 
	NodeAddExisting: 0x04, 
	NodeAddStop: 0x05, 
	NodeAddStopFailed: 0x06, 
	NodeAddAnyS2: 0x07, 
	enum: {
		0x01: "NodeAddAny", 
		0x02: "NodeAddController", 
		0x03: "NodeAddSlave", 
		0x04: "NodeAddExisting", 
		0x05: "NodeAddStop", 
		0x06: "NodeAddStopFailed", 
		0x07: "NodeAddAnyS2"
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS = {
	Ack: 0x00, 
	LowPower: 0x01, 
	AutoRoute: 0x02, 
	Reserved: 0x03, 
	NoRoute: 0x04, 
	Explore: 0x05, 
	NoRetransmission: 0x06, 
	HighPower: 0x07, 
	enum: {
		0x00: "Ack", 
		0x01: "LowPower", 
		0x02: "AutoRoute", 
		0x03: "Reserved", 
		0x04: "NoRoute", 
		0x05: "Explore", 
		0x06: "NoRetransmission", 
		0x07: "HighPower"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD_STATUS [0x02] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x02] = {
	name: "NODE_ADD_STATUS",
	help: "Node Add Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "Reserved" /* BYTE */ }, 
		'0x03': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x04': {name: "NodeInfoLength" /* BYTE */ }, 
		'0x05a': {name: "Listening" /* Properties1 STRUCT_BYTE */ }, 
		'0x05b': {name: "Capability" /* Properties1 STRUCT_BYTE */ }, 
		'0x06a': {name: "Opt" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "Security" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "BasicDeviceClass" /* BYTE */ }, 
		'0x08': {name: "GenericDeviceClass" /* BYTE */ }, 
		'0x09': {name: "SpecificDeviceClass" /* BYTE */ }, 
		'0x0a': {name: "NonsecureCommandClass" /* VARIANT */ }, 
		'0x0b': null /* MARKER SecurityMark handled by VARIANT */, 
		'0x0c': {name: "SecureCommandClass" /* VARIANT */ }, 
		'0x0d': {name: "GrantedKeys" /* BYTE */ }, 
		'0x0e': {name: "KexFailType" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS)); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('NodeInfoLength' in context) payload.writeBYTE(context['NodeInfoLength']); else return payload.asBuffer();
		if ('Listening' in context || 'Capability' in context) {
			let _properties1 = 0x00;
			if (context['Listening']) _properties1 = _properties1 | 0x80;
			if ('Capability' in context) _properties1 = _properties1 | ((context['Capability']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Opt' in context || 'Security' in context) {
			let _properties2 = 0x00;
			if (context['Opt']) _properties2 = _properties2 | 0x80;
			if ('Security' in context) _properties2 = _properties2 | ((context['Security']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('BasicDeviceClass' in context) payload.writeBYTE(context['BasicDeviceClass']); else return payload.asBuffer();
		if ('GenericDeviceClass' in context) payload.writeBYTE(context['GenericDeviceClass']); else return payload.asBuffer();
		if ('SpecificDeviceClass' in context) payload.writeBYTE(context['SpecificDeviceClass']); else return payload.asBuffer();
		if ('NonsecureCommandClass' in context) payload.writeSTRINGtoMARKER(context['NonsecureCommandClass'], { encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return payload.asBuffer();
		if ('SecureCommandClass' in context) payload.writeSTRING(context['SecureCommandClass'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('GrantedKeys' in context) payload.writeBYTE(context['GrantedKeys']); else return payload.asBuffer();
		if ('KexFailType' in context) payload.writeBYTE(context['KexFailType']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NodeInfoLength'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Listening'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Capability'] = (_properties1 & 0x7f); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Opt'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Security'] = (_properties2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['BasicDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GenericDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SpecificDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NonsecureCommandClass'] = payload.readSTRINGtoMARKER({ encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return context;
		if (!payload.insufficientBytes(1)) context['SecureCommandClass'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['GrantedKeys'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KexFailType'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS = {
	NodeAddStatusDone: 0x06, 
	NodeAddStatusFailed: 0x07, 
	NodeAddStatusSecurityFailed: 0x09, 
	enum: {
		0x06: "NodeAddStatusDone", 
		0x07: "NodeAddStatusFailed", 
		0x09: "NodeAddStatusSecurityFailed"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_REMOVE [0x03] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x03] = {
	name: "NODE_REMOVE",
	help: "Node Remove",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Reserved" /* BYTE */ }, 
		'0x02': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_MODE.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_MODE = {
	NodeRemoveAny: 0x01, 
	NodeRemoveController: 0x02, 
	NodeRemoveSlave: 0x03, 
	NodeRemoveStop: 0x05, 
	enum: {
		0x01: "NodeRemoveAny", 
		0x02: "NodeRemoveController", 
		0x03: "NodeRemoveSlave", 
		0x05: "NodeRemoveStop"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_REMOVE_STATUS [0x04] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x04] = {
	name: "NODE_REMOVE_STATUS",
	help: "Node Remove Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_STATUS)); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_STATUS = {
	NodeRemoveStatusDone: 0x06, 
	NodeRemoveStatusFailed: 0x07, 
	enum: {
		0x06: "NodeRemoveStatusDone", 
		0x07: "NodeRemoveStatusFailed"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] FAILED_NODE_REMOVE [0x07] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x07] = {
	name: "FAILED_NODE_REMOVE",
	help: "Failed Node Remove",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] FAILED_NODE_REMOVE_STATUS [0x08] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x08] = {
	name: "FAILED_NODE_REMOVE_STATUS",
	help: "Failed Node Remove Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REMOVE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REMOVE_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REMOVE_STATUS = {
	FailedNodeNotFound: 0x00, 
	Done: 0x01, 
	FailedNodeRemoveFail: 0x02, 
	enum: {
		0x00: "FailedNodeNotFound", 
		0x01: "Done", 
		0x02: "FailedNodeRemoveFail"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] FAILED_NODE_REPLACE [0x09] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x09] = {
	name: "FAILED_NODE_REPLACE",
	help: "Failed Node Replace",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02-0': {name: "Ack" /* TxOptions BITMASK */ }, 
		'0x02-1': {name: "LowPower" /* TxOptions BITMASK */ }, 
		'0x02-2': {name: "AutoRoute" /* TxOptions BITMASK */ }, 
		'0x02-3': {name: "Reserved" /* TxOptions BITMASK */ }, 
		'0x02-4': {name: "NoRoute" /* TxOptions BITMASK */ }, 
		'0x02-5': {name: "Explore" /* TxOptions BITMASK */ }, 
		'0x02-6': {name: "NoRetransmission" /* TxOptions BITMASK */ }, 
		'0x02-7': {name: "HighPower" /* TxOptions BITMASK */ }, 
		'0x03': {name: "Mode" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS), {length: 1});
		if ('Mode' in context) payload.writeBYTE(context['Mode']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS.enum);
		if (!payload.insufficientBytes(1)) context['Mode'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] FAILED_NODE_REPLACE_STATUS [0x0a] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0a] = {
	name: "FAILED_NODE_REPLACE_STATUS",
	help: "Failed Node Replace Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x03': {name: "GrantedKeys" /* BYTE */ }, 
		'0x04': {name: "KexFailType" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REPLACE_STATUS)); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('GrantedKeys' in context) payload.writeBYTE(context['GrantedKeys']); else return payload.asBuffer();
		if ('KexFailType' in context) payload.writeBYTE(context['KexFailType']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REPLACE_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GrantedKeys'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KexFailType'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REPLACE_STATUS = {
	Done: 0x04, 
	FailedNodeReplaceFail: 0x05, 
	FailedNodeReplaceSecurityFailed: 0x09, 
	enum: {
		0x04: "Done", 
		0x05: "FailedNodeReplaceFail", 
		0x09: "FailedNodeReplaceSecurityFailed"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_NEIGHBOR_UPDATE_REQUEST [0x0b] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0b] = {
	name: "NODE_NEIGHBOR_UPDATE_REQUEST",
	help: "Node Neighbor Update Request",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_NEIGHBOR_UPDATE_STATUS [0x0c] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0c] = {
	name: "NODE_NEIGHBOR_UPDATE_STATUS",
	help: "Node Neighbor Update Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_NEIGHBOR_UPDATE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_NEIGHBOR_UPDATE_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_NEIGHBOR_UPDATE_STATUS = {
	NeighborUpdateStatusDone: 0x22, 
	NeighborUpdateStatusFail: 0x23, 
	enum: {
		0x22: "NeighborUpdateStatusDone", 
		0x23: "NeighborUpdateStatusFail"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] RETURN_ROUTE_ASSIGN [0x0d] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0d] = {
	name: "RETURN_ROUTE_ASSIGN",
	help: "Return Route Assign",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwaveNodeId", alias: "SourceNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "DestinationNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwaveNodeId' in context) payload.writeBYTE(context['zwaveNodeId']); else return payload.asBuffer();
		if ('DestinationNodeId' in context) payload.writeBYTE(context['DestinationNodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwaveNodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DestinationNodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] RETURN_ROUTE_ASSIGN_COMPLETE [0x0e] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0e] = {
	name: "RETURN_ROUTE_ASSIGN_COMPLETE",
	help: "Return Route Assign Complete",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS = {
	TransmitCompleteOk: 0x00, 
	TransmitCompleteNoAck: 0x01, 
	TransmitCompleteFail: 0x02, 
	enum: {
		0x00: "TransmitCompleteOk", 
		0x01: "TransmitCompleteNoAck", 
		0x02: "TransmitCompleteFail"
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] RETURN_ROUTE_DELETE [0x0f] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x0f] = {
	name: "RETURN_ROUTE_DELETE",
	help: "Return Route Delete",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] RETURN_ROUTE_DELETE_COMPLETE [0x10] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x10] = {
	name: "RETURN_ROUTE_DELETE_COMPLETE",
	help: "Return Route Delete Complete",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS.enum); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD_KEYS_REPORT [0x11] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x11] = {
	name: "NODE_ADD_KEYS_REPORT",
	help: "Node Add Keys Report",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "RequestClientsideAuthentication" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "RequestedKeys" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('RequestClientsideAuthentication' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['RequestClientsideAuthentication']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RequestedKeys' in context) payload.writeBYTE(context['RequestedKeys']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RequestClientsideAuthentication'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['RequestedKeys'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD_KEYS_SET [0x12] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x12] = {
	name: "NODE_ADD_KEYS_SET",
	help: "Node Add Keys Set",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "Accept" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "GrantClientsideAuthentication" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "GrantedKeys" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Accept' in context || 'GrantClientsideAuthentication' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Accept']) _properties1 = _properties1 | 0x01;
			if (context['GrantClientsideAuthentication']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('GrantedKeys' in context) payload.writeBYTE(context['GrantedKeys']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Accept'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['GrantClientsideAuthentication'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['GrantedKeys'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD_DSK_REPORT [0x13] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x13] = {
	name: "NODE_ADD_DSK_REPORT",
	help: "Node Add DSK Report",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "InputDskLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "DSK" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('InputDskLength' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('InputDskLength' in context) _properties1 = _properties1 | ((context['InputDskLength']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DSK' in context) payload.writeSTRING(context['DSK'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['InputDskLength'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DSK'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INCLUSION [0x34] NODE_ADD_DSK_SET [0x14] COMMAND 
COMMAND_CLASS.enum[0x34].command[0x14] = {
	name: "NODE_ADD_DSK_SET",
	help: "Node Add DSK Set",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "Accept" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "InputDskLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "InputDsk" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Accept' in context || 'InputDskLength' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Accept']) _properties1 = _properties1 | 0x80;
			if ('InputDskLength' in context) _properties1 = _properties1 | ((context['InputDskLength']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0x70);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('InputDsk' in context) payload.writeSTRING(context['InputDsk'], { encoding: 'hex', length: (payload.at(1) & 0x0f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Accept'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['InputDskLength'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x70) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['InputDsk'] = payload.readSTRING({ encoding: 'hex', length: payload.at(1) & 0x0f }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x35 METER_PULSE COMMANDS
 */

// METER_PULSE [0x35] GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x35].command[0x04] = {
	name: "GET",
	help: "Meter Pulse Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_PULSE [0x35] REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x35].command[0x05] = {
	name: "REPORT",
	help: "Meter Pulse Report",
	param: { 
		'0x00': {name: "PulseCount" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PulseCount' in context) payload.writeDWORD(context['PulseCount']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PulseCount'] = payload.readDWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x36 BASIC_TARIFF_INFO COMMANDS
 */

// BASIC_TARIFF_INFO [0x36] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x36].command[0x01] = {
	name: "GET",
	help: "Basic Tariff Info Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// BASIC_TARIFF_INFO [0x36] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x36].command[0x02] = {
	name: "REPORT",
	help: "Basic Tariff Info Report",
	param: { 
		'0x00a': {name: "Dual" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "TotalNoImportRates" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "E1CurrentRateInUse" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "E1RateConsumptionRegister" /* DWORD */ }, 
		'0x03': {name: "E1TimeForNextRateHours" /* BYTE */ }, 
		'0x04': {name: "E1TimeForNextRateMinutes" /* BYTE */ }, 
		'0x05': {name: "E1TimeForNextRateSeconds" /* BYTE */ }, 
		'0x06a': {name: "E2CurrentRateInUse" /* Properties3 STRUCT_BYTE */ }, 
		'0x06b': {name: "Reserved3" /* Properties3 STRUCT_BYTE */ }, 
		'0x07': {name: "E2RateConsumptionRegister" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Dual' in context || 'TotalNoImportRates' in context || 'Reserved1' in context) {
			let _properties1 = 0x00;
			if (context['Dual']) _properties1 = _properties1 | 0x80;
			if ('TotalNoImportRates' in context) _properties1 = _properties1 | ((context['TotalNoImportRates']) & 0x0f);
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1'] << 4) & 0x70);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('E1CurrentRateInUse' in context || 'Reserved2' in context) {
			let _properties2 = 0x00;
			if ('E1CurrentRateInUse' in context) _properties2 = _properties2 | ((context['E1CurrentRateInUse']) & 0x0f);
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('E1RateConsumptionRegister' in context) payload.writeDWORD(context['E1RateConsumptionRegister']); else return payload.asBuffer();
		if ('E1TimeForNextRateHours' in context) payload.writeBYTE(context['E1TimeForNextRateHours']); else return payload.asBuffer();
		if ('E1TimeForNextRateMinutes' in context) payload.writeBYTE(context['E1TimeForNextRateMinutes']); else return payload.asBuffer();
		if ('E1TimeForNextRateSeconds' in context) payload.writeBYTE(context['E1TimeForNextRateSeconds']); else return payload.asBuffer();
		if ('E2CurrentRateInUse' in context || 'Reserved3' in context) {
			let _properties3 = 0x00;
			if ('E2CurrentRateInUse' in context) _properties3 = _properties3 | ((context['E2CurrentRateInUse']) & 0x0f);
			if ('Reserved3' in context) _properties3 = _properties3 | ((context['Reserved3'] << 4) & 0xf0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('E2RateConsumptionRegister' in context) payload.writeDWORD(context['E2RateConsumptionRegister']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Dual'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['TotalNoImportRates'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0x70) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['E1CurrentRateInUse'] = (_properties2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['E1RateConsumptionRegister'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['E1TimeForNextRateHours'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['E1TimeForNextRateMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['E1TimeForNextRateSeconds'] = payload.readBYTE(); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['E2CurrentRateInUse'] = (_properties3 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved3'] = (_properties3 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['E2RateConsumptionRegister'] = payload.readDWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x37 HRV_STATUS COMMANDS
 */

// HRV_STATUS [0x37] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x37].command[0x01] = {
	name: "GET",
	help: "Hrv Status Get",
	param: { 
		'0x00': {name: "StatusParameter" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('StatusParameter' in context) payload.writeBYTE(helpers.getValue(context, 'StatusParameter', ENUM_HRV_STATUS_STATUS_PARAMETER)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['StatusParameter'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_HRV_STATUS_STATUS_PARAMETER.enum); else return context;
		return context;
	}
};

const ENUM_HRV_STATUS_STATUS_PARAMETER = {
	OutdoorAirTemperature: 0x00, 
	SupplyAirTemperature: 0x01, 
	ExhaustAirTemperature: 0x02, 
	DischargeAirTemperature: 0x03, 
	RoomTemperature: 0x04, 
	RelativeHumidityInRoom: 0x05, 
	RemainingFilterLife: 0x06, 
	enum: {
		0x00: "OutdoorAirTemperature", 
		0x01: "SupplyAirTemperature", 
		0x02: "ExhaustAirTemperature", 
		0x03: "DischargeAirTemperature", 
		0x04: "RoomTemperature", 
		0x05: "RelativeHumidityInRoom", 
		0x06: "RemainingFilterLife"
	}
};

// HRV_STATUS [0x37] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x37].command[0x02] = {
	name: "REPORT",
	help: "Hrv Status Report",
	param: { 
		'0x00': {name: "StatusParameter" /* CONST */ }, 
		'0x01a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('StatusParameter' in context) payload.writeBYTE(helpers.getValue(context, 'StatusParameter', ENUM_HRV_STATUS_STATUS_PARAMETER)); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeSTRING(context['Value'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['StatusParameter'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_HRV_STATUS_STATUS_PARAMETER.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// HRV_STATUS [0x37] SUPPORTED_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x37].command[0x03] = {
	name: "SUPPORTED_GET",
	help: "Hrv Status Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HRV_STATUS [0x37] SUPPORTED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x37].command[0x04] = {
	name: "SUPPORTED_REPORT",
	help: "Hrv Status Supported Report",
	param: { 
		'0x00-0': {name: "OutdoorAirTemperature" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "SupplyAirTemperature" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "ExhaustAirTemperature" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "DischargeAirTemperature" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "RoomTemperature" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "RelativeHumidityInRoom" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "RemainingFilterLife" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_HRV_STATUS_STATUS_PARAMETER), {length: 7});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 7}), ENUM_HRV_STATUS_STATUS_PARAMETER.enum);
		return context;
	}
};



/*
 * COMMAND_CLASS 0x38 THERMOSTAT_HEATING COMMANDS
 */

// THERMOSTAT_HEATING [0x38] MODE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x01] = {
	name: "MODE_SET",
	help: "Thermostat Heating Mode Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_THERMOSTAT_HEATING_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_HEATING_MODE.enum); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_HEATING_MODE = {
	Off: 0x00, 
	OffTimed: 0x01, 
	Off3Hours: 0x02, 
	AntiFreeze: 0x03, 
	Manual: 0x04, 
	TemporaryManual: 0x05, 
	Automatic: 0x06, 
	ManualTimed: 0x07, 
	enum: {
		0x00: "Off", 
		0x01: "OffTimed", 
		0x02: "Off3Hours", 
		0x03: "AntiFreeze", 
		0x04: "Manual", 
		0x05: "TemporaryManual", 
		0x06: "Automatic", 
		0x07: "ManualTimed"
	}
};

// THERMOSTAT_HEATING [0x38] MODE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x02] = {
	name: "MODE_GET",
	help: "Thermostat Heating Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_HEATING [0x38] MODE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x03] = {
	name: "MODE_REPORT",
	help: "Thermostat Heating Mode Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_THERMOSTAT_HEATING_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_HEATING_MODE.enum); else return context;
		return context;
	}
};

// THERMOSTAT_HEATING [0x38] SETPOINT_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x04] = {
	name: "SETPOINT_SET",
	help: "Thermostat Heating Setpoint Set",
	param: { 
		'0x00': {name: "SetpointNr" /* BYTE */ }, 
		'0x01a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointNr' in context) payload.writeBYTE(context['SetpointNr']); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetpointNr'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// THERMOSTAT_HEATING [0x38] SETPOINT_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x05] = {
	name: "SETPOINT_GET",
	help: "Thermostat Heating Setpoint Get",
	param: { 
		'0x00': {name: "SetpointNr" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointNr' in context) payload.writeBYTE(context['SetpointNr']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetpointNr'] = payload.readBYTE(); else return context;
		return context;
	}
};

// THERMOSTAT_HEATING [0x38] SETPOINT_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x06] = {
	name: "SETPOINT_REPORT",
	help: "Thermostat Heating Setpoint Report",
	param: { 
		'0x00': {name: "SetpointNr" /* BYTE */ }, 
		'0x01a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointNr' in context) payload.writeBYTE(context['SetpointNr']); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetpointNr'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// THERMOSTAT_HEATING [0x38] RELAY_STATUS_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x09] = {
	name: "RELAY_STATUS_GET",
	help: "Thermostat Heating Relay Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_HEATING [0x38] RELAY_STATUS_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x0a] = {
	name: "RELAY_STATUS_REPORT",
	help: "Thermostat Heating Relay Status Report",
	param: { 
		'0x00': {name: "RelayStatus" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RelayStatus' in context) payload.writeBYTE(helpers.getValue(context, 'RelayStatus', ENUM_THERMOSTAT_HEATING_RELAY_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RelayStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_HEATING_RELAY_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_HEATING_RELAY_STATUS = {
	Off: 0x00, 
	On: 0x01, 
	enum: {
		0x00: "Off", 
		0x01: "On"
	}
};

// THERMOSTAT_HEATING [0x38] STATUS_SET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x0b] = {
	name: "STATUS_SET",
	help: "Thermostat Heating Status Set",
	param: { 
		'0x00': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_THERMOSTAT_HEATING_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_HEATING_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_HEATING_STATUS = {
	Heating: 0x00, 
	Cooling: 0x01, 
	enum: {
		0x00: "Heating", 
		0x01: "Cooling"
	}
};

// THERMOSTAT_HEATING [0x38] STATUS_GET [0x0c] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x0c] = {
	name: "STATUS_GET",
	help: "Thermostat Heating Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_HEATING [0x38] STATUS_REPORT [0x0d] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x0d] = {
	name: "STATUS_REPORT",
	help: "Thermostat Heating Heating Status Report",
	param: { 
		'0x00': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_THERMOSTAT_HEATING_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_HEATING_STATUS.enum); else return context;
		return context;
	}
};

// THERMOSTAT_HEATING [0x38] TIMED_OFF_SET [0x11] COMMAND 
COMMAND_CLASS.enum[0x38].command[0x11] = {
	name: "TIMED_OFF_SET",
	help: "Thermostat Heating Timed Off Set",
	param: { 
		'0x00': {name: "Minutes" /* BYTE */ }, 
		'0x01': {name: "Hours" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Minutes' in context) payload.writeBYTE(context['Minutes']); else return payload.asBuffer();
		if ('Hours' in context) payload.writeBYTE(context['Hours']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Minutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Hours'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x39 HRV_CONTROL COMMANDS
 */

// HRV_CONTROL [0x39] MODE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x01] = {
	name: "MODE_SET",
	help: "Hrv Control Mode Set",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_HRV_CONTROL_MODE)) & 0x1f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x1f), ENUM_HRV_CONTROL_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		return context;
	}
};

const ENUM_HRV_CONTROL_MODE = {
	Off: 0x00, 
	DemandAutomatic: 0x01, 
	Schedule: 0x02, 
	EnergySavingsMode: 0x03, 
	Manual: 0x04, 
	enum: {
		0x00: "Off", 
		0x01: "DemandAutomatic", 
		0x02: "Schedule", 
		0x03: "EnergySavingsMode", 
		0x04: "Manual"
	}
};

// HRV_CONTROL [0x39] MODE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x02] = {
	name: "MODE_GET",
	help: "Hrv Control Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HRV_CONTROL [0x39] MODE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x03] = {
	name: "MODE_REPORT",
	help: "Hrv Control Mode Report",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_HRV_CONTROL_MODE)) & 0x1f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x1f), ENUM_HRV_CONTROL_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		return context;
	}
};

// HRV_CONTROL [0x39] BYPASS_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x04] = {
	name: "BYPASS_SET",
	help: "Hrv Control Bypass Set",
	param: { 
		'0x00': {name: "Bypass" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Bypass' in context) payload.writeBYTE(context['Bypass']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Bypass'] = payload.readBYTE(); else return context;
		return context;
	}
};

// HRV_CONTROL [0x39] BYPASS_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x05] = {
	name: "BYPASS_GET",
	help: "Hrv Control Bypass  Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HRV_CONTROL [0x39] BYPASS_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x06] = {
	name: "BYPASS_REPORT",
	help: "Hrv Control Bypass Report",
	param: { 
		'0x00': {name: "Bypass" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Bypass' in context) payload.writeBYTE(context['Bypass']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Bypass'] = payload.readBYTE(); else return context;
		return context;
	}
};

// HRV_CONTROL [0x39] VENTILATION_RATE_SET [0x07] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x07] = {
	name: "VENTILATION_RATE_SET",
	help: "Hrv Control Ventilation Rate Set",
	param: { 
		'0x00': {name: "VentilationRate" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('VentilationRate' in context) payload.writeBYTE(context['VentilationRate']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['VentilationRate'] = payload.readBYTE(); else return context;
		return context;
	}
};

// HRV_CONTROL [0x39] VENTILATION_RATE_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x08] = {
	name: "VENTILATION_RATE_GET",
	help: "Hrv Control Ventilation Rate  Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HRV_CONTROL [0x39] VENTILATION_RATE_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x09] = {
	name: "VENTILATION_RATE_REPORT",
	help: "Hrv Control Ventilation Rate  Report",
	param: { 
		'0x00': {name: "VentilationRate" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('VentilationRate' in context) payload.writeBYTE(context['VentilationRate']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['VentilationRate'] = payload.readBYTE(); else return context;
		return context;
	}
};

// HRV_CONTROL [0x39] MODE_SUPPORTED_GET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x0a] = {
	name: "MODE_SUPPORTED_GET",
	help: "Hrv Control Mode Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HRV_CONTROL [0x39] MODE_SUPPORTED_REPORT [0x0b] COMMAND 
COMMAND_CLASS.enum[0x39].command[0x0b] = {
	name: "MODE_SUPPORTED_REPORT",
	help: "Hrv Control Mode Supported Report",
	param: { 
		'0x00a': {name: "ManualControlSupported" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01-0': {name: "Off" /* BitMask BITMASK */ }, 
		'0x01-1': {name: "DemandAutomatic" /* BitMask BITMASK */ }, 
		'0x01-2': {name: "Schedule" /* BitMask BITMASK */ }, 
		'0x01-3': {name: "EnergySavingsMode" /* BitMask BITMASK */ }, 
		'0x01-4': {name: "Manual" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManualControlSupported' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('ManualControlSupported' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'ManualControlSupported', ENUM_HRV_CONTROL_MODE_SUPPORTED_MANUAL_CONTROL_SUPPORTED)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_HRV_CONTROL_MODE), {length: 5});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ManualControlSupported'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HRV_CONTROL_MODE_SUPPORTED_MANUAL_CONTROL_SUPPORTED.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		helpers.setNameFlags(context, payload.readBITMASK({length: 5}), ENUM_HRV_CONTROL_MODE.enum);
		return context;
	}
};

const ENUM_HRV_CONTROL_MODE_SUPPORTED_MANUAL_CONTROL_SUPPORTED = {
	BypassOpenClose: 0x00, 
	BypassAuto: 0x01, 
	ModulatedBypass: 0x02, 
	VentilationRate: 0x03, 
	enum: {
		0x00: "BypassOpenClose", 
		0x01: "BypassAuto", 
		0x02: "ModulatedBypass", 
		0x03: "VentilationRate"
	}
};



/*
 * COMMAND_CLASS 0x3a DCP_CONFIG COMMANDS
 */

// DCP_CONFIG [0x3a] DCP_LIST_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3a].command[0x01] = {
	name: "DCP_LIST_SUPPORTED_GET",
	help: "Dcp List Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DCP_CONFIG [0x3a] DCP_LIST_SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x3a].command[0x02] = {
	name: "DCP_LIST_SUPPORTED_REPORT",
	help: "Dcp List Supported Report",
	param: { 
		'0x00': {name: "DcpListSize" /* BYTE */ }, 
		'0x01': {name: "FreeDcpListEntries" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DcpListSize' in context) payload.writeBYTE(context['DcpListSize']); else return payload.asBuffer();
		if ('FreeDcpListEntries' in context) payload.writeBYTE(context['FreeDcpListEntries']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['DcpListSize'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['FreeDcpListEntries'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DCP_CONFIG [0x3a] DCP_LIST_SET [0x03] COMMAND 
COMMAND_CLASS.enum[0x3a].command[0x03] = {
	name: "DCP_LIST_SET",
	help: "Dcp List Set",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x06': {name: "DcpRateId" /* BYTE */ }, 
		'0x07a': {name: "NumberOfDc" /* Properties1 STRUCT_BYTE */ }, 
		'0x07b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x08': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x08-0x00': {name: "GenericDeviceClass" /* BYTE */ },
				'0x08-0x01': {name: "SpecificDeviceClass" /* BYTE */ }, 
		'0x09': {name: "StartYear" /* WORD */ }, 
		'0x0a': {name: "StartMonth" /* BYTE */ }, 
		'0x0b': {name: "StartDay" /* BYTE */ }, 
		'0x0c': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x0d': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x0e': {name: "StartSecondLocalTime" /* BYTE */ }, 
		'0x0f': {name: "DurationHourTime" /* BYTE */ }, 
		'0x10': {name: "DurationMinuteTime" /* BYTE */ }, 
		'0x11': {name: "DurationSecondTime" /* BYTE */ }, 
		'0x12': {name: "EventPriority" /* BYTE */ }, 
		'0x13': {name: "LoadShedding" /* BYTE */ }, 
		'0x14': {name: "StartAssociationGroup" /* BYTE */ }, 
		'0x15': {name: "StopAssociationGroup" /* BYTE */ }, 
		'0x16': {name: "RandomizationInterval" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('DcpRateId' in context) payload.writeBYTE(context['DcpRateId']); else return payload.asBuffer();
		if ('NumberOfDc' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfDc' in context) _properties1 = _properties1 | ((context['NumberOfDc']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(7) & 0x03)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('GenericDeviceClass' in context) payload.writeBYTE(context['GenericDeviceClass']); else return payload.asBuffer();
				if ('SpecificDeviceClass' in context) payload.writeBYTE(context['SpecificDeviceClass']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StartSecondLocalTime' in context) payload.writeBYTE(context['StartSecondLocalTime']); else return payload.asBuffer();
		if ('DurationHourTime' in context) payload.writeBYTE(context['DurationHourTime']); else return payload.asBuffer();
		if ('DurationMinuteTime' in context) payload.writeBYTE(context['DurationMinuteTime']); else return payload.asBuffer();
		if ('DurationSecondTime' in context) payload.writeBYTE(context['DurationSecondTime']); else return payload.asBuffer();
		if ('EventPriority' in context) payload.writeBYTE(context['EventPriority']); else return payload.asBuffer();
		if ('LoadShedding' in context) payload.writeBYTE(context['LoadShedding']); else return payload.asBuffer();
		if ('StartAssociationGroup' in context) payload.writeBYTE(context['StartAssociationGroup']); else return payload.asBuffer();
		if ('StopAssociationGroup' in context) payload.writeBYTE(context['StopAssociationGroup']); else return payload.asBuffer();
		if ('RandomizationInterval' in context) payload.writeBYTE(context['RandomizationInterval']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DcpRateId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfDc'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(7) & 0x03; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['GenericDeviceClass'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['SpecificDeviceClass'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartSecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationHourTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinuteTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationSecondTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventPriority'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LoadShedding'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartAssociationGroup'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopAssociationGroup'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RandomizationInterval'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DCP_CONFIG [0x3a] DCP_LIST_REMOVE [0x04] COMMAND 
COMMAND_CLASS.enum[0x3a].command[0x04] = {
	name: "DCP_LIST_REMOVE",
	help: "Dcp List Remove",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x3b DCP_MONITOR COMMANDS
 */

// DCP_MONITOR [0x3b] DCP_LIST_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3b].command[0x01] = {
	name: "DCP_LIST_GET",
	help: "Dcp List Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DCP_MONITOR [0x3b] DCP_LIST_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x3b].command[0x02] = {
	name: "DCP_LIST_REPORT",
	help: "Dcp List Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "Year" /* WORD */ }, 
		'0x02': {name: "Month" /* BYTE */ }, 
		'0x03': {name: "Day" /* BYTE */ }, 
		'0x04': {name: "HourLocalTime" /* BYTE */ }, 
		'0x05': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x06': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x07': {name: "DcpId" /* BYTE */ }, 
		'0x08a': {name: "NumberOfDc" /* Properties1 STRUCT_BYTE */ }, 
		'0x08b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x09': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x09-0x00': {name: "GenericDeviceClass" /* BYTE */ },
				'0x09-0x01': {name: "SpecificDeviceClass" /* BYTE */ }, 
		'0x0a': {name: "StartYear" /* WORD */ }, 
		'0x0b': {name: "StartMonth" /* BYTE */ }, 
		'0x0c': {name: "StartDay" /* BYTE */ }, 
		'0x0d': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x0e': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x0f': {name: "StartSecondLocalTime" /* BYTE */ }, 
		'0x10': {name: "DurationHourTime" /* BYTE */ }, 
		'0x11': {name: "DurationMinuteTime" /* BYTE */ }, 
		'0x12': {name: "DurationSecondTime" /* BYTE */ }, 
		'0x13': {name: "EventPriority" /* BYTE */ }, 
		'0x14': {name: "LoadShedding" /* BYTE */ }, 
		'0x15': {name: "StartAssociationGroup" /* BYTE */ }, 
		'0x16': {name: "StopAssociationGroup" /* BYTE */ }, 
		'0x17': {name: "RandomizationInterval" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('DcpId' in context) payload.writeBYTE(context['DcpId']); else return payload.asBuffer();
		if ('NumberOfDc' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfDc' in context) _properties1 = _properties1 | ((context['NumberOfDc']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('GenericDeviceClass' in context) payload.writeBYTE(context['GenericDeviceClass']); else return payload.asBuffer();
				if ('SpecificDeviceClass' in context) payload.writeBYTE(context['SpecificDeviceClass']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StartSecondLocalTime' in context) payload.writeBYTE(context['StartSecondLocalTime']); else return payload.asBuffer();
		if ('DurationHourTime' in context) payload.writeBYTE(context['DurationHourTime']); else return payload.asBuffer();
		if ('DurationMinuteTime' in context) payload.writeBYTE(context['DurationMinuteTime']); else return payload.asBuffer();
		if ('DurationSecondTime' in context) payload.writeBYTE(context['DurationSecondTime']); else return payload.asBuffer();
		if ('EventPriority' in context) payload.writeBYTE(context['EventPriority']); else return payload.asBuffer();
		if ('LoadShedding' in context) payload.writeBYTE(context['LoadShedding']); else return payload.asBuffer();
		if ('StartAssociationGroup' in context) payload.writeBYTE(context['StartAssociationGroup']); else return payload.asBuffer();
		if ('StopAssociationGroup' in context) payload.writeBYTE(context['StopAssociationGroup']); else return payload.asBuffer();
		if ('RandomizationInterval' in context) payload.writeBYTE(context['RandomizationInterval']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DcpId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfDc'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['GenericDeviceClass'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['SpecificDeviceClass'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartSecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationHourTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinuteTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationSecondTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventPriority'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LoadShedding'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartAssociationGroup'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopAssociationGroup'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RandomizationInterval'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DCP_MONITOR [0x3b] DCP_EVENT_STATUS_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x3b].command[0x03] = {
	name: "DCP_EVENT_STATUS_GET",
	help: "Dcp Event Status Get",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DCP_MONITOR [0x3b] DCP_EVENT_STATUS_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x3b].command[0x04] = {
	name: "DCP_EVENT_STATUS_REPORT",
	help: "Dcp Event Status Report",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x06': {name: "EventStatus" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('EventStatus' in context) payload.writeBYTE(helpers.getValue(context, 'EventStatus', ENUM_DCP_MONITOR_DCP_EVENT_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DCP_MONITOR_DCP_EVENT_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_DCP_MONITOR_DCP_EVENT_STATUS = {
	Reserved: 0x00, 
	EventStarted: 0x01, 
	EventCompleted: 0x02, 
	EventRejected: 0x03, 
	EventNotApplicable: 0x04, 
	enum: {
		0x00: "Reserved", 
		0x01: "EventStarted", 
		0x02: "EventCompleted", 
		0x03: "EventRejected", 
		0x04: "EventNotApplicable"
	}
};



/*
 * COMMAND_CLASS 0x3c METER_TBL_CONFIG COMMANDS
 */

// METER_TBL_CONFIG [0x3c] METER_TBL_TABLE_POINT_ADM_NO_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3c].command[0x01] = {
	name: "METER_TBL_TABLE_POINT_ADM_NO_SET",
	help: "Meter Tbl Table Point Adm No Set",
	param: { 
		'0x00a': {name: "NumberOfCharacters" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "MeterPointAdmNumberCharacter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfCharacters' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfCharacters' in context) _properties1 = _properties1 | ((context['NumberOfCharacters']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MeterPointAdmNumberCharacter' in context) payload.writeSTRING(context['MeterPointAdmNumberCharacter'], { encoding: 'hex', length: (payload.at(0) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfCharacters'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MeterPointAdmNumberCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x1f }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x3d METER_TBL_MONITOR COMMANDS
 */

// METER_TBL_MONITOR [0x3d] METER_TBL_TABLE_POINT_ADM_NO_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x01] = {
	name: "METER_TBL_TABLE_POINT_ADM_NO_GET",
	help: "Meter Tbl Table Point Adm No Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_TBL_MONITOR [0x3d] METER_TBL_TABLE_POINT_ADM_NO_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x02] = {
	name: "METER_TBL_TABLE_POINT_ADM_NO_REPORT",
	help: "Meter Tbl Table Point Adm No Report",
	param: { 
		'0x00a': {name: "NumberOfCharacters" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "MeterPointAdmNumberCharacter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfCharacters' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfCharacters' in context) _properties1 = _properties1 | ((context['NumberOfCharacters']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MeterPointAdmNumberCharacter' in context) payload.writeSTRING(context['MeterPointAdmNumberCharacter'], { encoding: 'hex', length: (payload.at(0) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfCharacters'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MeterPointAdmNumberCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x1f }); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_TABLE_ID_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x03] = {
	name: "METER_TBL_TABLE_ID_GET",
	help: "Meter Tbl Table Id Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_TBL_MONITOR [0x3d] METER_TBL_TABLE_ID_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x04] = {
	name: "METER_TBL_TABLE_ID_REPORT",
	help: "Meter Tbl Table Id Report",
	param: { 
		'0x00a': {name: "NumberOfCharacters" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "MeterIdCharacter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfCharacters' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfCharacters' in context) _properties1 = _properties1 | ((context['NumberOfCharacters']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MeterIdCharacter' in context) payload.writeSTRING(context['MeterIdCharacter'], { encoding: 'hex', length: (payload.at(0) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfCharacters'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MeterIdCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x1f }); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_TABLE_CAPABILITY_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x05] = {
	name: "METER_TBL_TABLE_CAPABILITY_GET",
	help: "Meter Tbl Table Capability Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_TBL_MONITOR [0x3d] METER_TBL_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x06] = {
	name: "METER_TBL_REPORT",
	help: "Meter Tbl Report",
	param: { 
		'0x00a': {name: "MeterType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "PayMeter" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "DatasetSupported" /* BIT_24 */ }, 
		'0x03': {name: "DatasetHistorySupported" /* BIT_24 */ }, 
		'0x04': {name: "DataHistorySupported" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MeterType' in context || 'RateType' in context) {
			let _properties1 = 0x00;
			if ('MeterType' in context) _properties1 = _properties1 | ((context['MeterType']) & 0x3f);
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PayMeter' in context || 'Reserved' in context) {
			let _properties2 = 0x00;
			if ('PayMeter' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'PayMeter', ENUM_METER_TBL_MONITOR_METER_TBL_PAY_METER)) & 0x0f); 
			if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('DatasetSupported' in context) payload.writeBIT_24(context['DatasetSupported']); else return payload.asBuffer();
		if ('DatasetHistorySupported' in context) payload.writeBIT_24(context['DatasetHistorySupported']); else return payload.asBuffer();
		if ('DataHistorySupported' in context) payload.writeBIT_24(context['DataHistorySupported']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MeterType'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PayMeter'] = helpers.lookupNameValue((_properties2 & 0x0f), ENUM_METER_TBL_MONITOR_METER_TBL_PAY_METER.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatasetSupported'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['DatasetHistorySupported'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['DataHistorySupported'] = payload.readBIT_24(); else return context;
		return context;
	}
};

const ENUM_METER_TBL_MONITOR_METER_TBL_PAY_METER = {
	Reserved: 0x00, 
	Creditmeter: 0x01, 
	PrepaymentMeter: 0x02, 
	PrepaymentMeterDebt: 0x03, 
	enum: {
		0x00: "Reserved", 
		0x01: "Creditmeter", 
		0x02: "PrepaymentMeter", 
		0x03: "PrepaymentMeterDebt"
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_STATUS_SUPPORTED_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x07] = {
	name: "METER_TBL_STATUS_SUPPORTED_GET",
	help: "Meter Tbl  Status Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_TBL_MONITOR [0x3d] METER_TBL_STATUS_SUPPORTED_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x08] = {
	name: "METER_TBL_STATUS_SUPPORTED_REPORT",
	help: "Meter Tbl  Status Supported Report",
	param: { 
		'0x00': {name: "SupportedOperatingStatus" /* BIT_24 */ }, 
		'0x01': {name: "StatusEventLogDepth" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedOperatingStatus' in context) payload.writeBIT_24(context['SupportedOperatingStatus']); else return payload.asBuffer();
		if ('StatusEventLogDepth' in context) payload.writeBYTE(context['StatusEventLogDepth']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedOperatingStatus'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['StatusEventLogDepth'] = payload.readBYTE(); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_STATUS_DEPTH_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x09] = {
	name: "METER_TBL_STATUS_DEPTH_GET",
	help: "Meter Tbl  Status Depth Get",
	param: { 
		'0x00': {name: "StatusEventLogDepth" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('StatusEventLogDepth' in context) payload.writeBYTE(context['StatusEventLogDepth']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['StatusEventLogDepth'] = payload.readBYTE(); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_STATUS_DATE_GET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0a] = {
	name: "METER_TBL_STATUS_DATE_GET",
	help: "Meter Tbl  Status Date Get",
	param: { 
		'0x00': {name: "MaximumReports" /* BYTE */ }, 
		'0x01': {name: "StartYear" /* WORD */ }, 
		'0x02': {name: "StartMonth" /* BYTE */ }, 
		'0x03': {name: "StartDay" /* BYTE */ }, 
		'0x04': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x05': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x06': {name: "StartSecondLocalTime" /* BYTE */ }, 
		'0x07': {name: "StopYear" /* WORD */ }, 
		'0x08': {name: "StopMonth" /* BYTE */ }, 
		'0x09': {name: "StopDay" /* BYTE */ }, 
		'0x0a': {name: "StopHourLocalTime" /* BYTE */ }, 
		'0x0b': {name: "StopMinuteLocalTime" /* BYTE */ }, 
		'0x0c': {name: "StopSecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MaximumReports' in context) payload.writeBYTE(context['MaximumReports']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StartSecondLocalTime' in context) payload.writeBYTE(context['StartSecondLocalTime']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeWORD(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHourLocalTime' in context) payload.writeBYTE(context['StopHourLocalTime']); else return payload.asBuffer();
		if ('StopMinuteLocalTime' in context) payload.writeBYTE(context['StopMinuteLocalTime']); else return payload.asBuffer();
		if ('StopSecondLocalTime' in context) payload.writeBYTE(context['StopSecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MaximumReports'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartSecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopSecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_STATUS_REPORT [0x0b] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0b] = {
	name: "METER_TBL_STATUS_REPORT",
	help: "Meter Tbl  Status  Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "CurrentOperatingStatus" /* BIT_24 */ }, 
		'0x02': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x02-0x00a': {name: "Type" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x00b': {name: "OperatingStatusEventId" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x01': {name: "Year" /* WORD */ },
				'0x02-0x02': {name: "Month" /* BYTE */ },
				'0x02-0x03': {name: "Day" /* BYTE */ },
				'0x02-0x04': {name: "HourLocalTime" /* BYTE */ },
				'0x02-0x05': {name: "MinuteLocalTime" /* BYTE */ },
				'0x02-0x06': {name: "SecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('CurrentOperatingStatus' in context) payload.writeBIT_24(context['CurrentOperatingStatus']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Type' in context || 'OperatingStatusEventId' in context || 'Reserved' in context) {
					let _properties1 = 0x00;
					if (context['Type']) _properties1 = _properties1 | 0x80;
					if ('OperatingStatusEventId' in context) _properties1 = _properties1 | ((context['OperatingStatusEventId']) & 0x1f);
					if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0x60);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
				if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
				if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
				if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
				if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
				if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CurrentOperatingStatus'] = payload.readBIT_24(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['Type'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['OperatingStatusEventId'] = (_properties1 & 0x1f); else return context;
				if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x60) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
			if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_CURRENT_DATA_GET [0x0c] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0c] = {
	name: "METER_TBL_CURRENT_DATA_GET",
	help: "Meter Tbl Current Data Get",
	param: { 
		'0x00': {name: "DatasetRequested" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DatasetRequested' in context) payload.writeBIT_24(context['DatasetRequested']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['DatasetRequested'] = payload.readBIT_24(); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_CURRENT_DATA_REPORT [0x0d] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0d] = {
	name: "METER_TBL_CURRENT_DATA_REPORT",
	help: "Meter Tbl Current Data Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01a': {name: "OperatingStatusIndication" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "Dataset" /* BIT_24 */ }, 
		'0x03': {name: "Year" /* WORD */ }, 
		'0x04': {name: "Month" /* BYTE */ }, 
		'0x05': {name: "Day" /* BYTE */ }, 
		'0x06': {name: "HourLocalTime" /* BYTE */ }, 
		'0x07': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x08': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x09': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x09-0x00a': {name: "CurrentScale" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x00b': {name: "CurrentPrecision" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x01': {name: "CurrentValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('OperatingStatusIndication' in context || 'RateType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['OperatingStatusIndication']) _properties1 = _properties1 | 0x80;
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0x7c);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Dataset' in context) payload.writeBIT_24(context['Dataset']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('CurrentScale' in context || 'CurrentPrecision' in context) {
					let _properties1 = 0x00;
					if ('CurrentScale' in context) _properties1 = _properties1 | ((context['CurrentScale']) & 0x1f);
					if ('CurrentPrecision' in context) _properties1 = _properties1 | ((context['CurrentPrecision'] << 5) & 0xe0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('CurrentValue' in context) payload.writeDWORD(context['CurrentValue']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OperatingStatusIndication'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7c) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Dataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['CurrentScale'] = (_properties1 & 0x1f); else return context;
				if (!payload.insufficientBytes(1)) context['CurrentPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['CurrentValue'] = payload.readDWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_HISTORICAL_DATA_GET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0e] = {
	name: "METER_TBL_HISTORICAL_DATA_GET",
	help: "Meter Tbl Historical Data Get",
	param: { 
		'0x00': {name: "MaximumReports" /* BYTE */ }, 
		'0x01': {name: "HistoricalDatasetRequested" /* BIT_24 */ }, 
		'0x02': {name: "StartYear" /* WORD */ }, 
		'0x03': {name: "StartMonth" /* BYTE */ }, 
		'0x04': {name: "StartDay" /* BYTE */ }, 
		'0x05': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x06': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x07': {name: "StartSecondLocalTime" /* BYTE */ }, 
		'0x08': {name: "StopYear" /* WORD */ }, 
		'0x09': {name: "StopMonth" /* BYTE */ }, 
		'0x0a': {name: "StopDay" /* BYTE */ }, 
		'0x0b': {name: "StopHourLocalTime" /* BYTE */ }, 
		'0x0c': {name: "StopMinuteLocalTime" /* BYTE */ }, 
		'0x0d': {name: "StopSecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MaximumReports' in context) payload.writeBYTE(context['MaximumReports']); else return payload.asBuffer();
		if ('HistoricalDatasetRequested' in context) payload.writeBIT_24(context['HistoricalDatasetRequested']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StartSecondLocalTime' in context) payload.writeBYTE(context['StartSecondLocalTime']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeWORD(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHourLocalTime' in context) payload.writeBYTE(context['StopHourLocalTime']); else return payload.asBuffer();
		if ('StopMinuteLocalTime' in context) payload.writeBYTE(context['StopMinuteLocalTime']); else return payload.asBuffer();
		if ('StopSecondLocalTime' in context) payload.writeBYTE(context['StopSecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MaximumReports'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HistoricalDatasetRequested'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartSecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopSecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// METER_TBL_MONITOR [0x3d] METER_TBL_HISTORICAL_DATA_REPORT [0x0f] COMMAND 
COMMAND_CLASS.enum[0x3d].command[0x0f] = {
	name: "METER_TBL_HISTORICAL_DATA_REPORT",
	help: "Meter Tbl Historical Data Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01a': {name: "OperatingStatusIndication" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "Dataset" /* BIT_24 */ }, 
		'0x03': {name: "Year" /* WORD */ }, 
		'0x04': {name: "Month" /* BYTE */ }, 
		'0x05': {name: "Day" /* BYTE */ }, 
		'0x06': {name: "HourLocalTime" /* BYTE */ }, 
		'0x07': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x08': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x09': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x09-0x00a': {name: "HistoricalScale" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x00b': {name: "HistoricalPrecision" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x01': {name: "HistoricalValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('OperatingStatusIndication' in context || 'RateType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['OperatingStatusIndication']) _properties1 = _properties1 | 0x80;
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0x7c);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Dataset' in context) payload.writeBIT_24(context['Dataset']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('HistoricalScale' in context || 'HistoricalPrecision' in context) {
					let _properties1 = 0x00;
					if ('HistoricalScale' in context) _properties1 = _properties1 | ((context['HistoricalScale']) & 0x1f);
					if ('HistoricalPrecision' in context) _properties1 = _properties1 | ((context['HistoricalPrecision'] << 5) & 0xe0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('HistoricalValue' in context) payload.writeDWORD(context['HistoricalValue']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OperatingStatusIndication'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7c) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Dataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['HistoricalScale'] = (_properties1 & 0x1f); else return context;
				if (!payload.insufficientBytes(1)) context['HistoricalPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['HistoricalValue'] = payload.readDWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x3e METER_TBL_PUSH COMMANDS
 */

// METER_TBL_PUSH [0x3e] CONFIGURATION_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3e].command[0x01] = {
	name: "CONFIGURATION_SET",
	help: "Meter Tbl Push Configuration Set",
	param: { 
		'0x00a': {name: "PS" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "OperatingStatusPushMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "PushDataset" /* BIT_24 */ }, 
		'0x02': {name: "IntervalMonths" /* BYTE */ }, 
		'0x03': {name: "IntervalDays" /* BYTE */ }, 
		'0x04': {name: "IntervalHours" /* BYTE */ }, 
		'0x05': {name: "IntervalMinutes" /* BYTE */ }, 
		'0x06': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PS' in context || 'OperatingStatusPushMode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['PS']) _properties1 = _properties1 | 0x10;
			if ('OperatingStatusPushMode' in context) _properties1 = _properties1 | ((context['OperatingStatusPushMode']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PushDataset' in context) payload.writeBIT_24(context['PushDataset']); else return payload.asBuffer();
		if ('IntervalMonths' in context) payload.writeBYTE(context['IntervalMonths']); else return payload.asBuffer();
		if ('IntervalDays' in context) payload.writeBYTE(context['IntervalDays']); else return payload.asBuffer();
		if ('IntervalHours' in context) payload.writeBYTE(context['IntervalHours']); else return payload.asBuffer();
		if ('IntervalMinutes' in context) payload.writeBYTE(context['IntervalMinutes']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PS'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['OperatingStatusPushMode'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['PushDataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalMonths'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalDays'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalHours'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// METER_TBL_PUSH [0x3e] CONFIGURATION_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x3e].command[0x02] = {
	name: "CONFIGURATION_GET",
	help: "Meter Tbl Push Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// METER_TBL_PUSH [0x3e] CONFIGURATION_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x3e].command[0x03] = {
	name: "CONFIGURATION_REPORT",
	help: "Meter Tbl Push Configuration Report",
	param: { 
		'0x00a': {name: "PS" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "OperatingStatusPushMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "PushDataset" /* BIT_24 */ }, 
		'0x02': {name: "IntervalMonths" /* BYTE */ }, 
		'0x03': {name: "IntervalDays" /* BYTE */ }, 
		'0x04': {name: "IntervalHours" /* BYTE */ }, 
		'0x05': {name: "IntervalMinutes" /* BYTE */ }, 
		'0x06': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PS' in context || 'OperatingStatusPushMode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['PS']) _properties1 = _properties1 | 0x10;
			if ('OperatingStatusPushMode' in context) _properties1 = _properties1 | ((context['OperatingStatusPushMode']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PushDataset' in context) payload.writeBIT_24(context['PushDataset']); else return payload.asBuffer();
		if ('IntervalMonths' in context) payload.writeBYTE(context['IntervalMonths']); else return payload.asBuffer();
		if ('IntervalDays' in context) payload.writeBYTE(context['IntervalDays']); else return payload.asBuffer();
		if ('IntervalHours' in context) payload.writeBYTE(context['IntervalHours']); else return payload.asBuffer();
		if ('IntervalMinutes' in context) payload.writeBYTE(context['IntervalMinutes']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PS'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['OperatingStatusPushMode'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['PushDataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalMonths'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalDays'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalHours'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['IntervalMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x3f PREPAYMENT COMMANDS
 */

// PREPAYMENT [0x3f] BALANCE_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x3f].command[0x01] = {
	name: "BALANCE_GET",
	help: "Prepayment Balance Get",
	param: { 
		'0x00a': {name: "BalanceType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('BalanceType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('BalanceType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'BalanceType', ENUM_PREPAYMENT_BALANCE_BALANCE_TYPE) << 6) & 0xc0); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['BalanceType'] = helpers.lookupNameValue((_properties1 & 0xc0) >> 6, ENUM_PREPAYMENT_BALANCE_BALANCE_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x3f); else return context;
		}
		return context;
	}
};

const ENUM_PREPAYMENT_BALANCE_BALANCE_TYPE = {
	Utility: 0x00, 
	Monetary: 0x01, 
	enum: {
		0x00: "Utility", 
		0x01: "Monetary"
	}
};

// PREPAYMENT [0x3f] BALANCE_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x3f].command[0x02] = {
	name: "BALANCE_REPORT",
	help: "Prepayment Balance Report",
	param: { 
		'0x00a': {name: "MeterType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "BalanceType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Scale" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "BalancePrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "BalanceValue" /* DWORD */ }, 
		'0x03a': {name: "Reserved1" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "DebtPrecision" /* Properties3 STRUCT_BYTE */ }, 
		'0x04': {name: "Debt" /* DWORD */ }, 
		'0x05a': {name: "Reserved2" /* Properties4 STRUCT_BYTE */ }, 
		'0x05b': {name: "EmerCreditPrecision" /* Properties4 STRUCT_BYTE */ }, 
		'0x06': {name: "EmerCredit" /* DWORD */ }, 
		'0x07': {name: "Currency" /* BIT_24 */ }, 
		'0x08': {name: "DebtRecoveryPercentage" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MeterType' in context || 'BalanceType' in context) {
			let _properties1 = 0x00;
			if ('MeterType' in context) _properties1 = _properties1 | ((context['MeterType']) & 0x3f);
			if ('BalanceType' in context) _properties1 = _properties1 | ((context['BalanceType'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Scale' in context || 'BalancePrecision' in context) {
			let _properties2 = 0x00;
			if ('Scale' in context) _properties2 = _properties2 | ((context['Scale']) & 0x1f);
			if ('BalancePrecision' in context) _properties2 = _properties2 | ((context['BalancePrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('BalanceValue' in context) payload.writeDWORD(context['BalanceValue']); else return payload.asBuffer();
		if ('Reserved1' in context || 'DebtPrecision' in context) {
			let _properties3 = 0x00;
			if ('Reserved1' in context) _properties3 = _properties3 | ((context['Reserved1']) & 0x1f);
			if ('DebtPrecision' in context) _properties3 = _properties3 | ((context['DebtPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('Debt' in context) payload.writeDWORD(context['Debt']); else return payload.asBuffer();
		if ('Reserved2' in context || 'EmerCreditPrecision' in context) {
			let _properties4 = 0x00;
			if ('Reserved2' in context) _properties4 = _properties4 | ((context['Reserved2']) & 0x1f);
			if ('EmerCreditPrecision' in context) _properties4 = _properties4 | ((context['EmerCreditPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ('EmerCredit' in context) payload.writeDWORD(context['EmerCredit']); else return payload.asBuffer();
		if ('Currency' in context) payload.writeBIT_24(context['Currency']); else return payload.asBuffer();
		if ('DebtRecoveryPercentage' in context) payload.writeBYTE(context['DebtRecoveryPercentage']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MeterType'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['BalanceType'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['BalancePrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['BalanceValue'] = payload.readDWORD(); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties3 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['DebtPrecision'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Debt'] = payload.readDWORD(); else return context;
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties4 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['EmerCreditPrecision'] = (_properties4 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['EmerCredit'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Currency'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['DebtRecoveryPercentage'] = payload.readBYTE(); else return context;
		return context;
	}
};

// PREPAYMENT [0x3f] SUPPORTED_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x3f].command[0x03] = {
	name: "SUPPORTED_GET",
	help: "Prepayment Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// PREPAYMENT [0x3f] SUPPORTED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x3f].command[0x04] = {
	name: "SUPPORTED_REPORT",
	help: "Prepayment Supported Report",
	param: { 
		'0x00a': {name: "TypesSupported" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('TypesSupported' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('TypesSupported' in context) _properties1 = _properties1 | ((context['TypesSupported']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['TypesSupported'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x40 THERMOSTAT_MODE COMMANDS
 */

// THERMOSTAT_MODE [0x40] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x40].command[0x01] = {
	name: "SET",
	help: "Thermostat Mode Set",
	param: { 
		'0x00a': {name: "Mode" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "NoOfManufacturerDataFields" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "ManufacturerData" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'NoOfManufacturerDataFields' in context) {
			let _level = 0x00;
			if ('Mode' in context) _level = _level | ((helpers.getValue(context, 'Mode', ENUM_THERMOSTAT_MODE)) & 0x1f); 
			if ('NoOfManufacturerDataFields' in context) _level = _level | ((context['NoOfManufacturerDataFields'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('ManufacturerData' in context) payload.writeSTRING(context['ManufacturerData'], { encoding: 'hex', length: ((payload.at(0) & 0xe0) >> 5) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_level & 0x1f), ENUM_THERMOSTAT_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['NoOfManufacturerDataFields'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ManufacturerData'] = payload.readSTRING({ encoding: 'hex', length: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_MODE = {
	Off: 0x00, 
	Heat: 0x01, 
	Cool: 0x02, 
	Auto: 0x03, 
	AuxiliaryHeat: 0x04, 
	Resume: 0x05, 
	FanOnly: 0x06, 
	Furnace: 0x07, 
	DryAir: 0x08, 
	MoistAir: 0x09, 
	AutoChangeover: 0x0a, 
	EnergySaveHeat: 0x0b, 
	EnergySaveCool: 0x0c, 
	AWAY: 0x0d, 
	Reserved: 0x0e, 
	FullPower: 0x0f, 
	Reserved0: 0x10, 
	Reserved1: 0x11, 
	Reserved2: 0x12, 
	Reserved3: 0x13, 
	Reserved4: 0x14, 
	Reserved5: 0x15, 
	Reserved6: 0x16, 
	Reserved7: 0x17, 
	Reserved8: 0x18, 
	Reserved9: 0x19, 
	ReservedA: 0x1a, 
	ReservedB: 0x1b, 
	ReservedC: 0x1c, 
	ReservedD: 0x1d, 
	ReservedE: 0x1e, 
	ManufacturerSpecifc: 0x1f, 
	enum: {
		0x00: "Off", 
		0x01: "Heat", 
		0x02: "Cool", 
		0x03: "Auto", 
		0x04: "AuxiliaryHeat", 
		0x05: "Resume", 
		0x06: "FanOnly", 
		0x07: "Furnace", 
		0x08: "DryAir", 
		0x09: "MoistAir", 
		0x0a: "AutoChangeover", 
		0x0b: "EnergySaveHeat", 
		0x0c: "EnergySaveCool", 
		0x0d: "AWAY", 
		0x0e: "Reserved", 
		0x0f: "FullPower", 
		0x10: "Reserved0", 
		0x11: "Reserved1", 
		0x12: "Reserved2", 
		0x13: "Reserved3", 
		0x14: "Reserved4", 
		0x15: "Reserved5", 
		0x16: "Reserved6", 
		0x17: "Reserved7", 
		0x18: "Reserved8", 
		0x19: "Reserved9", 
		0x1a: "ReservedA", 
		0x1b: "ReservedB", 
		0x1c: "ReservedC", 
		0x1d: "ReservedD", 
		0x1e: "ReservedE", 
		0x1f: "ManufacturerSpecifc"
	}
};

// THERMOSTAT_MODE [0x40] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x40].command[0x02] = {
	name: "GET",
	help: "Thermostat Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_MODE [0x40] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x40].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Mode Report",
	param: { 
		'0x00a': {name: "Mode" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "NoOfManufacturerDataFields" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "ManufacturerData" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'NoOfManufacturerDataFields' in context) {
			let _level = 0x00;
			if ('Mode' in context) _level = _level | ((helpers.getValue(context, 'Mode', ENUM_THERMOSTAT_MODE)) & 0x1f); 
			if ('NoOfManufacturerDataFields' in context) _level = _level | ((context['NoOfManufacturerDataFields'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('ManufacturerData' in context) payload.writeSTRING(context['ManufacturerData'], { encoding: 'hex', length: ((payload.at(0) & 0xe0) >> 5) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_level & 0x1f), ENUM_THERMOSTAT_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['NoOfManufacturerDataFields'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ManufacturerData'] = payload.readSTRING({ encoding: 'hex', length: (payload.at(0) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// THERMOSTAT_MODE [0x40] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x40].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Thermostat Mode Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_MODE [0x40] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x40].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Thermostat Mode Supported Report",
	param: { 
		'0x00-0': {name: "Off" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Heat" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Cool" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "Auto" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "AuxiliaryemergencyHeat" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "Resume" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "FanOnly" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "Furnace" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "DryAir" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "MoistAir" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "AutoChangeover" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "EnergySaveHeat" /* BitMask BITMASK */ }, 
		'0x00-12': {name: "EnergySaveCool" /* BitMask BITMASK */ }, 
		'0x00-13': {name: "Away" /* BitMask BITMASK */ }, 
		'0x00-14': {name: "Reserved" /* BitMask BITMASK */ }, 
		'0x00-15': {name: "FullPower" /* BitMask BITMASK */ }, 
		'0x00-16': {name: "Reserved0" /* BitMask BITMASK */ }, 
		'0x00-17': {name: "Reserved1" /* BitMask BITMASK */ }, 
		'0x00-18': {name: "Reserved2" /* BitMask BITMASK */ }, 
		'0x00-19': {name: "Reserved3" /* BitMask BITMASK */ }, 
		'0x00-20': {name: "Reserved4" /* BitMask BITMASK */ }, 
		'0x00-21': {name: "Reserved5" /* BitMask BITMASK */ }, 
		'0x00-22': {name: "Reserved6" /* BitMask BITMASK */ }, 
		'0x00-23': {name: "Reserved7" /* BitMask BITMASK */ }, 
		'0x00-24': {name: "Reserved8" /* BitMask BITMASK */ }, 
		'0x00-25': {name: "Reserved9" /* BitMask BITMASK */ }, 
		'0x00-26': {name: "ReservedA" /* BitMask BITMASK */ }, 
		'0x00-27': {name: "ReservedB" /* BitMask BITMASK */ }, 
		'0x00-28': {name: "ReservedC" /* BitMask BITMASK */ }, 
		'0x00-29': {name: "ReservedD" /* BitMask BITMASK */ }, 
		'0x00-30': {name: "ReservedE" /* BitMask BITMASK */ }, 
		'0x00-31': {name: "ManufacturerSpecifc" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_THERMOSTAT_MODE_SUPPORTED_), {length: 32});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 32}), ENUM_THERMOSTAT_MODE_SUPPORTED_.enum);
		return context;
	}
};

const ENUM_THERMOSTAT_MODE_SUPPORTED_ = {
	Off: 0x00, 
	Heat: 0x01, 
	Cool: 0x02, 
	Auto: 0x03, 
	AuxiliaryemergencyHeat: 0x04, 
	Resume: 0x05, 
	FanOnly: 0x06, 
	Furnace: 0x07, 
	DryAir: 0x08, 
	MoistAir: 0x09, 
	AutoChangeover: 0x0a, 
	EnergySaveHeat: 0x0b, 
	EnergySaveCool: 0x0c, 
	Away: 0x0d, 
	Reserved: 0x0e, 
	FullPower: 0x0f, 
	Reserved0: 0x10, 
	Reserved1: 0x11, 
	Reserved2: 0x12, 
	Reserved3: 0x13, 
	Reserved4: 0x14, 
	Reserved5: 0x15, 
	Reserved6: 0x16, 
	Reserved7: 0x17, 
	Reserved8: 0x18, 
	Reserved9: 0x19, 
	ReservedA: 0x1a, 
	ReservedB: 0x1b, 
	ReservedC: 0x1c, 
	ReservedD: 0x1d, 
	ReservedE: 0x1e, 
	ManufacturerSpecifc: 0x1f, 
	enum: {
		0x00: "Off", 
		0x01: "Heat", 
		0x02: "Cool", 
		0x03: "Auto", 
		0x04: "AuxiliaryemergencyHeat", 
		0x05: "Resume", 
		0x06: "FanOnly", 
		0x07: "Furnace", 
		0x08: "DryAir", 
		0x09: "MoistAir", 
		0x0a: "AutoChangeover", 
		0x0b: "EnergySaveHeat", 
		0x0c: "EnergySaveCool", 
		0x0d: "Away", 
		0x0e: "Reserved", 
		0x0f: "FullPower", 
		0x10: "Reserved0", 
		0x11: "Reserved1", 
		0x12: "Reserved2", 
		0x13: "Reserved3", 
		0x14: "Reserved4", 
		0x15: "Reserved5", 
		0x16: "Reserved6", 
		0x17: "Reserved7", 
		0x18: "Reserved8", 
		0x19: "Reserved9", 
		0x1a: "ReservedA", 
		0x1b: "ReservedB", 
		0x1c: "ReservedC", 
		0x1d: "ReservedD", 
		0x1e: "ReservedE", 
		0x1f: "ManufacturerSpecifc"
	}
};



/*
 * COMMAND_CLASS 0x41 PREPAYMENT_ENCAPSULATION COMMANDS
 */

// PREPAYMENT_ENCAPSULATION [0x41] ENCAPSULATION [0x01] COMMAND 
COMMAND_CLASS.enum[0x41].command[0x01] = {
	name: "ENCAPSULATION",
	help: "Cmd Encapsulation",
	param: { 
		'0x00': {name: "Data" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Data' in context) payload.writeSTRING(context['Data'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Data'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x42 THERMOSTAT_OPERATING_STATE COMMANDS
 */

// THERMOSTAT_OPERATING_STATE [0x42] LOGGING_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x01] = {
	name: "LOGGING_SUPPORTED_GET",
	help: "Thermostat Operating State Logging Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_OPERATING_STATE [0x42] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x02] = {
	name: "GET",
	help: "Thermostat Operating State Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_OPERATING_STATE [0x42] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Operating State Report",
	param: { 
		'0x00a': {name: "OperatingState" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OperatingState' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('OperatingState' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'OperatingState', ENUM_THERMOSTAT_OPERATING_STATE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OperatingState'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_THERMOSTAT_OPERATING_STATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

const ENUM_THERMOSTAT_OPERATING_STATE = {
	Idle: 0x00, 
	Heating: 0x01, 
	Cooling: 0x02, 
	FanOnly: 0x03, 
	PendingHeat: 0x04, 
	PendingCool: 0x05, 
	VentEconomizer: 0x06, 
	AuxHeating: 0x07, 
	'2ndStageHeating': 0x08, 
	'2ndStageCooling': 0x09, 
	'2ndStageAuxHeat': 0x0a, 
	'3rdStageAuxHeat': 0x0b, 
	enum: {
		0x00: "Idle", 
		0x01: "Heating", 
		0x02: "Cooling", 
		0x03: "FanOnly", 
		0x04: "PendingHeat", 
		0x05: "PendingCool", 
		0x06: "VentEconomizer", 
		0x07: "AuxHeating", 
		0x08: "2ndStageHeating", 
		0x09: "2ndStageCooling", 
		0x0a: "2ndStageAuxHeat", 
		0x0b: "3rdStageAuxHeat"
	}
};

// THERMOSTAT_OPERATING_STATE [0x42] THERMOSTAT_OPERATING_LOGGING_SUPPORTED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x04] = {
	name: "THERMOSTAT_OPERATING_LOGGING_SUPPORTED_REPORT",
	help: "Thermostat Operating State Logging Supported Report",
	param: { 
		'0x00-0': {name: "Idle" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Heating" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Cooling" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "FanOnly" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "PendingHeat" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "PendingCool" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "VentEconomizer" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "AuxHeating" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "2ndStageHeating" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "2ndStageCooling" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "2ndStageAuxHeat" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "3rdStageAuxHeat" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_THERMOSTAT_OPERATING_STATE), {length: 12});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 12}), ENUM_THERMOSTAT_OPERATING_STATE.enum);
		return context;
	}
};

// THERMOSTAT_OPERATING_STATE [0x42] LOGGING_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x05] = {
	name: "LOGGING_GET",
	help: "Thermostat Operating State Logging Get",
	param: { 
		'0x00-0': {name: "Idle" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Heating" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Cooling" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "FanOnly" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "PendingHeat" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "PendingCool" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "VentEconomizer" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "AuxHeating" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "2ndStageHeating" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "2ndStageCooling" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "2ndStageAuxHeat" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "3rdStageAuxHeat" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_THERMOSTAT_OPERATING_STATE), {length: 12});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 12}), ENUM_THERMOSTAT_OPERATING_STATE.enum);
		return context;
	}
};

// THERMOSTAT_OPERATING_STATE [0x42] LOGGING_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x42].command[0x06] = {
	name: "LOGGING_REPORT",
	help: "Thermostat Operating State Logging Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00a': {name: "OperatingStateLogType" /* Properties1 STRUCT_BYTE */ },
				'0x01-0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ },
				'0x01-0x01': {name: "UsageTodayhours" /* BYTE */ },
				'0x01-0x02': {name: "UsageTodayminutes" /* BYTE */ },
				'0x01-0x03': {name: "UsageYesterdayhours" /* BYTE */ },
				'0x01-0x04': {name: "UsageYesterdayminutes" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('OperatingStateLogType' in context || 'Reserved' in context) {
					let _properties1 = 0x00;
					if ('OperatingStateLogType' in context) _properties1 = _properties1 | ((context['OperatingStateLogType']) & 0x0f);
					if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('UsageTodayhours' in context) payload.writeBYTE(context['UsageTodayhours']); else return payload.asBuffer();
				if ('UsageTodayminutes' in context) payload.writeBYTE(context['UsageTodayminutes']); else return payload.asBuffer();
				if ('UsageYesterdayhours' in context) payload.writeBYTE(context['UsageYesterdayhours']); else return payload.asBuffer();
				if ('UsageYesterdayminutes' in context) payload.writeBYTE(context['UsageYesterdayminutes']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['OperatingStateLogType'] = (_properties1 & 0x0f); else return context;
				if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
			}
			if (!payload.insufficientBytes(1)) context['UsageTodayhours'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['UsageTodayminutes'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['UsageYesterdayhours'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['UsageYesterdayminutes'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x43 THERMOSTAT_SETPOINT COMMANDS
 */

// THERMOSTAT_SETPOINT [0x43] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x01] = {
	name: "SET",
	help: "Thermostat Setpoint Set",
	param: { 
		'0x00a': {name: "SetpointType" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01a': {name: "Size" /* Level2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Level2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Level2 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('SetpointType' in context) _level = _level | ((helpers.getValue(context, 'SetpointType', ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _level2 = 0x00;
			if ('Size' in context) _level2 = _level2 | ((context['Size']) & 0x07);
			if ('Scale' in context) _level2 = _level2 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _level2 = _level2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_level & 0x0f), ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf0) >> 4; else return context;
		}
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_level2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_level2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_level2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE = {
	NotSupported: 0x00, 
	Heating1: 0x01, 
	Cooling1: 0x02, 
	NotSupported1: 0x03, 
	NotSupported2: 0x04, 
	NotSupported3: 0x05, 
	NotSupported4: 0x06, 
	Furnace: 0x07, 
	DryAir: 0x08, 
	MoistAir: 0x09, 
	AutoChangeover: 0x0a, 
	EnergySaveHeating: 0x0b, 
	EnergySaveCooling: 0x0c, 
	AwayHeating: 0x0d, 
	AwayCooling: 0x0e, 
	FullPower: 0x0f, 
	enum: {
		0x00: "NotSupported", 
		0x01: "Heating1", 
		0x02: "Cooling1", 
		0x03: "NotSupported1", 
		0x04: "NotSupported2", 
		0x05: "NotSupported3", 
		0x06: "NotSupported4", 
		0x07: "Furnace", 
		0x08: "DryAir", 
		0x09: "MoistAir", 
		0x0a: "AutoChangeover", 
		0x0b: "EnergySaveHeating", 
		0x0c: "EnergySaveCooling", 
		0x0d: "AwayHeating", 
		0x0e: "AwayCooling", 
		0x0f: "FullPower"
	}
};

// THERMOSTAT_SETPOINT [0x43] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x02] = {
	name: "GET",
	help: "Thermostat Setpoint Get",
	param: { 
		'0x00a': {name: "SetpointType" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointType' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('SetpointType' in context) _level = _level | ((helpers.getValue(context, 'SetpointType', ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_level & 0x0f), ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// THERMOSTAT_SETPOINT [0x43] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Setpoint Report",
	param: { 
		'0x00a': {name: "SetpointType" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01a': {name: "Size" /* Level2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Level2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Level2 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('SetpointType' in context) _level = _level | ((helpers.getValue(context, 'SetpointType', ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _level2 = 0x00;
			if ('Size' in context) _level2 = _level2 | ((context['Size']) & 0x07);
			if ('Scale' in context) _level2 = _level2 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _level2 = _level2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_level & 0x0f), ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf0) >> 4; else return context;
		}
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_level2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_level2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_level2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// THERMOSTAT_SETPOINT [0x43] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Thermostat Setpoint Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_SETPOINT [0x43] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Thermostat Setpoint Supported Report",
	param: { 
		'0x00-0': {name: "None" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Heating" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Cooling" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "Furnace" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "DryAir" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "MoistAir" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "AutoChangeover" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "EnergySaveHeating" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "EnergySaveCooling" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "AwayHeating" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "AwayCooling" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "FullPower" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_THERMOSTAT_SETPOINT_SUPPORTED_), {length: 12});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 12}), ENUM_THERMOSTAT_SETPOINT_SUPPORTED_.enum);
		return context;
	}
};

const ENUM_THERMOSTAT_SETPOINT_SUPPORTED_ = {
	None: 0x00, 
	Heating: 0x01, 
	Cooling: 0x02, 
	Furnace: 0x07, 
	DryAir: 0x08, 
	MoistAir: 0x09, 
	AutoChangeover: 0x0a, 
	EnergySaveHeating: 0x0b, 
	EnergySaveCooling: 0x0c, 
	AwayHeating: 0x0d, 
	AwayCooling: 0x0e, 
	FullPower: 0x0f, 
	enum: {
		0x00: "None", 
		0x01: "Heating", 
		0x02: "Cooling", 
		0x07: "Furnace", 
		0x08: "DryAir", 
		0x09: "MoistAir", 
		0x0a: "AutoChangeover", 
		0x0b: "EnergySaveHeating", 
		0x0c: "EnergySaveCooling", 
		0x0d: "AwayHeating", 
		0x0e: "AwayCooling", 
		0x0f: "FullPower"
	}
};

// THERMOSTAT_SETPOINT [0x43] CAPABILITIES_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x09] = {
	name: "CAPABILITIES_GET",
	help: "Thermostat Setpoint Capabilities Get",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// THERMOSTAT_SETPOINT [0x43] CAPABILITIES_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x43].command[0x0a] = {
	name: "CAPABILITIES_REPORT",
	help: "Thermostat Setpoint Capabilities Report",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Size1" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale1" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision1" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "MinValue" /* VARIANT */ }, 
		'0x03a': {name: "Size2" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "Scale2" /* Properties3 STRUCT_BYTE */ }, 
		'0x03c': {name: "Precision2" /* Properties3 STRUCT_BYTE */ }, 
		'0x04': {name: "MaxValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('MinValue' in context) && !(('Precision1' in context) && ('Size1' in context))) helpers.updateFLOATINGSizePrecision(context, 'MinValue', 'Precision1', 'Size1');
		if (('MaxValue' in context) && !(('Precision2' in context) && ('Size2' in context))) helpers.updateFLOATINGSizePrecision(context, 'MaxValue', 'Precision2', 'Size2');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Size1' in context || 'Scale1' in context || 'Precision1' in context) {
			let _properties2 = 0x00;
			if ('Size1' in context) _properties2 = _properties2 | ((context['Size1']) & 0x07);
			if ('Scale1' in context) _properties2 = _properties2 | ((context['Scale1'] << 3) & 0x18);
			if ('Precision1' in context) _properties2 = _properties2 | ((context['Precision1'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MinValue' in context) payload.writeFLOATING(context['MinValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Size2' in context || 'Scale2' in context || 'Precision2' in context) {
			let _properties3 = 0x00;
			if ('Size2' in context) _properties3 = _properties3 | ((context['Size2']) & 0x07);
			if ('Scale2' in context) _properties3 = _properties3 | ((context['Scale2'] << 3) & 0x18);
			if ('Precision2' in context) _properties3 = _properties3 | ((context['Precision2'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('MaxValue' in context) payload.writeFLOATING(context['MaxValue'], {size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size1'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale1'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision1'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size2'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale2'] = (_properties3 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision2'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaxValue'] = payload.readFLOATING({size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x44 THERMOSTAT_FAN_MODE COMMANDS
 */

// THERMOSTAT_FAN_MODE [0x44] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x44].command[0x01] = {
	name: "SET",
	help: "Thermostat Fan Mode Set",
	param: { 
		'0x00a': {name: "FanMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Off" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('FanMode' in context || 'Off' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('FanMode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'FanMode', ENUM_THERMOSTAT_FAN_MODE)) & 0x0f); 
			if (context['Off']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0x70);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FanMode'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_THERMOSTAT_FAN_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Off'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x70) >> 4; else return context;
		}
		return context;
	}
};

const ENUM_THERMOSTAT_FAN_MODE = {
	AutoLow: 0x00, 
	Low: 0x01, 
	AutoHigh: 0x02, 
	High: 0x03, 
	AutoMedium: 0x04, 
	Medium: 0x05, 
	Circulation: 0x06, 
	Humidity: 0x07, 
	LeftRight: 0x08, 
	UpDown: 0x09, 
	Quiet: 0x0a, 
	ReservedB: 0x0b, 
	ReservedC: 0x0c, 
	ReservedD: 0x0d, 
	ReservedE: 0x0e, 
	ReservedF: 0x0f, 
	enum: {
		0x00: "AutoLow", 
		0x01: "Low", 
		0x02: "AutoHigh", 
		0x03: "High", 
		0x04: "AutoMedium", 
		0x05: "Medium", 
		0x06: "Circulation", 
		0x07: "Humidity", 
		0x08: "LeftRight", 
		0x09: "UpDown", 
		0x0a: "Quiet", 
		0x0b: "ReservedB", 
		0x0c: "ReservedC", 
		0x0d: "ReservedD", 
		0x0e: "ReservedE", 
		0x0f: "ReservedF"
	}
};

// THERMOSTAT_FAN_MODE [0x44] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x44].command[0x02] = {
	name: "GET",
	help: "Thermostat Fan Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_FAN_MODE [0x44] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x44].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Fan Mode Report",
	param: { 
		'0x00a': {name: "FanMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Off" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('FanMode' in context || 'Off' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('FanMode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'FanMode', ENUM_THERMOSTAT_FAN_MODE)) & 0x0f); 
			if (context['Off']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0x70);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FanMode'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_THERMOSTAT_FAN_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Off'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x70) >> 4; else return context;
		}
		return context;
	}
};

// THERMOSTAT_FAN_MODE [0x44] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x44].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Thermostat Fan Mode Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_FAN_MODE [0x44] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x44].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Thermostat Fan Mode Supported Report",
	param: { 
		'0x00-0': {name: "Auto" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Low" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "AutoHigh" /* BitMask BITMASK */ }, 
		'0x00-3': {name: "High" /* BitMask BITMASK */ }, 
		'0x00-4': {name: "AutoMedium" /* BitMask BITMASK */ }, 
		'0x00-5': {name: "Medium" /* BitMask BITMASK */ }, 
		'0x00-6': {name: "Circulation" /* BitMask BITMASK */ }, 
		'0x00-7': {name: "HumidityCirculation" /* BitMask BITMASK */ }, 
		'0x00-8': {name: "LeftRight" /* BitMask BITMASK */ }, 
		'0x00-9': {name: "UpDown" /* BitMask BITMASK */ }, 
		'0x00-10': {name: "Quiet" /* BitMask BITMASK */ }, 
		'0x00-11': {name: "ReservedB" /* BitMask BITMASK */ }, 
		'0x00-12': {name: "ReservedC" /* BitMask BITMASK */ }, 
		'0x00-13': {name: "ReservedD" /* BitMask BITMASK */ }, 
		'0x00-14': {name: "ReservedE" /* BitMask BITMASK */ }, 
		'0x00-15': {name: "ReservedF" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_THERMOSTAT_FAN_MODE_SUPPORTED_), {length: 16});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 16}), ENUM_THERMOSTAT_FAN_MODE_SUPPORTED_.enum);
		return context;
	}
};

const ENUM_THERMOSTAT_FAN_MODE_SUPPORTED_ = {
	Auto: 0x00, 
	Low: 0x01, 
	AutoHigh: 0x02, 
	High: 0x03, 
	AutoMedium: 0x04, 
	Medium: 0x05, 
	Circulation: 0x06, 
	HumidityCirculation: 0x07, 
	LeftRight: 0x08, 
	UpDown: 0x09, 
	Quiet: 0x0a, 
	ReservedB: 0x0b, 
	ReservedC: 0x0c, 
	ReservedD: 0x0d, 
	ReservedE: 0x0e, 
	ReservedF: 0x0f, 
	enum: {
		0x00: "Auto", 
		0x01: "Low", 
		0x02: "AutoHigh", 
		0x03: "High", 
		0x04: "AutoMedium", 
		0x05: "Medium", 
		0x06: "Circulation", 
		0x07: "HumidityCirculation", 
		0x08: "LeftRight", 
		0x09: "UpDown", 
		0x0a: "Quiet", 
		0x0b: "ReservedB", 
		0x0c: "ReservedC", 
		0x0d: "ReservedD", 
		0x0e: "ReservedE", 
		0x0f: "ReservedF"
	}
};



/*
 * COMMAND_CLASS 0x45 THERMOSTAT_FAN_STATE COMMANDS
 */

// THERMOSTAT_FAN_STATE [0x45] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x45].command[0x02] = {
	name: "GET",
	help: "Thermostat Fan State Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_FAN_STATE [0x45] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x45].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Fan State Report",
	param: { 
		'0x00a': {name: "FanOperatingState" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('FanOperatingState' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('FanOperatingState' in context) _level = _level | ((helpers.getValue(context, 'FanOperatingState', ENUM_THERMOSTAT_FAN_STATE_FAN_OPERATING_STATE)) & 0x0f); 
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FanOperatingState'] = helpers.lookupNameValue((_level & 0x0f), ENUM_THERMOSTAT_FAN_STATE_FAN_OPERATING_STATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

const ENUM_THERMOSTAT_FAN_STATE_FAN_OPERATING_STATE = {
	Idle: 0x00, 
	Running: 0x01, 
	RunningHigh: 0x02, 
	RunningMedium: 0x03, 
	Circulation: 0x04, 
	HumidityCirculation: 0x05, 
	RightleftCirculation: 0x06, 
	UpdownCirculation: 0x07, 
	QuietCirculation: 0x08, 
	enum: {
		0x00: "Idle", 
		0x01: "Running", 
		0x02: "RunningHigh", 
		0x03: "RunningMedium", 
		0x04: "Circulation", 
		0x05: "HumidityCirculation", 
		0x06: "RightleftCirculation", 
		0x07: "UpdownCirculation", 
		0x08: "QuietCirculation"
	}
};



/*
 * COMMAND_CLASS 0x46 CLIMATE_CONTROL_SCHEDULE COMMANDS
 */

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x01] = {
	name: "SCHEDULE_SET",
	help: "Schedule Set",
	param: { 
		'0x00a': {name: "Weekday" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Switchpoint0" /* BIT_24 */ }, 
		'0x02': {name: "Switchpoint1" /* BIT_24 */ }, 
		'0x03': {name: "Switchpoint2" /* BIT_24 */ }, 
		'0x04': {name: "Switchpoint3" /* BIT_24 */ }, 
		'0x05': {name: "Switchpoint4" /* BIT_24 */ }, 
		'0x06': {name: "Switchpoint5" /* BIT_24 */ }, 
		'0x07': {name: "Switchpoint6" /* BIT_24 */ }, 
		'0x08': {name: "Switchpoint7" /* BIT_24 */ }, 
		'0x09': {name: "Switchpoint8" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Weekday' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Weekday' in context) _properties1 = _properties1 | ((context['Weekday']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Switchpoint0' in context) payload.writeBIT_24(context['Switchpoint0']); else return payload.asBuffer();
		if ('Switchpoint1' in context) payload.writeBIT_24(context['Switchpoint1']); else return payload.asBuffer();
		if ('Switchpoint2' in context) payload.writeBIT_24(context['Switchpoint2']); else return payload.asBuffer();
		if ('Switchpoint3' in context) payload.writeBIT_24(context['Switchpoint3']); else return payload.asBuffer();
		if ('Switchpoint4' in context) payload.writeBIT_24(context['Switchpoint4']); else return payload.asBuffer();
		if ('Switchpoint5' in context) payload.writeBIT_24(context['Switchpoint5']); else return payload.asBuffer();
		if ('Switchpoint6' in context) payload.writeBIT_24(context['Switchpoint6']); else return payload.asBuffer();
		if ('Switchpoint7' in context) payload.writeBIT_24(context['Switchpoint7']); else return payload.asBuffer();
		if ('Switchpoint8' in context) payload.writeBIT_24(context['Switchpoint8']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Weekday'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Switchpoint0'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint1'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint2'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint3'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint4'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint5'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint6'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint7'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint8'] = payload.readBIT_24(); else return context;
		return context;
	}
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x02] = {
	name: "SCHEDULE_GET",
	help: "Schedule Get",
	param: { 
		'0x00a': {name: "Weekday" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Weekday' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Weekday' in context) _properties1 = _properties1 | ((context['Weekday']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Weekday'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		return context;
	}
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x03] = {
	name: "SCHEDULE_REPORT",
	help: "Schedule Report",
	param: { 
		'0x00a': {name: "Weekday" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Switchpoint0" /* BIT_24 */ }, 
		'0x02': {name: "Switchpoint1" /* BIT_24 */ }, 
		'0x03': {name: "Switchpoint2" /* BIT_24 */ }, 
		'0x04': {name: "Switchpoint3" /* BIT_24 */ }, 
		'0x05': {name: "Switchpoint4" /* BIT_24 */ }, 
		'0x06': {name: "Switchpoint5" /* BIT_24 */ }, 
		'0x07': {name: "Switchpoint6" /* BIT_24 */ }, 
		'0x08': {name: "Switchpoint7" /* BIT_24 */ }, 
		'0x09': {name: "Switchpoint8" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Weekday' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Weekday' in context) _properties1 = _properties1 | ((context['Weekday']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Switchpoint0' in context) payload.writeBIT_24(context['Switchpoint0']); else return payload.asBuffer();
		if ('Switchpoint1' in context) payload.writeBIT_24(context['Switchpoint1']); else return payload.asBuffer();
		if ('Switchpoint2' in context) payload.writeBIT_24(context['Switchpoint2']); else return payload.asBuffer();
		if ('Switchpoint3' in context) payload.writeBIT_24(context['Switchpoint3']); else return payload.asBuffer();
		if ('Switchpoint4' in context) payload.writeBIT_24(context['Switchpoint4']); else return payload.asBuffer();
		if ('Switchpoint5' in context) payload.writeBIT_24(context['Switchpoint5']); else return payload.asBuffer();
		if ('Switchpoint6' in context) payload.writeBIT_24(context['Switchpoint6']); else return payload.asBuffer();
		if ('Switchpoint7' in context) payload.writeBIT_24(context['Switchpoint7']); else return payload.asBuffer();
		if ('Switchpoint8' in context) payload.writeBIT_24(context['Switchpoint8']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Weekday'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Switchpoint0'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint1'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint2'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint3'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint4'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint5'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint6'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint7'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Switchpoint8'] = payload.readBIT_24(); else return context;
		return context;
	}
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_CHANGED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x04] = {
	name: "SCHEDULE_CHANGED_GET",
	help: "Schedule Changed Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_CHANGED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x05] = {
	name: "SCHEDULE_CHANGED_REPORT",
	help: "Schedule Changed Report",
	param: { 
		'0x00': {name: "ChangeCounter" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ChangeCounter' in context) payload.writeBYTE(context['ChangeCounter']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ChangeCounter'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_OVERRIDE_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x06] = {
	name: "SCHEDULE_OVERRIDE_SET",
	help: "Schedule Override Set",
	param: { 
		'0x00a': {name: "OverrideType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "OverrideState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OverrideType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('OverrideType' in context) _properties1 = _properties1 | ((context['OverrideType']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('OverrideState' in context) payload.writeBYTE(helpers.getValue(context, 'OverrideState', ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OverrideType'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['OverrideState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE.enum); else return context;
		return context;
	}
};

const ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE = {
	NoOverride: 0x00, 
	TemporaryOverride: 0x01, 
	PermanentOverride: 0x02, 
	Reserved: 0x03, 
	enum: {
		0x00: "NoOverride", 
		0x01: "TemporaryOverride", 
		0x02: "PermanentOverride", 
		0x03: "Reserved"
	}
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_OVERRIDE_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x07] = {
	name: "SCHEDULE_OVERRIDE_GET",
	help: "Schedule Override Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CLIMATE_CONTROL_SCHEDULE [0x46] SCHEDULE_OVERRIDE_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x46].command[0x08] = {
	name: "SCHEDULE_OVERRIDE_REPORT",
	help: "Schedule Override Report",
	param: { 
		'0x00a': {name: "OverrideType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "OverrideState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OverrideType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('OverrideType' in context) _properties1 = _properties1 | ((context['OverrideType']) & 0x03);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('OverrideState' in context) payload.writeBYTE(helpers.getValue(context, 'OverrideState', ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OverrideType'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['OverrideState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x47 THERMOSTAT_SETBACK COMMANDS
 */

// THERMOSTAT_SETBACK [0x47] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x47].command[0x01] = {
	name: "SET",
	help: "Thermostat Setback Set",
	param: { 
		'0x00a': {name: "SetbackType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "SetbackState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetbackType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetbackType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetbackType', ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE)) & 0x03); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SetbackState' in context) payload.writeBYTE(helpers.getValue(context, 'SetbackState', ENUM_THERMOSTAT_SETBACK_SETBACK_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetbackType'] = helpers.lookupNameValue((_properties1 & 0x03), ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SetbackState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_SETBACK_SETBACK_STATE.enum); else return context;
		return context;
	}
};

const ENUM_THERMOSTAT_SETBACK_SETBACK_STATE = {
	FrostProtection: 0x79, 
	EnergySavingMode: 0x7a, 
	Reserved: 0x7b, 
	Reserved: 0x7c, 
	Reserved: 0x7d, 
	Reserved: 0x7e, 
	UnusedState: 0x7f, 
	enum: {
		0x79: "FrostProtection", 
		0x7a: "EnergySavingMode", 
		0x7b: "Reserved", 
		0x7c: "Reserved", 
		0x7d: "Reserved", 
		0x7e: "Reserved", 
		0x7f: "UnusedState"
	}
};

// THERMOSTAT_SETBACK [0x47] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x47].command[0x02] = {
	name: "GET",
	help: "Thermostat Setback Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// THERMOSTAT_SETBACK [0x47] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x47].command[0x03] = {
	name: "REPORT",
	help: "Thermostat Setback Report",
	param: { 
		'0x00a': {name: "SetbackType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "SetbackState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetbackType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetbackType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetbackType', ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE)) & 0x03); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SetbackState' in context) payload.writeBYTE(helpers.getValue(context, 'SetbackState', ENUM_THERMOSTAT_SETBACK_SETBACK_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetbackType'] = helpers.lookupNameValue((_properties1 & 0x03), ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SetbackState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_THERMOSTAT_SETBACK_SETBACK_STATE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x48 RATE_TBL_CONFIG COMMANDS
 */

// RATE_TBL_CONFIG [0x48] RATE_TBL_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x48].command[0x01] = {
	name: "RATE_TBL_SET",
	help: "Rate Tbl Set",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "NumberOfRateChar" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "RateCharacter" /* VARIANT */ }, 
		'0x03': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x04': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "DurationMinute" /* WORD */ }, 
		'0x06a': {name: "ConsumptionScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "ConsumptionPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "MinConsumptionValue" /* DWORD */ }, 
		'0x08': {name: "MaxConsumptionValue" /* DWORD */ }, 
		'0x09a': {name: "MaxDemandScale" /* Properties3 STRUCT_BYTE */ }, 
		'0x09b': {name: "MaxDemandPrecision" /* Properties3 STRUCT_BYTE */ }, 
		'0x0a': {name: "MaxDemandValue" /* DWORD */ }, 
		'0x0b': {name: "DcpRateId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Reserved' in context || 'NumberOfRateChar' in context || 'RateType' in context) {
			let _properties1 = 0x00;
			if (context['Reserved']) _properties1 = _properties1 | 0x80;
			if ('NumberOfRateChar' in context) _properties1 = _properties1 | ((context['NumberOfRateChar']) & 0x1f);
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType'] << 5) & 0x60);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RateCharacter' in context) payload.writeSTRING(context['RateCharacter'], { encoding: 'hex', length: (payload.at(1) & 0x1f) }); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('DurationMinute' in context) payload.writeWORD(context['DurationMinute']); else return payload.asBuffer();
		if ('ConsumptionScale' in context || 'ConsumptionPrecision' in context) {
			let _properties2 = 0x00;
			if ('ConsumptionScale' in context) _properties2 = _properties2 | ((context['ConsumptionScale']) & 0x1f);
			if ('ConsumptionPrecision' in context) _properties2 = _properties2 | ((context['ConsumptionPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MinConsumptionValue' in context) payload.writeDWORD(context['MinConsumptionValue']); else return payload.asBuffer();
		if ('MaxConsumptionValue' in context) payload.writeDWORD(context['MaxConsumptionValue']); else return payload.asBuffer();
		if ('MaxDemandScale' in context || 'MaxDemandPrecision' in context) {
			let _properties3 = 0x00;
			if ('MaxDemandScale' in context) _properties3 = _properties3 | ((context['MaxDemandScale']) & 0x1f);
			if ('MaxDemandPrecision' in context) _properties3 = _properties3 | ((context['MaxDemandPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('MaxDemandValue' in context) payload.writeDWORD(context['MaxDemandValue']); else return payload.asBuffer();
		if ('DcpRateId' in context) payload.writeBYTE(context['DcpRateId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfRateChar'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0x60) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['RateCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(1) & 0x1f }); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinute'] = payload.readWORD(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ConsumptionScale'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['ConsumptionPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinConsumptionValue'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxConsumptionValue'] = payload.readDWORD(); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MaxDemandScale'] = (_properties3 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['MaxDemandPrecision'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaxDemandValue'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DcpRateId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// RATE_TBL_CONFIG [0x48] RATE_TBL_REMOVE [0x02] COMMAND 
COMMAND_CLASS.enum[0x48].command[0x02] = {
	name: "RATE_TBL_REMOVE",
	help: "Rate Tbl Remove",
	param: { 
		'0x00a': {name: "RateParameterSetIds" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "RateParameterSetId" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetIds' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('RateParameterSetIds' in context) _properties1 = _properties1 | ((context['RateParameterSetIds']) & 0x3f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RateParameterSetId' in context) payload.writeSTRING(context['RateParameterSetId'], { encoding: 'hex', length: (payload.at(0) & 0x3f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RateParameterSetIds'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x3f }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x49 RATE_TBL_MONITOR COMMANDS
 */

// RATE_TBL_MONITOR [0x49] RATE_TBL_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x01] = {
	name: "RATE_TBL_SUPPORTED_GET",
	help: "Rate Tbl Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x02] = {
	name: "RATE_TBL_SUPPORTED_REPORT",
	help: "Rate Tbl Supported Report",
	param: { 
		'0x00': {name: "RatesSupported" /* BYTE */ }, 
		'0x01': {name: "ParameterSetSupportedBitMask" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RatesSupported' in context) payload.writeBYTE(context['RatesSupported']); else return payload.asBuffer();
		if ('ParameterSetSupportedBitMask' in context) payload.writeWORD(context['ParameterSetSupportedBitMask']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RatesSupported'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ParameterSetSupportedBitMask'] = payload.readWORD(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x03] = {
	name: "RATE_TBL_GET",
	help: "Rate Tbl Get",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x04] = {
	name: "RATE_TBL_REPORT",
	help: "Rate Tbl Report",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "NumberOfRateChar" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "RateCharacter" /* VARIANT */ }, 
		'0x03': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x04': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "DurationMinute" /* WORD */ }, 
		'0x06a': {name: "ConsumptionScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "ConsumptionPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "MinConsumptionValue" /* DWORD */ }, 
		'0x08': {name: "MaxConsumptionValue" /* DWORD */ }, 
		'0x09a': {name: "MaxDemandScale" /* Properties3 STRUCT_BYTE */ }, 
		'0x09b': {name: "MaxDemandPrecision" /* Properties3 STRUCT_BYTE */ }, 
		'0x0a': {name: "MaxDemandValue" /* DWORD */ }, 
		'0x0b': {name: "DcpRateId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Reserved' in context || 'NumberOfRateChar' in context || 'RateType' in context) {
			let _properties1 = 0x00;
			if (context['Reserved']) _properties1 = _properties1 | 0x80;
			if ('NumberOfRateChar' in context) _properties1 = _properties1 | ((context['NumberOfRateChar']) & 0x1f);
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType'] << 5) & 0x60);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RateCharacter' in context) payload.writeSTRING(context['RateCharacter'], { encoding: 'hex', length: (payload.at(1) & 0x1f) }); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('DurationMinute' in context) payload.writeWORD(context['DurationMinute']); else return payload.asBuffer();
		if ('ConsumptionScale' in context || 'ConsumptionPrecision' in context) {
			let _properties2 = 0x00;
			if ('ConsumptionScale' in context) _properties2 = _properties2 | ((context['ConsumptionScale']) & 0x1f);
			if ('ConsumptionPrecision' in context) _properties2 = _properties2 | ((context['ConsumptionPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MinConsumptionValue' in context) payload.writeDWORD(context['MinConsumptionValue']); else return payload.asBuffer();
		if ('MaxConsumptionValue' in context) payload.writeDWORD(context['MaxConsumptionValue']); else return payload.asBuffer();
		if ('MaxDemandScale' in context || 'MaxDemandPrecision' in context) {
			let _properties3 = 0x00;
			if ('MaxDemandScale' in context) _properties3 = _properties3 | ((context['MaxDemandScale']) & 0x1f);
			if ('MaxDemandPrecision' in context) _properties3 = _properties3 | ((context['MaxDemandPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('MaxDemandValue' in context) payload.writeDWORD(context['MaxDemandValue']); else return payload.asBuffer();
		if ('DcpRateId' in context) payload.writeBYTE(context['DcpRateId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfRateChar'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0x60) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['RateCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(1) & 0x1f }); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinute'] = payload.readWORD(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ConsumptionScale'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['ConsumptionPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinConsumptionValue'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxConsumptionValue'] = payload.readDWORD(); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MaxDemandScale'] = (_properties3 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['MaxDemandPrecision'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaxDemandValue'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DcpRateId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_ACTIVE_RATE_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x05] = {
	name: "RATE_TBL_ACTIVE_RATE_GET",
	help: "Rate Tbl Active Rate  Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_ACTIVE_RATE_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x06] = {
	name: "RATE_TBL_ACTIVE_RATE_REPORT",
	help: "Rate Tbl Active Rate  Report",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_CURRENT_DATA_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x07] = {
	name: "RATE_TBL_CURRENT_DATA_GET",
	help: "Rate Tbl Current Data Get",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01': {name: "DatasetRequested" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('DatasetRequested' in context) payload.writeBIT_24(context['DatasetRequested']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DatasetRequested'] = payload.readBIT_24(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_CURRENT_DATA_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x08] = {
	name: "RATE_TBL_CURRENT_DATA_REPORT",
	help: "Rate Tbl Current Data Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x02': {name: "Dataset" /* BIT_24 */ }, 
		'0x03': {name: "Year" /* WORD */ }, 
		'0x04': {name: "Month" /* BYTE */ }, 
		'0x05': {name: "Day" /* BYTE */ }, 
		'0x06': {name: "HourLocalTime" /* BYTE */ }, 
		'0x07': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x08': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x09': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x09-0x00a': {name: "CurrentScale" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x00b': {name: "CurrentPrecision" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x01': {name: "CurrentValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Dataset' in context) payload.writeBIT_24(context['Dataset']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('CurrentScale' in context || 'CurrentPrecision' in context) {
					let _properties1 = 0x00;
					if ('CurrentScale' in context) _properties1 = _properties1 | ((context['CurrentScale']) & 0x1f);
					if ('CurrentPrecision' in context) _properties1 = _properties1 | ((context['CurrentPrecision'] << 5) & 0xe0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('CurrentValue' in context) payload.writeDWORD(context['CurrentValue']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Dataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['CurrentScale'] = (_properties1 & 0x1f); else return context;
				if (!payload.insufficientBytes(1)) context['CurrentPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['CurrentValue'] = payload.readDWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_HISTORICAL_DATA_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x09] = {
	name: "RATE_TBL_HISTORICAL_DATA_GET",
	help: "Rate Tbl Historical Data Get",
	param: { 
		'0x00': {name: "MaximumReports" /* BYTE */ }, 
		'0x01': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x02': {name: "DatasetRequested" /* BIT_24 */ }, 
		'0x03': {name: "StartYear" /* WORD */ }, 
		'0x04': {name: "StartMonth" /* BYTE */ }, 
		'0x05': {name: "StartDay" /* BYTE */ }, 
		'0x06': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x07': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x08': {name: "StartSecondLocalTime" /* BYTE */ }, 
		'0x09': {name: "StopYear" /* WORD */ }, 
		'0x0a': {name: "StopMonth" /* BYTE */ }, 
		'0x0b': {name: "StopDay" /* BYTE */ }, 
		'0x0c': {name: "StopHourLocalTime" /* BYTE */ }, 
		'0x0d': {name: "StopMinuteLocalTime" /* BYTE */ }, 
		'0x0e': {name: "StopSecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MaximumReports' in context) payload.writeBYTE(context['MaximumReports']); else return payload.asBuffer();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('DatasetRequested' in context) payload.writeBIT_24(context['DatasetRequested']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StartSecondLocalTime' in context) payload.writeBYTE(context['StartSecondLocalTime']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeWORD(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHourLocalTime' in context) payload.writeBYTE(context['StopHourLocalTime']); else return payload.asBuffer();
		if ('StopMinuteLocalTime' in context) payload.writeBYTE(context['StopMinuteLocalTime']); else return payload.asBuffer();
		if ('StopSecondLocalTime' in context) payload.writeBYTE(context['StopSecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MaximumReports'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DatasetRequested'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartSecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopSecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// RATE_TBL_MONITOR [0x49] RATE_TBL_HISTORICAL_DATA_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x49].command[0x0a] = {
	name: "RATE_TBL_HISTORICAL_DATA_REPORT",
	help: "Rate Tbl Historical Data Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x02': {name: "Dataset" /* BIT_24 */ }, 
		'0x03': {name: "Year" /* WORD */ }, 
		'0x04': {name: "Month" /* BYTE */ }, 
		'0x05': {name: "Day" /* BYTE */ }, 
		'0x06': {name: "HourLocalTime" /* BYTE */ }, 
		'0x07': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x08': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x09': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x09-0x00a': {name: "HistoricalScale" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x00b': {name: "HistoricalPrecision" /* Properties1 STRUCT_BYTE */ },
				'0x09-0x01': {name: "HistoricalValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Dataset' in context) payload.writeBIT_24(context['Dataset']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('HistoricalScale' in context || 'HistoricalPrecision' in context) {
					let _properties1 = 0x00;
					if ('HistoricalScale' in context) _properties1 = _properties1 | ((context['HistoricalScale']) & 0x1f);
					if ('HistoricalPrecision' in context) _properties1 = _properties1 | ((context['HistoricalPrecision'] << 5) & 0xe0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('HistoricalValue' in context) payload.writeDWORD(context['HistoricalValue']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Dataset'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['HistoricalScale'] = (_properties1 & 0x1f); else return context;
				if (!payload.insufficientBytes(1)) context['HistoricalPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['HistoricalValue'] = payload.readDWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4a TARIFF_CONFIG COMMANDS
 */

// TARIFF_CONFIG [0x4a] TARIFF_TBL_SUPPLIER_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x4a].command[0x01] = {
	name: "TARIFF_TBL_SUPPLIER_SET",
	help: "Tariff Tbl Supplier Set",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x06': {name: "Currency" /* BIT_24 */ }, 
		'0x07a': {name: "StandingChargePeriod" /* Properties1 STRUCT_BYTE */ }, 
		'0x07b': {name: "StandingChargePrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x08': {name: "StandingChargeValue" /* DWORD */ }, 
		'0x09a': {name: "NumberOfSupplierCharacters" /* Properties2 STRUCT_BYTE */ }, 
		'0x09b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }, 
		'0x0a': {name: "SupplierCharacter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('Currency' in context) payload.writeBIT_24(context['Currency']); else return payload.asBuffer();
		if ('StandingChargePeriod' in context || 'StandingChargePrecision' in context) {
			let _properties1 = 0x00;
			if ('StandingChargePeriod' in context) _properties1 = _properties1 | ((context['StandingChargePeriod']) & 0x1f);
			if ('StandingChargePrecision' in context) _properties1 = _properties1 | ((context['StandingChargePrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StandingChargeValue' in context) payload.writeDWORD(context['StandingChargeValue']); else return payload.asBuffer();
		if ('NumberOfSupplierCharacters' in context || 'Reserved' in context) {
			let _properties2 = 0x00;
			if ('NumberOfSupplierCharacters' in context) _properties2 = _properties2 | ((context['NumberOfSupplierCharacters']) & 0x1f);
			if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('SupplierCharacter' in context) payload.writeSTRING(context['SupplierCharacter'], { encoding: 'hex', length: (payload.at(9) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Currency'] = payload.readBIT_24(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StandingChargePeriod'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['StandingChargePrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StandingChargeValue'] = payload.readDWORD(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfSupplierCharacters'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SupplierCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(9) & 0x1f }); else return context;
		return context;
	}
};

// TARIFF_CONFIG [0x4a] TARIFF_TBL_SET [0x02] COMMAND 
COMMAND_CLASS.enum[0x4a].command[0x02] = {
	name: "TARIFF_TBL_SET",
	help: "Tariff Tbl Set",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "TariffPrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "TariffValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Reserved' in context || 'TariffPrecision' in context) {
			let _properties1 = 0x00;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x1f);
			if ('TariffPrecision' in context) _properties1 = _properties1 | ((context['TariffPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('TariffValue' in context) payload.writeDWORD(context['TariffValue']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['TariffPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['TariffValue'] = payload.readDWORD(); else return context;
		return context;
	}
};

// TARIFF_CONFIG [0x4a] TARIFF_TBL_REMOVE [0x03] COMMAND 
COMMAND_CLASS.enum[0x4a].command[0x03] = {
	name: "TARIFF_TBL_REMOVE",
	help: "Tariff Tbl Remove",
	param: { 
		'0x00a': {name: "RateParameterSetIds" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "RateParameterSetId" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetIds' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('RateParameterSetIds' in context) _properties1 = _properties1 | ((context['RateParameterSetIds']) & 0x3f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RateParameterSetId' in context) payload.writeSTRING(context['RateParameterSetId'], { encoding: 'hex', length: (payload.at(0) & 0x3f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RateParameterSetIds'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x3f }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4b TARIFF_TBL_MONITOR COMMANDS
 */

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_SUPPLIER_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x01] = {
	name: "TARIFF_TBL_SUPPLIER_GET",
	help: "Tariff Tbl Supplier Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_SUPPLIER_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x02] = {
	name: "TARIFF_TBL_SUPPLIER_REPORT",
	help: "Tariff Tbl Supplier Report",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourLocalTime" /* BYTE */ }, 
		'0x04': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x05': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x06': {name: "Currency" /* BIT_24 */ }, 
		'0x07a': {name: "StandingChargePeriod" /* Properties1 STRUCT_BYTE */ }, 
		'0x07b': {name: "StandingChargePrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x08': {name: "StandingChargeValue" /* DWORD */ }, 
		'0x09a': {name: "NumberOfSupplierCharacters" /* Properties2 STRUCT_BYTE */ }, 
		'0x09b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }, 
		'0x0a': {name: "SupplierCharacter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context) payload.writeBYTE(context['HourLocalTime']); else return payload.asBuffer();
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('Currency' in context) payload.writeBIT_24(context['Currency']); else return payload.asBuffer();
		if ('StandingChargePeriod' in context || 'StandingChargePrecision' in context) {
			let _properties1 = 0x00;
			if ('StandingChargePeriod' in context) _properties1 = _properties1 | ((context['StandingChargePeriod']) & 0x1f);
			if ('StandingChargePrecision' in context) _properties1 = _properties1 | ((context['StandingChargePrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StandingChargeValue' in context) payload.writeDWORD(context['StandingChargeValue']); else return payload.asBuffer();
		if ('NumberOfSupplierCharacters' in context || 'Reserved' in context) {
			let _properties2 = 0x00;
			if ('NumberOfSupplierCharacters' in context) _properties2 = _properties2 | ((context['NumberOfSupplierCharacters']) & 0x1f);
			if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('SupplierCharacter' in context) payload.writeSTRING(context['SupplierCharacter'], { encoding: 'hex', length: (payload.at(9) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Currency'] = payload.readBIT_24(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StandingChargePeriod'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['StandingChargePrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StandingChargeValue'] = payload.readDWORD(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfSupplierCharacters'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SupplierCharacter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(9) & 0x1f }); else return context;
		return context;
	}
};

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x03] = {
	name: "TARIFF_TBL_GET",
	help: "Tariff Tbl Get",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x04] = {
	name: "TARIFF_TBL_REPORT",
	help: "Tariff Tbl Report",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "TariffPrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "TariffValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('Reserved' in context || 'TariffPrecision' in context) {
			let _properties1 = 0x00;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x1f);
			if ('TariffPrecision' in context) _properties1 = _properties1 | ((context['TariffPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('TariffValue' in context) payload.writeDWORD(context['TariffValue']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['TariffPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['TariffValue'] = payload.readDWORD(); else return context;
		return context;
	}
};

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_COST_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x05] = {
	name: "TARIFF_TBL_COST_GET",
	help: "Tariff Tbl Cost Get",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01': {name: "StartYear" /* WORD */ }, 
		'0x02': {name: "StartMonth" /* BYTE */ }, 
		'0x03': {name: "StartDay" /* BYTE */ }, 
		'0x04': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x05': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x06': {name: "StopYear" /* WORD */ }, 
		'0x07': {name: "StopMonth" /* BYTE */ }, 
		'0x08': {name: "StopDay" /* BYTE */ }, 
		'0x09': {name: "StopHourLocalTime" /* BYTE */ }, 
		'0x0a': {name: "StopMinuteLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeWORD(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHourLocalTime' in context) payload.writeBYTE(context['StopHourLocalTime']); else return payload.asBuffer();
		if ('StopMinuteLocalTime' in context) payload.writeBYTE(context['StopMinuteLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinuteLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TARIFF_TBL_MONITOR [0x4b] TARIFF_TBL_COST_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x4b].command[0x06] = {
	name: "TARIFF_TBL_COST_REPORT",
	help: "Tariff Tbl Cost Report",
	param: { 
		'0x00': {name: "RateParameterSetId" /* BYTE */ }, 
		'0x01a': {name: "RateType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "StartYear" /* WORD */ }, 
		'0x03': {name: "StartMonth" /* BYTE */ }, 
		'0x04': {name: "StartDay" /* BYTE */ }, 
		'0x05': {name: "StartHourLocalTime" /* BYTE */ }, 
		'0x06': {name: "StartMinuteLocalTime" /* BYTE */ }, 
		'0x07': {name: "StopYear" /* WORD */ }, 
		'0x08': {name: "StopMonth" /* BYTE */ }, 
		'0x09': {name: "StopDay" /* BYTE */ }, 
		'0x0a': {name: "StopHourLocalTime" /* BYTE */ }, 
		'0x0b': {name: "StopMinuteLocalTime" /* BYTE */ }, 
		'0x0c': {name: "Currency" /* BIT_24 */ }, 
		'0x0da': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x0db': {name: "CostPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x0e': {name: "CostValue" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RateParameterSetId' in context) payload.writeBYTE(context['RateParameterSetId']); else return payload.asBuffer();
		if ('RateType' in context || 'Reserved1' in context) {
			let _properties1 = 0x00;
			if ('RateType' in context) _properties1 = _properties1 | ((context['RateType']) & 0x03);
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('StartYear' in context) payload.writeWORD(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHourLocalTime' in context) payload.writeBYTE(context['StartHourLocalTime']); else return payload.asBuffer();
		if ('StartMinuteLocalTime' in context) payload.writeBYTE(context['StartMinuteLocalTime']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeWORD(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHourLocalTime' in context) payload.writeBYTE(context['StopHourLocalTime']); else return payload.asBuffer();
		if ('StopMinuteLocalTime' in context) payload.writeBYTE(context['StopMinuteLocalTime']); else return payload.asBuffer();
		if ('Currency' in context) payload.writeBIT_24(context['Currency']); else return payload.asBuffer();
		if ('Reserved2' in context || 'CostPrecision' in context) {
			let _properties2 = 0x00;
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2']) & 0x1f);
			if ('CostPrecision' in context) _properties2 = _properties2 | ((context['CostPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('CostValue' in context) payload.writeDWORD(context['CostValue']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RateParameterSetId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RateType'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHourLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Currency'] = payload.readBIT_24(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['CostPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['CostValue'] = payload.readDWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4c DOOR_LOCK_LOGGING COMMANDS
 */

// DOOR_LOCK_LOGGING [0x4c] RECORDS_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x4c].command[0x01] = {
	name: "RECORDS_SUPPORTED_GET",
	help: "Door Lock Logging Records Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DOOR_LOCK_LOGGING [0x4c] RECORDS_SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x4c].command[0x02] = {
	name: "RECORDS_SUPPORTED_REPORT",
	help: "Door Lock Logging Records Supported Report",
	param: { 
		'0x00': {name: "MaxRecordsStored" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MaxRecordsStored' in context) payload.writeBYTE(context['MaxRecordsStored']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MaxRecordsStored'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DOOR_LOCK_LOGGING [0x4c] RECORD_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x4c].command[0x03] = {
	name: "RECORD_GET",
	help: "Record Get",
	param: { 
		'0x00': {name: "RecordNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RecordNumber' in context) payload.writeBYTE(context['RecordNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RecordNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DOOR_LOCK_LOGGING [0x4c] RECORD_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x4c].command[0x04] = {
	name: "RECORD_REPORT",
	help: "Record Report",
	param: { 
		'0x00': {name: "RecordNumber" /* BYTE */ }, 
		'0x01': {name: "Year" /* WORD */ }, 
		'0x02': {name: "Month" /* BYTE */ }, 
		'0x03': {name: "Day" /* BYTE */ }, 
		'0x04a': {name: "HourLocalTime" /* Properties1 STRUCT_BYTE */ }, 
		'0x04b': {name: "RecordStatus" /* Properties1 STRUCT_BYTE */ }, 
		'0x05': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x06': {name: "SecondLocalTime" /* BYTE */ }, 
		'0x07': {name: "EventType" /* BYTE */ }, 
		'0x08': {name: "UserIdentifier" /* BYTE */ }, 
		'0x09': {name: "UserCodeLength" /* BYTE */ }, 
		'0x0a': {name: "UserCode" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RecordNumber' in context) payload.writeBYTE(context['RecordNumber']); else return payload.asBuffer();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourLocalTime' in context || 'RecordStatus' in context) {
			let _properties1 = 0x00;
			if ('HourLocalTime' in context) _properties1 = _properties1 | ((context['HourLocalTime']) & 0x1f);
			if ('RecordStatus' in context) _properties1 = _properties1 | ((context['RecordStatus'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		if ('EventType' in context) payload.writeBYTE(context['EventType']); else return payload.asBuffer();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('UserCodeLength' in context) payload.writeBYTE(context['UserCodeLength']); else return payload.asBuffer();
		if ('UserCode' in context) payload.writeSTRING(context['UserCode'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RecordNumber'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['HourLocalTime'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['RecordStatus'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventType'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['UserCodeLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['UserCode'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4d NETWORK_MANAGEMENT_BASIC COMMANDS
 */

// NETWORK_MANAGEMENT_BASIC [0x4d] LEARN_MODE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x01] = {
	name: "LEARN_MODE_SET",
	help: "Learn Mode Set",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Reserved" /* BYTE */ }, 
		'0x02': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE = {
	LearnModeSetDisable: 0x00, 
	LearnModeSetClassic: 0x01, 
	LearnModeSetNwi: 0x02, 
	enum: {
		0x00: "LearnModeSetDisable", 
		0x01: "LearnModeSetClassic", 
		0x02: "LearnModeSetNwi"
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] LEARN_MODE_SET_STATUS [0x02] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x02] = {
	name: "LEARN_MODE_SET_STATUS",
	help: "Learn Mode Set Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "Reserved" /* BYTE */ }, 
		'0x03': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x04': {name: "GrantedKeys" /* BYTE */ }, 
		'0x05': {name: "DSK" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE_SET_STATUS)); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('GrantedKeys' in context) payload.writeBYTE(context['GrantedKeys']); else return payload.asBuffer();
		if ('DSK' in context) payload.writeSTRING(context['DSK'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE_SET_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GrantedKeys'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DSK'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE_SET_STATUS = {
	LearnModeFailedTimeout: 0x01, 
	LearnModeDone: 0x06, 
	LearnModeFailed: 0x07, 
	LearnModeSecurityFailed: 0x09, 
	enum: {
		0x01: "LearnModeFailedTimeout", 
		0x06: "LearnModeDone", 
		0x07: "LearnModeFailed", 
		0x09: "LearnModeSecurityFailed"
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] NETWORK_UPDATE_REQUEST [0x03] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x03] = {
	name: "NETWORK_UPDATE_REQUEST",
	help: "Network Update Request",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] NETWORK_UPDATE_REQUEST_STATUS [0x04] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x04] = {
	name: "NETWORK_UPDATE_REQUEST_STATUS",
	help: "Network Update Request Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_BASIC_NETWORK_UPDATE_REQUEST_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_BASIC_NETWORK_UPDATE_REQUEST_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_BASIC_NETWORK_UPDATE_REQUEST_STATUS = {
	SucUpdateDone: 0x00, 
	SucUpdateAbort: 0x01, 
	SucUpdateWait: 0x02, 
	SucUpdateDisabled: 0x03, 
	SucUpdateOverflow: 0x04, 
	enum: {
		0x00: "SucUpdateDone", 
		0x01: "SucUpdateAbort", 
		0x02: "SucUpdateWait", 
		0x03: "SucUpdateDisabled", 
		0x04: "SucUpdateOverflow"
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] NODE_INFORMATION_SEND [0x05] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x05] = {
	name: "NODE_INFORMATION_SEND",
	help: "Node Information Send",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Reserved" /* BYTE */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x03-0': {name: "Ack" /* TxOptions BITMASK */ }, 
		'0x03-1': {name: "LowPower" /* TxOptions BITMASK */ }, 
		'0x03-2': {name: "AutoRoute" /* TxOptions BITMASK */ }, 
		'0x03-3': {name: "Reserved" /* TxOptions BITMASK */ }, 
		'0x03-4': {name: "NoRoute" /* TxOptions BITMASK */ }, 
		'0x03-5': {name: "Explore" /* TxOptions BITMASK */ }, 
		'0x03-6': {name: "NoRetransmission" /* TxOptions BITMASK */ }, 
		'0x03-7': {name: "HighPower" /* TxOptions BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS.enum);
		return context;
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] DEFAULT_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x06] = {
	name: "DEFAULT_SET",
	help: "Default Set",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] DEFAULT_SET_COMPLETE [0x07] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x07] = {
	name: "DEFAULT_SET_COMPLETE",
	help: "Default Set Complete",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_BASIC_DEFAULT_SET_COMPLETE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_BASIC_DEFAULT_SET_COMPLETE_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_BASIC_DEFAULT_SET_COMPLETE_STATUS = {
	DefaultSetDone: 0x06, 
	DefaultSetBusy: 0x07, 
	enum: {
		0x06: "DefaultSetDone", 
		0x07: "DefaultSetBusy"
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] DSK_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x08] = {
	name: "DSK_GET",
	help: "DSK Get",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_BASIC [0x4d] DSK_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x4d].command[0x09] = {
	name: "DSK_REPORT",
	help: "DSK Report",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "DSK" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('DSK' in context) payload.writeSTRING(context['DSK'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DSK'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4e SCHEDULE_ENTRY_LOCK COMMANDS
 */

// SCHEDULE_ENTRY_LOCK [0x4e] ENABLE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x01] = {
	name: "ENABLE_SET",
	help: "Schedule Entry Lock Enable Set",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "Enabled" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('Enabled' in context) payload.writeBYTE(helpers.getValue(context, 'Enabled', ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Enabled'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED.enum); else return context;
		return context;
	}
};

const ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED = {
	Disabled: 0x00, 
	Enabled: 0x01, 
	enum: {
		0x00: "Disabled", 
		0x01: "Enabled"
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] ENABLE_ALL_SET [0x02] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x02] = {
	name: "ENABLE_ALL_SET",
	help: "Schedule Entry Lock Enable All Set",
	param: { 
		'0x00': {name: "Enabled" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Enabled' in context) payload.writeBYTE(helpers.getValue(context, 'Enabled', ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Enabled'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED.enum); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] WEEK_DAY_SET [0x03] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x03] = {
	name: "WEEK_DAY_SET",
	help: "Schedule Entry Lock Week Day Set",
	param: { 
		'0x00': {name: "SetAction" /* CONST */ }, 
		'0x01': {name: "UserIdentifier" /* BYTE */ }, 
		'0x02': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x03': {name: "DayOfWeek" /* BYTE */ }, 
		'0x04': {name: "StartHour" /* BYTE */ }, 
		'0x05': {name: "StartMinute" /* BYTE */ }, 
		'0x06': {name: "StopHour" /* BYTE */ }, 
		'0x07': {name: "StopMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetAction' in context) payload.writeBYTE(helpers.getValue(context, 'SetAction', ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION)); else return payload.asBuffer();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('DayOfWeek' in context) payload.writeBYTE(context['DayOfWeek']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('StopHour' in context) payload.writeBYTE(context['StopHour']); else return payload.asBuffer();
		if ('StopMinute' in context) payload.writeBYTE(context['StopMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetAction'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION.enum); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayOfWeek'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION = {
	Erase: 0x00, 
	Modify: 0x01, 
	enum: {
		0x00: "Erase", 
		0x01: "Modify"
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] WEEK_DAY_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x04] = {
	name: "WEEK_DAY_GET",
	help: "Schedule Entry Lock Week Day Get",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] WEEK_DAY_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x05] = {
	name: "WEEK_DAY_REPORT",
	help: "Schedule Entry Lock Week Day Report",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x02': {name: "DayOfWeek" /* BYTE */ }, 
		'0x03': {name: "StartHour" /* BYTE */ }, 
		'0x04': {name: "StartMinute" /* BYTE */ }, 
		'0x05': {name: "StopHour" /* BYTE */ }, 
		'0x06': {name: "StopMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('DayOfWeek' in context) payload.writeBYTE(context['DayOfWeek']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('StopHour' in context) payload.writeBYTE(context['StopHour']); else return payload.asBuffer();
		if ('StopMinute' in context) payload.writeBYTE(context['StopMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayOfWeek'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] YEAR_DAY_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x06] = {
	name: "YEAR_DAY_SET",
	help: "Schedule Entry Lock Year Day Set",
	param: { 
		'0x00': {name: "SetAction" /* CONST */ }, 
		'0x01': {name: "UserIdentifier" /* BYTE */ }, 
		'0x02': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x03': {name: "StartYear" /* BYTE */ }, 
		'0x04': {name: "StartMonth" /* BYTE */ }, 
		'0x05': {name: "StartDay" /* BYTE */ }, 
		'0x06': {name: "StartHour" /* BYTE */ }, 
		'0x07': {name: "StartMinute" /* BYTE */ }, 
		'0x08': {name: "StopYear" /* BYTE */ }, 
		'0x09': {name: "StopMonth" /* BYTE */ }, 
		'0x0a': {name: "StopDay" /* BYTE */ }, 
		'0x0b': {name: "StopHour" /* BYTE */ }, 
		'0x0c': {name: "StopMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetAction' in context) payload.writeBYTE(helpers.getValue(context, 'SetAction', ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION)); else return payload.asBuffer();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeBYTE(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeBYTE(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHour' in context) payload.writeBYTE(context['StopHour']); else return payload.asBuffer();
		if ('StopMinute' in context) payload.writeBYTE(context['StopMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetAction'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION.enum); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] YEAR_DAY_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x07] = {
	name: "YEAR_DAY_GET",
	help: "Schedule Entry Lock Year Day Get",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] YEAR_DAY_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x08] = {
	name: "YEAR_DAY_REPORT",
	help: "Schedule Entry Lock Year Day Report",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x02': {name: "StartYear" /* BYTE */ }, 
		'0x03': {name: "StartMonth" /* BYTE */ }, 
		'0x04': {name: "StartDay" /* BYTE */ }, 
		'0x05': {name: "StartHour" /* BYTE */ }, 
		'0x06': {name: "StartMinute" /* BYTE */ }, 
		'0x07': {name: "StopYear" /* BYTE */ }, 
		'0x08': {name: "StopMonth" /* BYTE */ }, 
		'0x09': {name: "StopDay" /* BYTE */ }, 
		'0x0a': {name: "StopHour" /* BYTE */ }, 
		'0x0b': {name: "StopMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeBYTE(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context) payload.writeBYTE(context['StartMonth']); else return payload.asBuffer();
		if ('StartDay' in context) payload.writeBYTE(context['StartDay']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('StopYear' in context) payload.writeBYTE(context['StopYear']); else return payload.asBuffer();
		if ('StopMonth' in context) payload.writeBYTE(context['StopMonth']); else return payload.asBuffer();
		if ('StopDay' in context) payload.writeBYTE(context['StopDay']); else return payload.asBuffer();
		if ('StopHour' in context) payload.writeBYTE(context['StopHour']); else return payload.asBuffer();
		if ('StopMinute' in context) payload.writeBYTE(context['StopMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopYear'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMonth'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StopMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] SCHEDULE_ENTRY_TYPE_SUPPORTED_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x09] = {
	name: "SCHEDULE_ENTRY_TYPE_SUPPORTED_GET",
	help: "Schedule Entry Type Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SCHEDULE_ENTRY_LOCK [0x4e] SCHEDULE_ENTRY_TYPE_SUPPORTED_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0a] = {
	name: "SCHEDULE_ENTRY_TYPE_SUPPORTED_REPORT",
	help: "Schedule Entry Type Supported Report",
	param: { 
		'0x00': {name: "NumberOfSlotsWeekDay" /* BYTE */ }, 
		'0x01': {name: "NumberOfSlotsYearDay" /* BYTE */ }, 
		'0x02': {name: "NumberOfSlotsDailyRepeating" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfSlotsWeekDay' in context) payload.writeBYTE(context['NumberOfSlotsWeekDay']); else return payload.asBuffer();
		if ('NumberOfSlotsYearDay' in context) payload.writeBYTE(context['NumberOfSlotsYearDay']); else return payload.asBuffer();
		if ('NumberOfSlotsDailyRepeating' in context) payload.writeBYTE(context['NumberOfSlotsDailyRepeating']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfSlotsWeekDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfSlotsYearDay'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfSlotsDailyRepeating'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] TIME_OFFSET_GET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0b] = {
	name: "TIME_OFFSET_GET",
	help: "Schedule Entry Lock Time Offset Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SCHEDULE_ENTRY_LOCK [0x4e] TIME_OFFSET_REPORT [0x0c] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0c] = {
	name: "TIME_OFFSET_REPORT",
	help: "Schedule Entry Lock Time Offset Report",
	param: { 
		'0x00a': {name: "SignTzo" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "HourTzo" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "MinuteTzo" /* BYTE */ }, 
		'0x02a': {name: "SignOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x02b': {name: "MinuteOffsetDst" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SignTzo' in context || 'HourTzo' in context) {
			let _level = 0x00;
			if (context['SignTzo']) _level = _level | 0x80;
			if ('HourTzo' in context) _level = _level | ((context['HourTzo']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('MinuteTzo' in context) payload.writeBYTE(context['MinuteTzo']); else return payload.asBuffer();
		if ('SignOffsetDst' in context || 'MinuteOffsetDst' in context) {
			let _level2 = 0x00;
			if (context['SignOffsetDst']) _level2 = _level2 | 0x80;
			if ('MinuteOffsetDst' in context) _level2 = _level2 | ((context['MinuteOffsetDst']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignTzo'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HourTzo'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteTzo'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignOffsetDst'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MinuteOffsetDst'] = (_level2 & 0x7f); else return context;
		}
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] TIME_OFFSET_SET [0x0d] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0d] = {
	name: "TIME_OFFSET_SET",
	help: "Schedule Entry Lock Time Offset Set",
	param: { 
		'0x00a': {name: "SignTzo" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "HourTzo" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "MinuteTzo" /* BYTE */ }, 
		'0x02a': {name: "SignOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x02b': {name: "MinuteOffsetDst" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SignTzo' in context || 'HourTzo' in context) {
			let _level = 0x00;
			if (context['SignTzo']) _level = _level | 0x80;
			if ('HourTzo' in context) _level = _level | ((context['HourTzo']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('MinuteTzo' in context) payload.writeBYTE(context['MinuteTzo']); else return payload.asBuffer();
		if ('SignOffsetDst' in context || 'MinuteOffsetDst' in context) {
			let _level2 = 0x00;
			if (context['SignOffsetDst']) _level2 = _level2 | 0x80;
			if ('MinuteOffsetDst' in context) _level2 = _level2 | ((context['MinuteOffsetDst']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignTzo'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HourTzo'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteTzo'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignOffsetDst'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MinuteOffsetDst'] = (_level2 & 0x7f); else return context;
		}
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] DAILY_REPEATING_GET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0e] = {
	name: "DAILY_REPEATING_GET",
	help: "Schedule Entry Lock Daily Repeating Get",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] DAILY_REPEATING_REPORT [0x0f] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x0f] = {
	name: "DAILY_REPEATING_REPORT",
	help: "Schedule Entry Lock Daily Repeating Report",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x02': {name: "WeekDayBitmask" /* BYTE */ }, 
		'0x03': {name: "StartHour" /* BYTE */ }, 
		'0x04': {name: "StartMinute" /* BYTE */ }, 
		'0x05': {name: "DurationHour" /* BYTE */ }, 
		'0x06': {name: "DurationMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('WeekDayBitmask' in context) payload.writeBYTE(context['WeekDayBitmask']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('DurationHour' in context) payload.writeBYTE(context['DurationHour']); else return payload.asBuffer();
		if ('DurationMinute' in context) payload.writeBYTE(context['DurationMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['WeekDayBitmask'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE_ENTRY_LOCK [0x4e] DAILY_REPEATING_SET [0x10] COMMAND 
COMMAND_CLASS.enum[0x4e].command[0x10] = {
	name: "DAILY_REPEATING_SET",
	help: "Schedule Entry Lock Daily Repeating Set",
	param: { 
		'0x00': {name: "SetAction" /* CONST */ }, 
		'0x01': {name: "UserIdentifier" /* BYTE */ }, 
		'0x02': {name: "ScheduleSlotId" /* BYTE */ }, 
		'0x03': {name: "WeekDayBitmask" /* BYTE */ }, 
		'0x04': {name: "StartHour" /* BYTE */ }, 
		'0x05': {name: "StartMinute" /* BYTE */ }, 
		'0x06': {name: "DurationHour" /* BYTE */ }, 
		'0x07': {name: "DurationMinute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetAction' in context) payload.writeBYTE(helpers.getValue(context, 'SetAction', ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION)); else return payload.asBuffer();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('ScheduleSlotId' in context) payload.writeBYTE(context['ScheduleSlotId']); else return payload.asBuffer();
		if ('WeekDayBitmask' in context) payload.writeBYTE(context['WeekDayBitmask']); else return payload.asBuffer();
		if ('StartHour' in context) payload.writeBYTE(context['StartHour']); else return payload.asBuffer();
		if ('StartMinute' in context) payload.writeBYTE(context['StartMinute']); else return payload.asBuffer();
		if ('DurationHour' in context) payload.writeBYTE(context['DurationHour']); else return payload.asBuffer();
		if ('DurationMinute' in context) payload.writeBYTE(context['DurationMinute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SetAction'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION.enum); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleSlotId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['WeekDayBitmask'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartMinute'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationHour'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DurationMinute'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x4f ZIP_6LOWPAN COMMANDS
 */

// ZIP_6LOWPAN [0x4f] LOWPAN_FIRST_FRAGMENT [0xc0] COMMAND 
COMMAND_CLASS.enum[0x4f].command[0xc0] = {
	name: "LOWPAN_FIRST_FRAGMENT",
	help: "Lowpan First Fragment",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "DatagramSize1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "DatagramSize2" /* BYTE */ }, 
		'0x02': {name: "DatagramTag" /* BYTE */ }, 
		'0x03': {name: "Payload" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DatagramSize1' in context) {
			let _properties1 = 0x00;
			if ('DatagramSize1' in context) _properties1 = _properties1 | ((context['DatagramSize1']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DatagramSize2' in context) payload.writeBYTE(context['DatagramSize2']); else return payload.asBuffer();
		if ('DatagramTag' in context) payload.writeBYTE(context['DatagramTag']); else return payload.asBuffer();
		if ('Payload' in context) payload.writeSTRING(context['Payload'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DatagramSize1'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramSize2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DatagramTag'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Payload'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// ZIP_6LOWPAN [0x4f] LOWPAN_SUBSEQUENT_FRAGMENT [0xe0] COMMAND 
COMMAND_CLASS.enum[0x4f].command[0xe0] = {
	name: "LOWPAN_SUBSEQUENT_FRAGMENT",
	help: "Lowpan Subsequent Fragment",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "DatagramSize1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "DatagramSize2" /* BYTE */ }, 
		'0x02': {name: "DatagramTag" /* BYTE */ }, 
		'0x03': {name: "DatagramOffset" /* BYTE */ }, 
		'0x04': {name: "Payload" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DatagramSize1' in context) {
			let _properties1 = 0x00;
			if ('DatagramSize1' in context) _properties1 = _properties1 | ((context['DatagramSize1']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DatagramSize2' in context) payload.writeBYTE(context['DatagramSize2']); else return payload.asBuffer();
		if ('DatagramTag' in context) payload.writeBYTE(context['DatagramTag']); else return payload.asBuffer();
		if ('DatagramOffset' in context) payload.writeBYTE(context['DatagramOffset']); else return payload.asBuffer();
		if ('Payload' in context) payload.writeSTRING(context['Payload'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DatagramSize1'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramSize2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DatagramTag'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DatagramOffset'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Payload'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x50 BASIC_WINDOW_COVERING COMMANDS
 */

// BASIC_WINDOW_COVERING [0x50] START_LEVEL_CHANGE [0x01] COMMAND 
COMMAND_CLASS.enum[0x50].command[0x01] = {
	name: "START_LEVEL_CHANGE",
	help: "Basic Window Covering Start Level Change",
	param: { 
		'0x00a': {name: "OpenClose" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved2" /* Level STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved1" /* Level STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OpenClose' in context || 'Reserved2' in context || 'Reserved1' in context) {
			let _level = 0x00;
			if (context['OpenClose']) _level = _level | 0x40;
			if (context['Reserved2']) _level = _level | 0x80;
			if ('Reserved1' in context) _level = _level | ((context['Reserved1']) & 0x3f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OpenClose'] = ((_level & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_level & 0x3f); else return context;
		}
		return context;
	}
};

// BASIC_WINDOW_COVERING [0x50] STOP_LEVEL_CHANGE [0x02] COMMAND 
COMMAND_CLASS.enum[0x50].command[0x02] = {
	name: "STOP_LEVEL_CHANGE",
	help: "Basic Window Covering Stop Level Change",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x51 MTP_WINDOW_COVERING COMMANDS
 */

// MTP_WINDOW_COVERING [0x51] MOVE_TO_POSITION_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x51].command[0x01] = {
	name: "MOVE_TO_POSITION_SET",
	help: "Move To Position Set",
	param: { 
		'0x00': {name: "Value" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(helpers.getValue(context, 'Value', ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE.enum); else return context;
		return context;
	}
};

const ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE = {
	Close: 0x00, 
	Open: 0xff, 
	enum: {
		0x00: "Close", 
		0xff: "Open"
	}
};

// MTP_WINDOW_COVERING [0x51] MOVE_TO_POSITION_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x51].command[0x02] = {
	name: "MOVE_TO_POSITION_GET",
	help: "Move To Position Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// MTP_WINDOW_COVERING [0x51] MOVE_TO_POSITION_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x51].command[0x03] = {
	name: "MOVE_TO_POSITION_REPORT",
	help: "Move To Position Report",
	param: { 
		'0x00': {name: "Value" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Value' in context) payload.writeBYTE(helpers.getValue(context, 'Value', ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x52 NETWORK_MANAGEMENT_PROXY COMMANDS
 */

// NETWORK_MANAGEMENT_PROXY [0x52] NODE_LIST_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x52].command[0x01] = {
	name: "NODE_LIST_GET",
	help: "Node List Get",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_PROXY [0x52] NODE_LIST_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x52].command[0x02] = {
	name: "NODE_LIST_REPORT",
	help: "Node List Report",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "NodeListControllerId" /* BYTE */ }, 
		'0x03': {name: "NodeListData" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_PROXY_NODE_LIST_STATUS)); else return payload.asBuffer();
		if ('NodeListControllerId' in context) payload.writeBYTE(context['NodeListControllerId']); else return payload.asBuffer();
		if ('NodeListData' in context) payload.writeBITMASK(context['NodeListData'], {length: 29}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_PROXY_NODE_LIST_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NodeListControllerId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NodeListData'] = payload.readBITMASK({length: 29}); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_PROXY_NODE_LIST_STATUS = {
	Latest: 0x00, 
	MayNotBeTheLatest: 0x01, 
	enum: {
		0x00: "Latest", 
		0x01: "MayNotBeTheLatest"
	}
};

// NETWORK_MANAGEMENT_PROXY [0x52] NODE_INFO_CACHED_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x52].command[0x03] = {
	name: "NODE_INFO_CACHED_GET",
	help: "Node Info Cached Get",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "MaxAge" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('MaxAge' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('MaxAge' in context) _properties1 = _properties1 | ((context['MaxAge']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MaxAge'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_PROXY [0x52] NODE_INFO_CACHED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x52].command[0x04] = {
	name: "NODE_INFO_CACHED_REPORT",
	help: "Node Info Cached Report",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01a': {name: "Status" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Age" /* Properties1 STRUCT_BYTE */ }, 
		'0x02a': {name: "Listening" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Capability" /* Properties2 STRUCT_BYTE */ }, 
		'0x03a': {name: "Opt" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "Security" /* Properties3 STRUCT_BYTE */ }, 
		'0x03c': {name: "Sensor" /* Properties3 STRUCT_BYTE */ }, 
		'0x04': {name: "GrantedKeys" /* BYTE */ }, 
		'0x05': {name: "BasicDeviceClass" /* BYTE */ }, 
		'0x06': {name: "GenericDeviceClass" /* BYTE */ }, 
		'0x07': {name: "SpecificDeviceClass" /* BYTE */ }, 
		'0x08': {name: "NonsecureCommandClass" /* VARIANT */ }, 
		'0x09': null /* MARKER SecurityMark handled by VARIANT */, 
		'0x0a': {name: "SecureCommandClass" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context || 'Age' in context) {
			let _properties1 = 0x00;
			if ('Status' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_PROXY_NODE_INFO_CACHED_STATUS) << 4) & 0xf0); 
			if ('Age' in context) _properties1 = _properties1 | ((context['Age']) & 0x0f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Listening' in context || 'Capability' in context) {
			let _properties2 = 0x00;
			if (context['Listening']) _properties2 = _properties2 | 0x80;
			if ('Capability' in context) _properties2 = _properties2 | ((context['Capability']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Opt' in context || 'Security' in context || 'Sensor' in context) {
			let _properties3 = 0x00;
			if (context['Opt']) _properties3 = _properties3 | 0x80;
			if ('Security' in context) _properties3 = _properties3 | ((context['Security']) & 0x0f);
			if ('Sensor' in context) _properties3 = _properties3 | ((context['Sensor'] << 4) & 0x70);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('GrantedKeys' in context) payload.writeBYTE(context['GrantedKeys']); else return payload.asBuffer();
		if ('BasicDeviceClass' in context) payload.writeBYTE(context['BasicDeviceClass']); else return payload.asBuffer();
		if ('GenericDeviceClass' in context) payload.writeBYTE(context['GenericDeviceClass']); else return payload.asBuffer();
		if ('SpecificDeviceClass' in context) payload.writeBYTE(context['SpecificDeviceClass']); else return payload.asBuffer();
		if ('NonsecureCommandClass' in context) payload.writeSTRINGtoMARKER(context['NonsecureCommandClass'], { encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return payload.asBuffer();
		if ('SecureCommandClass' in context) payload.writeSTRING(context['SecureCommandClass'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue((_properties1 & 0xf0) >> 4, ENUM_NETWORK_MANAGEMENT_PROXY_NODE_INFO_CACHED_STATUS.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Age'] = (_properties1 & 0x0f); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Listening'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Capability'] = (_properties2 & 0x7f); else return context;
		}
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Opt'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Security'] = (_properties3 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Sensor'] = (_properties3 & 0x70) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['GrantedKeys'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['BasicDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GenericDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SpecificDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NonsecureCommandClass'] = payload.readSTRINGtoMARKER({ encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return context;
		if (!payload.insufficientBytes(1)) context['SecureCommandClass'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_PROXY_NODE_INFO_CACHED_STATUS = {
	STATUS_OK: 0x00, 
	STATUS_NOT_RESPONDING: 0x01, 
	STATUS_UNKNOWN: 0x02, 
	enum: {
		0x00: "STATUS_OK", 
		0x01: "STATUS_NOT_RESPONDING", 
		0x02: "STATUS_UNKNOWN"
	}
};



/*
 * COMMAND_CLASS 0x53 SCHEDULE COMMANDS
 */

// SCHEDULE [0x53] SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x01] = {
	name: "SUPPORTED_GET",
	help: "Schedule Support Get",
	param: { 
		'0x00': {name: "ScheduleIdBlock" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE [0x53] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Schedule Support Report",
	param: { 
		'0x00': {name: "NumberOfSupportedScheduleId" /* BYTE */ }, 
		'0x01a': {name: "FallbackSupport" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SupportEnabledisable" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "StartTimeSupport" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "NumberOfSupportedCc" /* BYTE */ }, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00': {name: "SupportedCc" /* BYTE */ },
				'0x03-0x03a': {name: "SupportedCommand" /* Properties2 STRUCT_BYTE */ },
				'0x03-0x03b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }, 
		'0x04a': {name: "OverrideSupport" /* Properties3 STRUCT_BYTE */ }, 
		'0x04b': {name: "SupportedOverrideTypes" /* Properties3 STRUCT_BYTE */ }, 
		'0x05': {name: "ScheduleIdBlock" /* BYTE */ }, 
		'0x06': {name: "NumberOfSupportedScheduleBlocks" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfSupportedScheduleId' in context) payload.writeBYTE(context['NumberOfSupportedScheduleId']); else return payload.asBuffer();
		if ('FallbackSupport' in context || 'SupportEnabledisable' in context || 'StartTimeSupport' in context) {
			let _properties1 = 0x00;
			if (context['FallbackSupport']) _properties1 = _properties1 | 0x40;
			if (context['SupportEnabledisable']) _properties1 = _properties1 | 0x80;
			if ('StartTimeSupport' in context) _properties1 = _properties1 | ((context['StartTimeSupport']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('NumberOfSupportedCc' in context) payload.writeBYTE(context['NumberOfSupportedCc']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(2))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('SupportedCc' in context) payload.writeBYTE(context['SupportedCc']); else return payload.asBuffer();
				if ('SupportedCommand' in context || 'Reserved' in context) {
					let _properties2 = 0x00;
					if ('SupportedCommand' in context) _properties2 = _properties2 | ((context['SupportedCommand']) & 0x03);
					if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved'] << 2) & 0xfc);
					payload.writeBYTE(_properties2);
				} else return payload.asBuffer();;
			});
		} else return payload.asBuffer();;
		if ('OverrideSupport' in context || 'SupportedOverrideTypes' in context) {
			let _properties3 = 0x00;
			if (context['OverrideSupport']) _properties3 = _properties3 | 0x80;
			if ('SupportedOverrideTypes' in context) _properties3 = _properties3 | ((context['SupportedOverrideTypes']) & 0x7f);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		if ('NumberOfSupportedScheduleBlocks' in context) payload.writeBYTE(context['NumberOfSupportedScheduleBlocks']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfSupportedScheduleId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FallbackSupport'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SupportEnabledisable'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartTimeSupport'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['NumberOfSupportedCc'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(2); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['SupportedCc'] = payload.readBYTE(); else return context;
			{
				let _properties2 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['SupportedCommand'] = (_properties2 & 0x03); else return context;
				if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0xfc) >> 2; else return context;
			}
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OverrideSupport'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SupportedOverrideTypes'] = (_properties3 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfSupportedScheduleBlocks'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE [0x53] COMMAND_SCHEDULE_SET [0x03] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x03] = {
	name: "COMMAND_SCHEDULE_SET",
	help: "Schedule Set",
	param: { 
		'0x00': {name: "ScheduleId" /* BYTE */ }, 
		'0x01': {name: "ScheduleIdBlock" /* BYTE */ }, 
		'0x02': {name: "StartYear" /* BYTE */ }, 
		'0x03a': {name: "StartMonth" /* Properties1 STRUCT_BYTE */ }, 
		'0x03b': {name: "RecurrenceOffset" /* Properties1 STRUCT_BYTE */ }, 
		'0x04a': {name: "RecurrenceMode" /* Properties2 STRUCT_BYTE */ }, 
		'0x04b': {name: "Reserved1" /* Properties2 STRUCT_BYTE */ }, 
		'0x04c': {name: "StartDayOfMonth" /* Properties2 STRUCT_BYTE */ }, 
		'0x05a': {name: "Reserved2" /* Properties3 STRUCT_BYTE */ }, 
		'0x05b': {name: "StartWeekday" /* Properties3 STRUCT_BYTE */ }, 
		'0x06a': {name: "StartHour" /* Properties4 STRUCT_BYTE */ }, 
		'0x06b': {name: "DurationType" /* Properties4 STRUCT_BYTE */ }, 
		'0x07a': {name: "Relative" /* Properties5 STRUCT_BYTE */ }, 
		'0x07b': {name: "Reserved3" /* Properties5 STRUCT_BYTE */ }, 
		'0x07c': {name: "StartMinute" /* Properties5 STRUCT_BYTE */ }, 
		'0x08': {name: "DurationByte" /* WORD */ }, 
		'0x09': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x0a': {name: "NumberOfCmdToFollow" /* BYTE */ }, 
		'0x0b': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x0b-0x00': {name: "Length" /* BYTE */ },
				'0x0b-0x01': {name: "Byte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleId' in context) payload.writeBYTE(context['ScheduleId']); else return payload.asBuffer();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeBYTE(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context || 'RecurrenceOffset' in context) {
			let _properties1 = 0x00;
			if ('StartMonth' in context) _properties1 = _properties1 | ((context['StartMonth']) & 0x0f);
			if ('RecurrenceOffset' in context) _properties1 = _properties1 | ((context['RecurrenceOffset'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RecurrenceMode' in context || 'Reserved1' in context || 'StartDayOfMonth' in context) {
			let _properties2 = 0x00;
			if ('RecurrenceMode' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'RecurrenceMode', ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE) << 5) & 0x60); 
			if (context['Reserved1']) _properties2 = _properties2 | 0x80;
			if ('StartDayOfMonth' in context) _properties2 = _properties2 | ((context['StartDayOfMonth']) & 0x1f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Reserved2' in context || 'StartWeekday' in context) {
			let _properties3 = 0x00;
			if (context['Reserved2']) _properties3 = _properties3 | 0x80;
			if ('StartWeekday' in context) _properties3 = _properties3 | ((context['StartWeekday']) & 0x7f);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('StartHour' in context || 'DurationType' in context) {
			let _properties4 = 0x00;
			if ('StartHour' in context) _properties4 = _properties4 | ((context['StartHour']) & 0x1f);
			if ('DurationType' in context) _properties4 = _properties4 | ((context['DurationType'] << 5) & 0xe0);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ('Relative' in context || 'Reserved3' in context || 'StartMinute' in context) {
			let _properties5 = 0x00;
			if (context['Relative']) _properties5 = _properties5 | 0x40;
			if (context['Reserved3']) _properties5 = _properties5 | 0x80;
			if ('StartMinute' in context) _properties5 = _properties5 | ((context['StartMinute']) & 0x3f);
			payload.writeBYTE(_properties5);
		} else return payload.asBuffer();;
		if ('DurationByte' in context) payload.writeWORD(context['DurationByte']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('NumberOfCmdToFollow' in context) payload.writeBYTE(context['NumberOfCmdToFollow']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(10))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Length' in context) payload.writeBYTE(context['Length']); else return payload.asBuffer();
				if ('Byte' in context) payload.writeSTRING(context['Byte'], { encoding: 'hex', length: (payload.at(11) & 0xff) }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StartMonth'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['RecurrenceOffset'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RecurrenceMode'] = helpers.lookupNameValue((_properties2 & 0x60) >> 5, ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartDayOfMonth'] = (_properties2 & 0x1f); else return context;
		}
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved2'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartWeekday'] = (_properties3 & 0x7f); else return context;
		}
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StartHour'] = (_properties4 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['DurationType'] = (_properties4 & 0xe0) >> 5; else return context;
		}
		{
			let _properties5 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Relative'] = ((_properties5 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved3'] = ((_properties5 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartMinute'] = (_properties5 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DurationByte'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfCmdToFollow'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(10); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Length'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Byte'] = payload.readSTRING({ encoding: 'hex', length: payload.at(11) & 0xff }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

const ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE = {
	RepeatEverynHours: 0x00, 
	RepeatEverynDays: 0x01, 
	RepeatEverynWeeks: 0x02, 
	enum: {
		0x00: "RepeatEverynHours", 
		0x01: "RepeatEverynDays", 
		0x02: "RepeatEverynWeeks"
	}
};

// SCHEDULE [0x53] COMMAND_SCHEDULE_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x04] = {
	name: "COMMAND_SCHEDULE_GET",
	help: "Schedule Get",
	param: { 
		'0x00': {name: "ScheduleId" /* BYTE */ }, 
		'0x01': {name: "ScheduleIdBlock" /* BYTE */ }, 
		'0x02a': {name: "AidRoCtl" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleId' in context) payload.writeBYTE(context['ScheduleId']); else return payload.asBuffer();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		if ('AidRoCtl' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['AidRoCtl']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['AidRoCtl'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};

// SCHEDULE [0x53] COMMAND_SCHEDULE_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x05] = {
	name: "COMMAND_SCHEDULE_REPORT",
	help: "Schedule Report",
	param: { 
		'0x00': {name: "ScheduleId" /* BYTE */ }, 
		'0x01': {name: "ScheduleIdBlock" /* BYTE */ }, 
		'0x02': {name: "StartYear" /* BYTE */ }, 
		'0x03a': {name: "StartMonth" /* Properties1 STRUCT_BYTE */ }, 
		'0x03b': {name: "AidRo" /* Properties1 STRUCT_BYTE */ }, 
		'0x04a': {name: "RecurrenceMode" /* Properties2 STRUCT_BYTE */ }, 
		'0x04b': {name: "AidRoCtl" /* Properties2 STRUCT_BYTE */ }, 
		'0x04c': {name: "StartDayOfMonth" /* Properties2 STRUCT_BYTE */ }, 
		'0x05a': {name: "Reserved1" /* Properties3 STRUCT_BYTE */ }, 
		'0x05b': {name: "StartWeekday" /* Properties3 STRUCT_BYTE */ }, 
		'0x06a': {name: "StartHour" /* Properties4 STRUCT_BYTE */ }, 
		'0x06b': {name: "DurationType" /* Properties4 STRUCT_BYTE */ }, 
		'0x07a': {name: "Relative" /* Properties5 STRUCT_BYTE */ }, 
		'0x07b': {name: "Reserved2" /* Properties5 STRUCT_BYTE */ }, 
		'0x07c': {name: "StartMinute" /* Properties5 STRUCT_BYTE */ }, 
		'0x08': {name: "DurationByte" /* WORD */ }, 
		'0x09': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x0a': {name: "NumberOfCmdToFollow" /* BYTE */ }, 
		'0x0b': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x0b-0x00': {name: "Length" /* BYTE */ },
				'0x0b-0x01': {name: "Byte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleId' in context) payload.writeBYTE(context['ScheduleId']); else return payload.asBuffer();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		if ('StartYear' in context) payload.writeBYTE(context['StartYear']); else return payload.asBuffer();
		if ('StartMonth' in context || 'AidRo' in context) {
			let _properties1 = 0x00;
			if ('StartMonth' in context) _properties1 = _properties1 | ((context['StartMonth']) & 0x0f);
			if ('AidRo' in context) _properties1 = _properties1 | ((context['AidRo'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('RecurrenceMode' in context || 'AidRoCtl' in context || 'StartDayOfMonth' in context) {
			let _properties2 = 0x00;
			if ('RecurrenceMode' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'RecurrenceMode', ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE) << 5) & 0x60); 
			if (context['AidRoCtl']) _properties2 = _properties2 | 0x80;
			if ('StartDayOfMonth' in context) _properties2 = _properties2 | ((context['StartDayOfMonth']) & 0x1f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Reserved1' in context || 'StartWeekday' in context) {
			let _properties3 = 0x00;
			if (context['Reserved1']) _properties3 = _properties3 | 0x80;
			if ('StartWeekday' in context) _properties3 = _properties3 | ((context['StartWeekday']) & 0x7f);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('StartHour' in context || 'DurationType' in context) {
			let _properties4 = 0x00;
			if ('StartHour' in context) _properties4 = _properties4 | ((context['StartHour']) & 0x1f);
			if ('DurationType' in context) _properties4 = _properties4 | ((context['DurationType'] << 5) & 0xe0);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ('Relative' in context || 'Reserved2' in context || 'StartMinute' in context) {
			let _properties5 = 0x00;
			if (context['Relative']) _properties5 = _properties5 | 0x40;
			if (context['Reserved2']) _properties5 = _properties5 | 0x80;
			if ('StartMinute' in context) _properties5 = _properties5 | ((context['StartMinute']) & 0x3f);
			payload.writeBYTE(_properties5);
		} else return payload.asBuffer();;
		if ('DurationByte' in context) payload.writeWORD(context['DurationByte']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('NumberOfCmdToFollow' in context) payload.writeBYTE(context['NumberOfCmdToFollow']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(10))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Length' in context) payload.writeBYTE(context['Length']); else return payload.asBuffer();
				if ('Byte' in context) payload.writeSTRING(context['Byte'], { encoding: 'hex', length: (payload.at(11) & 0xff) }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StartYear'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StartMonth'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['AidRo'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RecurrenceMode'] = helpers.lookupNameValue((_properties2 & 0x60) >> 5, ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['AidRoCtl'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartDayOfMonth'] = (_properties2 & 0x1f); else return context;
		}
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved1'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartWeekday'] = (_properties3 & 0x7f); else return context;
		}
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['StartHour'] = (_properties4 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['DurationType'] = (_properties4 & 0xe0) >> 5; else return context;
		}
		{
			let _properties5 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Relative'] = ((_properties5 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = ((_properties5 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StartMinute'] = (_properties5 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DurationByte'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfCmdToFollow'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(10); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Length'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Byte'] = payload.readSTRING({ encoding: 'hex', length: payload.at(11) & 0xff }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// SCHEDULE [0x53] REMOVE [0x06] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x06] = {
	name: "REMOVE",
	help: "Schedule Remove",
	param: { 
		'0x00': {name: "ScheduleId" /* BYTE */ }, 
		'0x01': {name: "ScheduleIdBlock" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleId' in context) payload.writeBYTE(context['ScheduleId']); else return payload.asBuffer();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE [0x53] STATE_SET [0x07] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x07] = {
	name: "STATE_SET",
	help: "Schedule State Set",
	param: { 
		'0x00': {name: "ScheduleId" /* BYTE */ }, 
		'0x01': {name: "ScheduleState" /* BYTE */ }, 
		'0x02': {name: "ScheduleIdBlock" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleId' in context) payload.writeBYTE(context['ScheduleId']); else return payload.asBuffer();
		if ('ScheduleState' in context) payload.writeBYTE(context['ScheduleState']); else return payload.asBuffer();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleState'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE [0x53] STATE_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x08] = {
	name: "STATE_GET",
	help: "Schedule State Get",
	param: { 
		'0x00': {name: "ScheduleIdBlock" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCHEDULE [0x53] STATE_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x53].command[0x09] = {
	name: "STATE_REPORT",
	help: "Schedule State Report",
	param: { 
		'0x00': {name: "NumberOfSupportedScheduleId" /* BYTE */ }, 
		'0x01a': {name: "Override" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "ReportsToFollow" /* Properties1 STRUCT_BYTE */ }, 
		'0x02a': {name: "ActiveId1" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "ActiveId2" /* Properties2 STRUCT_BYTE */ }, 
		'0x03a': {name: "ActiveId3" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "ActiveIdn" /* Properties3 STRUCT_BYTE */ }, 
		'0x04': {name: "ScheduleIdBlock" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfSupportedScheduleId' in context) payload.writeBYTE(context['NumberOfSupportedScheduleId']); else return payload.asBuffer();
		if ('Override' in context || 'ReportsToFollow' in context) {
			let _properties1 = 0x00;
			if (context['Override']) _properties1 = _properties1 | 0x01;
			if ('ReportsToFollow' in context) _properties1 = _properties1 | ((context['ReportsToFollow'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ActiveId1' in context || 'ActiveId2' in context) {
			let _properties2 = 0x00;
			if ('ActiveId1' in context) _properties2 = _properties2 | ((context['ActiveId1']) & 0x0f);
			if ('ActiveId2' in context) _properties2 = _properties2 | ((context['ActiveId2'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('ActiveId3' in context || 'ActiveIdn' in context) {
			let _properties3 = 0x00;
			if ('ActiveId3' in context) _properties3 = _properties3 | ((context['ActiveId3']) & 0x0f);
			if ('ActiveIdn' in context) _properties3 = _properties3 | ((context['ActiveIdn'] << 4) & 0xf0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('ScheduleIdBlock' in context) payload.writeBYTE(context['ScheduleIdBlock']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfSupportedScheduleId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Override'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ActiveId1'] = (_properties2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['ActiveId2'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ActiveId3'] = (_properties3 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['ActiveIdn'] = (_properties3 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ScheduleIdBlock'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x54 NETWORK_MANAGEMENT_PRIMARY COMMANDS
 */

// NETWORK_MANAGEMENT_PRIMARY [0x54] CONTROLLER_CHANGE [0x01] COMMAND 
COMMAND_CLASS.enum[0x54].command[0x01] = {
	name: "CONTROLLER_CHANGE",
	help: "Controller Change",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Reserved" /* BYTE */ }, 
		'0x02': {name: "Mode" /* CONST */ }, 
		'0x03-0': {name: "Ack" /* TxOptions BITMASK */ }, 
		'0x03-1': {name: "LowPower" /* TxOptions BITMASK */ }, 
		'0x03-2': {name: "AutoRoute" /* TxOptions BITMASK */ }, 
		'0x03-3': {name: "Reserved" /* TxOptions BITMASK */ }, 
		'0x03-4': {name: "NoRoute" /* TxOptions BITMASK */ }, 
		'0x03-5': {name: "Explore" /* TxOptions BITMASK */ }, 
		'0x03-6': {name: "NoRetransmission" /* TxOptions BITMASK */ }, 
		'0x03-7': {name: "HighPower" /* TxOptions BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_NETWORK_MANAGEMENT_PRIMARY_CONTROLLER_CHANGE_MODE)); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_PRIMARY_CONTROLLER_CHANGE_MODE.enum); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS.enum);
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_PRIMARY_CONTROLLER_CHANGE_MODE = {
	ControllerChangeStart: 0x02, 
	ControllerChangeStop: 0x05, 
	enum: {
		0x02: "ControllerChangeStart", 
		0x05: "ControllerChangeStop"
	}
};

// NETWORK_MANAGEMENT_PRIMARY [0x54] CONTROLLER_CHANGE_STATUS [0x02] COMMAND 
COMMAND_CLASS.enum[0x54].command[0x02] = {
	name: "CONTROLLER_CHANGE_STATUS",
	help: "Controller Change Status",
	param: { 
		'0x00': {name: "SeqNo" /* BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "Reserved" /* BYTE */ }, 
		'0x03': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x04': {name: "NodeInfoLength" /* BYTE */ }, 
		'0x05a': {name: "Listening" /* Properties1 STRUCT_BYTE */ }, 
		'0x05b': {name: "Capability" /* Properties1 STRUCT_BYTE */ }, 
		'0x06a': {name: "Opt" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "Security" /* Properties2 STRUCT_BYTE */ }, 
		'0x07': {name: "BasicDeviceClass" /* BYTE */ }, 
		'0x08': {name: "GenericDeviceClass" /* BYTE */ }, 
		'0x09': {name: "SpecificDeviceClass" /* BYTE */ }, 
		'0x0a': {name: "CommandClass" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SeqNo' in context) payload.writeBYTE(context['SeqNo']); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS)); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('NodeInfoLength' in context) payload.writeBYTE(context['NodeInfoLength']); else return payload.asBuffer();
		if ('Listening' in context || 'Capability' in context) {
			let _properties1 = 0x00;
			if (context['Listening']) _properties1 = _properties1 | 0x80;
			if ('Capability' in context) _properties1 = _properties1 | ((context['Capability']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Opt' in context || 'Security' in context) {
			let _properties2 = 0x00;
			if (context['Opt']) _properties2 = _properties2 | 0x80;
			if ('Security' in context) _properties2 = _properties2 | ((context['Security']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('BasicDeviceClass' in context) payload.writeBYTE(context['BasicDeviceClass']); else return payload.asBuffer();
		if ('GenericDeviceClass' in context) payload.writeBYTE(context['GenericDeviceClass']); else return payload.asBuffer();
		if ('SpecificDeviceClass' in context) payload.writeBYTE(context['SpecificDeviceClass']); else return payload.asBuffer();
		if ('CommandClass' in context) payload.writeSTRING(context['CommandClass'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SeqNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NodeInfoLength'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Listening'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Capability'] = (_properties1 & 0x7f); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Opt'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Security'] = (_properties2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['BasicDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['GenericDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SpecificDeviceClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClass'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x55 TRANSPORT_SERVICE COMMANDS
 */

// TRANSPORT_SERVICE [0x55] COMMAND_FIRST_SEGMENT [0xc0] COMMAND 
COMMAND_CLASS.enum[0x55].command[0xc0] = {
	name: "COMMAND_FIRST_SEGMENT",
	help: "First Segment",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "DatagramSize1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "DatagramSize2" /* BYTE */ }, 
		'0x02a': {name: "Ext" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }, 
		'0x02c': {name: "SessionId" /* Properties2 STRUCT_BYTE */ }, 
		'0x03': {name: "HeaderExtensionLength" /* BYTE */ }, 
		'0x04': {name: "HeaderExtension" /* VARIANT */ }, 
		'0x05': {name: "Payload" /* VARIANT */ }, 
		'0x06': {name: "FrameCheckSequence" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DatagramSize1' in context) {
			let _properties1 = 0x00;
			if ('DatagramSize1' in context) _properties1 = _properties1 | ((context['DatagramSize1']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DatagramSize2' in context) payload.writeBYTE(context['DatagramSize2']); else return payload.asBuffer();
		if ('Ext' in context || 'Reserved' in context || 'SessionId' in context) {
			let _properties2 = 0x00;
			if (context['Ext']) _properties2 = _properties2 | 0x08;
			if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved']) & 0x07);
			if ('SessionId' in context) _properties2 = _properties2 | ((context['SessionId'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ((payload.at(2) & 0x08) !== 0) /* optional flag for HeaderExtensionLength */ {
			if ('HeaderExtensionLength' in context) payload.writeBYTE(context['HeaderExtensionLength']); else return payload.asBuffer();
		}
		if ((payload.at(2) & 0x08) !== 0) /* optional flag for HeaderExtension */ {
			if ('HeaderExtension' in context) payload.writeSTRING(context['HeaderExtension'], { encoding: 'hex', length: (payload.at(3) & 0xff) }); else return payload.asBuffer();
		}
		if ('Payload' in context) payload.writeSTRING(context['Payload'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('FrameCheckSequence' in context) payload.writeWORD(context['FrameCheckSequence']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DatagramSize1'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramSize2'] = payload.readBYTE(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Ext'] = ((_properties2 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['HeaderExtensionLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HeaderExtension'] = payload.readSTRING({ encoding: 'hex', length: payload.at(3) & 0xff }); else return context;
		if (!payload.insufficientBytes(1)) context['Payload'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['FrameCheckSequence'] = payload.readWORD(); else return context;
		return context;
	}
};

// TRANSPORT_SERVICE [0x55] COMMAND_SEGMENT_REQUEST [0xc8] COMMAND 
COMMAND_CLASS.enum[0x55].command[0xc8] = {
	name: "COMMAND_SEGMENT_REQUEST",
	help: "Segment Request",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "DatagramOffset1" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "SessionId" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "DatagramOffset2" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context) {
			let _properties1 = 0x00;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Reserved2' in context || 'DatagramOffset1' in context || 'SessionId' in context) {
			let _properties2 = 0x00;
			if (context['Reserved2']) _properties2 = _properties2 | 0x08;
			if ('DatagramOffset1' in context) _properties2 = _properties2 | ((context['DatagramOffset1']) & 0x07);
			if ('SessionId' in context) _properties2 = _properties2 | ((context['SessionId'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('DatagramOffset2' in context) payload.writeBYTE(context['DatagramOffset2']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x07); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved2'] = ((_properties2 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['DatagramOffset1'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramOffset2'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TRANSPORT_SERVICE [0x55] COMMAND_SUBSEQUENT_SEGMENT [0xe0] COMMAND 
COMMAND_CLASS.enum[0x55].command[0xe0] = {
	name: "COMMAND_SUBSEQUENT_SEGMENT",
	help: "Subsequent Segment",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "DatagramSize1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "DatagramSize2" /* BYTE */ }, 
		'0x02a': {name: "Ext" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "DatagramOffset1" /* Properties2 STRUCT_BYTE */ }, 
		'0x02c': {name: "SessionId" /* Properties2 STRUCT_BYTE */ }, 
		'0x03': {name: "DatagramOffset2" /* BYTE */ }, 
		'0x04': {name: "HeaderExtensionLength" /* BYTE */ }, 
		'0x05': {name: "HeaderExtension" /* VARIANT */ }, 
		'0x06': {name: "Payload" /* VARIANT */ }, 
		'0x07': {name: "FrameCheckSequence" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DatagramSize1' in context) {
			let _properties1 = 0x00;
			if ('DatagramSize1' in context) _properties1 = _properties1 | ((context['DatagramSize1']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DatagramSize2' in context) payload.writeBYTE(context['DatagramSize2']); else return payload.asBuffer();
		if ('Ext' in context || 'DatagramOffset1' in context || 'SessionId' in context) {
			let _properties2 = 0x00;
			if (context['Ext']) _properties2 = _properties2 | 0x08;
			if ('DatagramOffset1' in context) _properties2 = _properties2 | ((context['DatagramOffset1']) & 0x07);
			if ('SessionId' in context) _properties2 = _properties2 | ((context['SessionId'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('DatagramOffset2' in context) payload.writeBYTE(context['DatagramOffset2']); else return payload.asBuffer();
		if ((payload.at(2) & 0x08) !== 0) /* optional flag for HeaderExtensionLength */ {
			if ('HeaderExtensionLength' in context) payload.writeBYTE(context['HeaderExtensionLength']); else return payload.asBuffer();
		}
		if ((payload.at(2) & 0x08) !== 0) /* optional flag for HeaderExtension */ {
			if ('HeaderExtension' in context) payload.writeSTRING(context['HeaderExtension'], { encoding: 'hex', length: (payload.at(4) & 0xff) }); else return payload.asBuffer();
		}
		if ('Payload' in context) payload.writeSTRING(context['Payload'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('FrameCheckSequence' in context) payload.writeWORD(context['FrameCheckSequence']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DatagramSize1'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramSize2'] = payload.readBYTE(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Ext'] = ((_properties2 & 0x08) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['DatagramOffset1'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DatagramOffset2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HeaderExtensionLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HeaderExtension'] = payload.readSTRING({ encoding: 'hex', length: payload.at(4) & 0xff }); else return context;
		if (!payload.insufficientBytes(1)) context['Payload'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['FrameCheckSequence'] = payload.readWORD(); else return context;
		return context;
	}
};

// TRANSPORT_SERVICE [0x55] COMMAND_SEGMENT_COMPLETE [0xe8] COMMAND 
COMMAND_CLASS.enum[0x55].command[0xe8] = {
	name: "COMMAND_SEGMENT_COMPLETE",
	help: "Segment Complete",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "SessionId" /* Properties2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context) {
			let _properties1 = 0x00;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Reserved2' in context || 'SessionId' in context) {
			let _properties2 = 0x00;
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2']) & 0x0f);
			if ('SessionId' in context) _properties2 = _properties2 | ((context['SessionId'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x07); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// TRANSPORT_SERVICE [0x55] COMMAND_SEGMENT_WAIT [0xf0] COMMAND 
COMMAND_CLASS.enum[0x55].command[0xf0] = {
	name: "COMMAND_SEGMENT_WAIT",
	help: "Segment Wait",
	cmd_mask: 248,
	param: { 
		'0x00a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "PendingFragments" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context) {
			let _properties1 = 0x00;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PendingFragments' in context) payload.writeBYTE(context['PendingFragments']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['PendingFragments'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x56 CRC_16_ENCAP COMMANDS
 */

// CRC_16_ENCAP [0x56] CRC_16_ENCAP [0x01] COMMAND 
COMMAND_CLASS.enum[0x56].command[0x01] = {
	name: "CRC_16_ENCAP",
	help: "CRC16 Encap",
	param: { 
		'0x00': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }, 
		'0x01': {name: "zwave.Command", alias: "zwaveCommand", encaptype: "CMD_REF" /* BYTE */ }, 
		'0x02': {name: "zwave.Payload", alias: "zwavePayload", encaptype: "CMD_DATA" /* VARIANT */ }, 
		'0x03': {name: "Checksum" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		if ('zwave.Command' in context) payload.writeBYTE(context['zwave.Command']); else return payload.asBuffer();
		if ('zwave.Payload' in context) payload.writeBUFFER(context['zwave.Payload'], {}); else return payload.asBuffer();
		if ('Checksum' in context) payload.writeWORD(context['Checksum']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Command'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Payload'] = payload.readBUFFER({}); else return context;
		if (!payload.insufficientBytes(1)) context['Checksum'] = payload.readWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x57 APPLICATION_CAPABILITY COMMANDS
 */

// APPLICATION_CAPABILITY [0x57] COMMAND_COMMAND_CLASS_NOT_SUPPORTED [0x01] COMMAND 
COMMAND_CLASS.enum[0x57].command[0x01] = {
	name: "COMMAND_COMMAND_CLASS_NOT_SUPPORTED",
	help: "Command Command Class Not Supported",
	param: { 
		'0x00a': {name: "Dynamic" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }, 
		'0x02': {name: "zwave.Command", alias: "zwaveCommand", encaptype: "CMD_REF" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Dynamic' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Dynamic']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		if ('zwave.Command' in context) payload.writeBYTE(context['zwave.Command']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Dynamic'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Command'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x58 ZIP_ND COMMANDS
 */

// ZIP_ND [0x58] ZIP_NODE_ADVERTISEMENT [0x01] COMMAND 
COMMAND_CLASS.enum[0x58].command[0x01] = {
	name: "ZIP_NODE_ADVERTISEMENT",
	help: "Zip Node Advertisement",
	param: { 
		'0x00a': {name: "Validity" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Local" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x03': {name: "HomeId" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Validity' in context || 'Local' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Validity' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Validity', ENUM_ZIP_ND_ZIP_NODE_ADVERTISEMENT_VALIDITY)) & 0x03); 
			if (context['Local']) _properties1 = _properties1 | 0x04;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('HomeId' in context) payload.writeSTRING(context['HomeId'], { encoding: 'hex', length: 4 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Validity'] = helpers.lookupNameValue((_properties1 & 0x03), ENUM_ZIP_ND_ZIP_NODE_ADVERTISEMENT_VALIDITY.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Local'] = ((_properties1 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['HomeId'] = payload.readSTRING({ encoding: 'hex', length: 4 }); else return context;
		return context;
	}
};

const ENUM_ZIP_ND_ZIP_NODE_ADVERTISEMENT_VALIDITY = {
	INFORMATION_OK: 0x00, 
	INFORMATION_OBSOLETE: 0x01, 
	INFORMATION_NOT_FOUND: 0x02, 
	enum: {
		0x00: "INFORMATION_OK", 
		0x01: "INFORMATION_OBSOLETE", 
		0x02: "INFORMATION_NOT_FOUND"
	}
};

// ZIP_ND [0x58] ZIP_NODE_SOLICITATION [0x03] COMMAND 
COMMAND_CLASS.enum[0x58].command[0x03] = {
	name: "ZIP_NODE_SOLICITATION",
	help: "Zip Node Solicitation",
	param: { 
		'0x00': {name: "Reserved" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "Ipv6Address" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

// ZIP_ND [0x58] ZIP_INV_NODE_SOLICITATION [0x04] COMMAND 
COMMAND_CLASS.enum[0x58].command[0x04] = {
	name: "ZIP_INV_NODE_SOLICITATION",
	help: "Zip Inverse Node Solicitation",
	param: { 
		'0x00a': {name: "Local" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved2" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Local' in context || 'Reserved1' in context || 'Reserved2' in context) {
			let _properties1 = 0x00;
			if (context['Local']) _properties1 = _properties1 | 0x04;
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1']) & 0x03);
			if ('Reserved2' in context) _properties1 = _properties1 | ((context['Reserved2'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Local'] = ((_properties1 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x59 ASSOCIATION_GRP_INFO COMMANDS
 */

// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_NAME_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x01] = {
	name: "ASSOCIATION_GROUP_NAME_GET",
	help: "Association Group Name Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_NAME_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x02] = {
	name: "ASSOCIATION_GROUP_NAME_REPORT",
	help: "Association Group Name Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "LengthOfName" /* BYTE */ }, 
		'0x02': {name: "Name" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('LengthOfName' in context) payload.writeBYTE(context['LengthOfName']); else return payload.asBuffer();
		if ('Name' in context) payload.writeSTRING(context['Name'], { encoding: 'utf8', length: (payload.at(1) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LengthOfName'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Name'] = payload.readSTRING({ encoding: 'utf8', length: payload.at(1) & 0xff }); else return context;
		return context;
	}
};

// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_INFO_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x03] = {
	name: "ASSOCIATION_GROUP_INFO_GET",
	help: "Association Group Info Get",
	param: { 
		'0x00a': {name: "ListMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RefreshCache" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ListMode' in context || 'RefreshCache' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['ListMode']) _properties1 = _properties1 | 0x40;
			if (context['RefreshCache']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ListMode'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RefreshCache'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_INFO_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x04] = {
	name: "ASSOCIATION_GROUP_INFO_REPORT",
	help: "Association Group Info Report",
	param: { 
		'0x00a': {name: "DynamicInfo" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "ListMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "GroupCount" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "GroupingIdentifier" /* BYTE */ },
				'0x01-0x01': {name: "Mode" /* BYTE */ },
				'0x01-0x02': {name: "Profile1" /* CONST */ },
				'0x01-0x03': {name: "Profile2" /* MULTI_ARRAY */ },
				'0x01-0x04': {name: "Reserved" /* BYTE */ },
				'0x01-0x05': {name: "EventCode" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DynamicInfo' in context || 'ListMode' in context || 'GroupCount' in context) {
			let _properties1 = 0x00;
			if (context['DynamicInfo']) _properties1 = _properties1 | 0x40;
			if (context['ListMode']) _properties1 = _properties1 | 0x80;
			if ('GroupCount' in context) _properties1 = _properties1 | ((context['GroupCount']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0) & 0x3f)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
				if ('Mode' in context) payload.writeBYTE(context['Mode']); else return payload.asBuffer();
				if ('Profile1' in context) payload.writeBYTE(helpers.getValue(context, 'Profile1', ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE1)); else return payload.asBuffer();
				if ('Profile2' in context) payload.writeBYTE(helpers.getValue(context, 'Profile2', MULTI_ARRAY_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_REPORT_PROFILE2[payload.at(3)])); else return payload.asBuffer();
				if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
				if ('EventCode' in context) payload.writeWORD(context['EventCode']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DynamicInfo'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ListMode'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['GroupCount'] = (_properties1 & 0x3f); else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(0) & 0x3f; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Mode'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Profile1'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE1.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Profile2'] = helpers.lookupNameValue(payload.readBYTE(), MULTI_ARRAY_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_REPORT_PROFILE2[payload.at(3)].enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['EventCode'] = payload.readWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE1 = {
	ProfileGeneral: 0x00, 
	ProfileControl: 0x20, 
	ProfileSensor: 0x31, 
	ProfileMeter: 0x32, 
	ProfileIrrigation: 0x6b, 
	ProfileNotification: 0x71, 
	enum: {
		0x00: "ProfileGeneral", 
		0x20: "ProfileControl", 
		0x31: "ProfileSensor", 
		0x32: "ProfileMeter", 
		0x6b: "ProfileIrrigation", 
		0x71: "ProfileNotification"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_GENERAL = {
	ProfileGeneralNa: 0x00, 
	ProfileGeneralLifeline: 0x01, 
	enum: {
		0x00: "ProfileGeneralNa", 
		0x01: "ProfileGeneralLifeline"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_CONTROL = {
	ProfileControlKey01: 0x01, 
	ProfileControlKey02: 0x02, 
	ProfileControlKey03: 0x03, 
	ProfileControlKey04: 0x04, 
	ProfileControlKey05: 0x05, 
	ProfileControlKey06: 0x06, 
	ProfileControlKey07: 0x07, 
	ProfileControlKey08: 0x08, 
	ProfileControlKey09: 0x09, 
	ProfileControlKey10: 0x0a, 
	ProfileControlKey11: 0x0b, 
	ProfileControlKey12: 0x0c, 
	ProfileControlKey13: 0x0d, 
	ProfileControlKey14: 0x0e, 
	ProfileControlKey15: 0x0f, 
	ProfileControlKey16: 0x10, 
	ProfileControlKey17: 0x11, 
	ProfileControlKey18: 0x12, 
	ProfileControlKey19: 0x13, 
	ProfileControlKey20: 0x14, 
	ProfileControlKey21: 0x15, 
	ProfileControlKey22: 0x16, 
	ProfileControlKey23: 0x17, 
	ProfileControlKey24: 0x18, 
	ProfileControlKey25: 0x19, 
	ProfileControlKey26: 0x1a, 
	ProfileControlKey27: 0x1b, 
	ProfileControlKey28: 0x1c, 
	ProfileControlKey29: 0x1d, 
	ProfileControlKey30: 0x1e, 
	ProfileControlKey31: 0x1f, 
	ProfileControlKey32: 0x20, 
	enum: {
		0x01: "ProfileControlKey01", 
		0x02: "ProfileControlKey02", 
		0x03: "ProfileControlKey03", 
		0x04: "ProfileControlKey04", 
		0x05: "ProfileControlKey05", 
		0x06: "ProfileControlKey06", 
		0x07: "ProfileControlKey07", 
		0x08: "ProfileControlKey08", 
		0x09: "ProfileControlKey09", 
		0x0a: "ProfileControlKey10", 
		0x0b: "ProfileControlKey11", 
		0x0c: "ProfileControlKey12", 
		0x0d: "ProfileControlKey13", 
		0x0e: "ProfileControlKey14", 
		0x0f: "ProfileControlKey15", 
		0x10: "ProfileControlKey16", 
		0x11: "ProfileControlKey17", 
		0x12: "ProfileControlKey18", 
		0x13: "ProfileControlKey19", 
		0x14: "ProfileControlKey20", 
		0x15: "ProfileControlKey21", 
		0x16: "ProfileControlKey22", 
		0x17: "ProfileControlKey23", 
		0x18: "ProfileControlKey24", 
		0x19: "ProfileControlKey25", 
		0x1a: "ProfileControlKey26", 
		0x1b: "ProfileControlKey27", 
		0x1c: "ProfileControlKey28", 
		0x1d: "ProfileControlKey29", 
		0x1e: "ProfileControlKey30", 
		0x1f: "ProfileControlKey31", 
		0x20: "ProfileControlKey32"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_SENSOR = {
	ProfilemultilevelSensorTypeTemperature: 0x01, 
	ProfilemultilevelSensorTypeHumidity: 0x05, 
	enum: {
		0x01: "ProfilemultilevelSensorTypeTemperature", 
		0x05: "ProfilemultilevelSensorTypeHumidity"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_NOTIFICATION = {
	ProfilenotificationTypeSmoke: 0x01, 
	ProfilenotificationTypeCo2: 0x03, 
	enum: {
		0x01: "ProfilenotificationTypeSmoke", 
		0x03: "ProfilenotificationTypeCo2"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_METER = {
	ProfilemeterTypeElectric: 0x01, 
	ProfilemeterTypeGas: 0x02, 
	ProfilemeterTypeWater: 0x03, 
	enum: {
		0x01: "ProfilemeterTypeElectric", 
		0x02: "ProfilemeterTypeGas", 
		0x03: "ProfilemeterTypeWater"
	}
};

const ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_IRRIGATION = {
	IrrigationChannel01: 0x01, 
	IrrigationChannel02: 0x02, 
	IrrigationChannel03: 0x03, 
	IrrigationChannel04: 0x04, 
	IrrigationChannel05: 0x05, 
	IrrigationChannel06: 0x06, 
	IrrigationChannel07: 0x07, 
	IrrigationChannel08: 0x08, 
	IrrigationChannel09: 0x09, 
	IrrigationChannel10: 0x0a, 
	IrrigationChannel11: 0x0b, 
	IrrigationChannel12: 0x0c, 
	IrrigationChannel13: 0x0d, 
	IrrigationChannel14: 0x0e, 
	IrrigationChannel15: 0x0f, 
	IrrigationChannel16: 0x10, 
	IrrigationChannel17: 0x11, 
	IrrigationChannel18: 0x12, 
	IrrigationChannel19: 0x13, 
	IrrigationChannel20: 0x14, 
	IrrigationChannel21: 0x15, 
	IrrigationChannel22: 0x16, 
	IrrigationChannel23: 0x17, 
	IrrigationChannel24: 0x18, 
	IrrigationChannel25: 0x19, 
	IrrigationChannel26: 0x1a, 
	IrrigationChannel27: 0x1b, 
	IrrigationChannel28: 0x1c, 
	IrrigationChannel29: 0x1d, 
	IrrigationChannel30: 0x1e, 
	IrrigationChannel31: 0x1f, 
	IrrigationChannel32: 0x20, 
	enum: {
		0x01: "IrrigationChannel01", 
		0x02: "IrrigationChannel02", 
		0x03: "IrrigationChannel03", 
		0x04: "IrrigationChannel04", 
		0x05: "IrrigationChannel05", 
		0x06: "IrrigationChannel06", 
		0x07: "IrrigationChannel07", 
		0x08: "IrrigationChannel08", 
		0x09: "IrrigationChannel09", 
		0x0a: "IrrigationChannel10", 
		0x0b: "IrrigationChannel11", 
		0x0c: "IrrigationChannel12", 
		0x0d: "IrrigationChannel13", 
		0x0e: "IrrigationChannel14", 
		0x0f: "IrrigationChannel15", 
		0x10: "IrrigationChannel16", 
		0x11: "IrrigationChannel17", 
		0x12: "IrrigationChannel18", 
		0x13: "IrrigationChannel19", 
		0x14: "IrrigationChannel20", 
		0x15: "IrrigationChannel21", 
		0x16: "IrrigationChannel22", 
		0x17: "IrrigationChannel23", 
		0x18: "IrrigationChannel24", 
		0x19: "IrrigationChannel25", 
		0x1a: "IrrigationChannel26", 
		0x1b: "IrrigationChannel27", 
		0x1c: "IrrigationChannel28", 
		0x1d: "IrrigationChannel29", 
		0x1e: "IrrigationChannel30", 
		0x1f: "IrrigationChannel31", 
		0x20: "IrrigationChannel32"
	}
};

const MULTI_ARRAY_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_REPORT_PROFILE2 = {
	0x00: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_GENERAL,
	0x20: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_CONTROL,
	0x31: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_SENSOR,
	0x32: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_METER,
	0x6b: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_IRRIGATION,
	0x71: ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_NOTIFICATION
};
// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_COMMAND_LIST_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x05] = {
	name: "ASSOCIATION_GROUP_COMMAND_LIST_GET",
	help: "Association Group Command List Get",
	param: { 
		'0x00a': {name: "AllowCache" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('AllowCache' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['AllowCache']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['AllowCache'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION_GRP_INFO [0x59] ASSOCIATION_GROUP_COMMAND_LIST_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x59].command[0x06] = {
	name: "ASSOCIATION_GROUP_COMMAND_LIST_REPORT",
	help: "Association Group Command List Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "ListLength" /* BYTE */ }, 
		'0x02': {name: "Command" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('ListLength' in context) payload.writeBYTE(context['ListLength']); else return payload.asBuffer();
		if ('Command' in context) payload.writeSTRING(context['Command'], { encoding: 'hex', length: (payload.at(1) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ListLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Command'] = payload.readSTRING({ encoding: 'hex', length: payload.at(1) & 0xff }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x5a DEVICE_RESET_LOCALLY COMMANDS
 */

// DEVICE_RESET_LOCALLY [0x5a] NOTIFICATION [0x01] COMMAND 
COMMAND_CLASS.enum[0x5a].command[0x01] = {
	name: "NOTIFICATION",
	help: "Device Reset Locally Notification",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x5b CENTRAL_SCENE COMMANDS
 */

// CENTRAL_SCENE [0x5b] SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x01] = {
	name: "SUPPORTED_GET",
	help: "Central Scene Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CENTRAL_SCENE [0x5b] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Central Scene Supported Report",
	param: { 
		'0x00': {name: "SupportedScenes" /* BYTE */ }, 
		'0x01a': {name: "Identical" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SlowRefreshSupport" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "NumberOfBitMaskBytes" /* Properties1 STRUCT_BYTE */ }, 
		'0x01d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x02-0x00-0': {name: "KeyPressed1Time" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-1': {name: "KeyReleased" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-2': {name: "KeyHeldDown" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-3': {name: "KeyPressed2Times" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-4': {name: "KeyPressed3Times" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-5': {name: "KeyPressed4Times" /* SupportedKeyAttributesForScene BITMASK */ },
				'0x02-0x00-6': {name: "KeyPressed5Times" /* SupportedKeyAttributesForScene BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedScenes' in context) payload.writeBYTE(context['SupportedScenes']); else return payload.asBuffer();
		if ('Identical' in context || 'SlowRefreshSupport' in context || 'NumberOfBitMaskBytes' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Identical']) _properties1 = _properties1 | 0x01;
			if (context['SlowRefreshSupport']) _properties1 = _properties1 | 0x80;
			if ('NumberOfBitMaskBytes' in context) _properties1 = _properties1 | ((context['NumberOfBitMaskBytes'] << 1) & 0x06);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0x78);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE), {length: 7});
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedScenes'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Identical'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SlowRefreshSupport'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfBitMaskBytes'] = (_properties1 & 0x06) >> 1; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x78) >> 3; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			helpers.setNameFlags(context, payload.readBITMASK({length: 7}), ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE.enum);
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

const ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE = {
	KeyPressed1Time: 0x00, 
	KeyReleased: 0x01, 
	KeyHeldDown: 0x02, 
	KeyPressed2Times: 0x03, 
	KeyPressed3Times: 0x04, 
	KeyPressed4Times: 0x05, 
	KeyPressed5Times: 0x06, 
	enum: {
		0x00: "KeyPressed1Time", 
		0x01: "KeyReleased", 
		0x02: "KeyHeldDown", 
		0x03: "KeyPressed2Times", 
		0x04: "KeyPressed3Times", 
		0x05: "KeyPressed4Times", 
		0x06: "KeyPressed5Times"
	}
};

// CENTRAL_SCENE [0x5b] NOTIFICATION [0x03] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x03] = {
	name: "NOTIFICATION",
	help: "Central Scene Notification",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "KeyAttributes" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SlowRefresh" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "SceneNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('KeyAttributes' in context || 'SlowRefresh' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('KeyAttributes' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'KeyAttributes', ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE)) & 0x07); 
			if (context['SlowRefresh']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0x78);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SceneNumber' in context) payload.writeBYTE(context['SceneNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['KeyAttributes'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['SlowRefresh'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x78) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SceneNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CENTRAL_SCENE [0x5b] CONFIGURATION_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x04] = {
	name: "CONFIGURATION_SET",
	help: "Central Scene Configuration Set",
	param: { 
		'0x00a': {name: "SlowRefresh" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SlowRefresh' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['SlowRefresh']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SlowRefresh'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};

// CENTRAL_SCENE [0x5b] CONFIGURATION_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x05] = {
	name: "CONFIGURATION_GET",
	help: "Central Scene Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CENTRAL_SCENE [0x5b] CONFIGURATION_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x5b].command[0x06] = {
	name: "CONFIGURATION_REPORT",
	help: "Central Scene Configuration Report",
	param: { 
		'0x00a': {name: "SlowRefresh" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SlowRefresh' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['SlowRefresh']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SlowRefresh'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x5c IP_ASSOCIATION COMMANDS
 */

// IP_ASSOCIATION [0x5c] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x5c].command[0x01] = {
	name: "SET",
	help: "IP Association Set",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x02': {name: "EndPoint" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('EndPoint' in context) payload.writeBYTE(context['EndPoint']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['EndPoint'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IP_ASSOCIATION [0x5c] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x5c].command[0x02] = {
	name: "GET",
	help: "IP Association Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "Index" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('Index' in context) payload.writeBYTE(context['Index']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Index'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IP_ASSOCIATION [0x5c] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x5c].command[0x03] = {
	name: "REPORT",
	help: "IP Association Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "Index" /* BYTE */ }, 
		'0x02': {name: "ActualNodes" /* BYTE */ }, 
		'0x03': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x04': {name: "EndPoint" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('Index' in context) payload.writeBYTE(context['Index']); else return payload.asBuffer();
		if ('ActualNodes' in context) payload.writeBYTE(context['ActualNodes']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('EndPoint' in context) payload.writeBYTE(context['EndPoint']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Index'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ActualNodes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['EndPoint'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IP_ASSOCIATION [0x5c] REMOVE [0x04] COMMAND 
COMMAND_CLASS.enum[0x5c].command[0x04] = {
	name: "REMOVE",
	help: "IP Association Remove",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x02': {name: "EndPoint" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('EndPoint' in context) payload.writeBYTE(context['EndPoint']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['EndPoint'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x5d ANTITHEFT COMMANDS
 */

// ANTITHEFT [0x5d] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x5d].command[0x01] = {
	name: "SET",
	help: "Anti-theft Set",
	param: { 
		'0x00a': {name: "Enable" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "NumberOfMagicCodeBytes" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "MagicCode" /* VARIANT */ }, 
		'0x02': {name: "ManufacturerId" /* WORD */ }, 
		'0x03': {name: "AntitheftHintNumberBytes" /* BYTE */ }, 
		'0x04': {name: "AntitheftHintByte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Enable' in context || 'NumberOfMagicCodeBytes' in context) {
			let _properties1 = 0x00;
			if (context['Enable']) _properties1 = _properties1 | 0x80;
			if ('NumberOfMagicCodeBytes' in context) _properties1 = _properties1 | ((context['NumberOfMagicCodeBytes']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MagicCode' in context) payload.writeSTRING(context['MagicCode'], { encoding: 'hex', length: (payload.at(0) & 0x7f) }); else return payload.asBuffer();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('AntitheftHintNumberBytes' in context) payload.writeBYTE(context['AntitheftHintNumberBytes']); else return payload.asBuffer();
		if ('AntitheftHintByte' in context) payload.writeSTRING(context['AntitheftHintByte'], { encoding: 'hex', length: (payload.at(3) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Enable'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfMagicCodeBytes'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MagicCode'] = payload.readSTRING({ encoding: 'hex', length: payload.at(0) & 0x7f }); else return context;
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['AntitheftHintNumberBytes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AntitheftHintByte'] = payload.readSTRING({ encoding: 'hex', length: payload.at(3) & 0xff }); else return context;
		return context;
	}
};

// ANTITHEFT [0x5d] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x5d].command[0x02] = {
	name: "GET",
	help: "Anti-theft Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ANTITHEFT [0x5d] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x5d].command[0x03] = {
	name: "REPORT",
	help: "Anti-theft Report",
	param: { 
		'0x00': {name: "AntitheftProtectionStatus" /* BYTE */ }, 
		'0x01': {name: "ManufacturerId" /* WORD */ }, 
		'0x02': {name: "AntitheftHintNumberBytes" /* BYTE */ }, 
		'0x03': {name: "AntitheftHintByte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('AntitheftProtectionStatus' in context) payload.writeBYTE(context['AntitheftProtectionStatus']); else return payload.asBuffer();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('AntitheftHintNumberBytes' in context) payload.writeBYTE(context['AntitheftHintNumberBytes']); else return payload.asBuffer();
		if ('AntitheftHintByte' in context) payload.writeSTRING(context['AntitheftHintByte'], { encoding: 'hex', length: (payload.at(2) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['AntitheftProtectionStatus'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['AntitheftHintNumberBytes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AntitheftHintByte'] = payload.readSTRING({ encoding: 'hex', length: payload.at(2) & 0xff }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x5e ZWAVEPLUS_INFO COMMANDS
 */

// ZWAVEPLUS_INFO [0x5e] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x5e].command[0x01] = {
	name: "GET",
	help: "Z-Wave+ Info Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZWAVEPLUS_INFO [0x5e] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x5e].command[0x02] = {
	name: "REPORT",
	help: "Z-Wave+ Info Report",
	param: { 
		'0x00': {name: "Version" /* BYTE */ }, 
		'0x01': {name: "RoleType" /* CONST */ }, 
		'0x02': {name: "NodeType" /* CONST */ }, 
		'0x03': {name: "InstallerIconType" /* WORD */ }, 
		'0x04': {name: "UserIconType" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Version' in context) payload.writeBYTE(context['Version']); else return payload.asBuffer();
		if ('RoleType' in context) payload.writeBYTE(helpers.getValue(context, 'RoleType', ENUM_ZWAVEPLUS_INFO_ROLE_TYPE)); else return payload.asBuffer();
		if ('NodeType' in context) payload.writeBYTE(helpers.getValue(context, 'NodeType', ENUM_ZWAVEPLUS_INFO_NODE_TYPE)); else return payload.asBuffer();
		if ('InstallerIconType' in context) payload.writeWORD(context['InstallerIconType']); else return payload.asBuffer();
		if ('UserIconType' in context) payload.writeWORD(context['UserIconType']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Version'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['RoleType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ZWAVEPLUS_INFO_ROLE_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NodeType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ZWAVEPLUS_INFO_NODE_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['InstallerIconType'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['UserIconType'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_ZWAVEPLUS_INFO_ROLE_TYPE = {
	RoleTypeControllerCentralStatic: 0x00, 
	RoleTypeControllerSubStatic: 0x01, 
	RoleTypeControllerPortable: 0x02, 
	RoleTypeControllerPortableReporting: 0x03, 
	RoleTypeSlavePortable: 0x04, 
	RoleTypeSlaveAlwaysOn: 0x05, 
	RoleTypeSlaveSleepingReporting: 0x06, 
	RoleTypeSlaveSleepingListening: 0x07, 
	enum: {
		0x00: "RoleTypeControllerCentralStatic", 
		0x01: "RoleTypeControllerSubStatic", 
		0x02: "RoleTypeControllerPortable", 
		0x03: "RoleTypeControllerPortableReporting", 
		0x04: "RoleTypeSlavePortable", 
		0x05: "RoleTypeSlaveAlwaysOn", 
		0x06: "RoleTypeSlaveSleepingReporting", 
		0x07: "RoleTypeSlaveSleepingListening"
	}
};

const ENUM_ZWAVEPLUS_INFO_NODE_TYPE = {
	NodeTypeZwaveplusNode: 0x00, 
	NodeTypeZwaveplusForIpGateway: 0x02, 
	enum: {
		0x00: "NodeTypeZwaveplusNode", 
		0x02: "NodeTypeZwaveplusForIpGateway"
	}
};



/*
 * COMMAND_CLASS 0x5f ZIP_GATEWAY COMMANDS
 */

// ZIP_GATEWAY [0x5f] GATEWAY_MODE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x01] = {
	name: "GATEWAY_MODE_SET",
	help: "Gateway Mode Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_ZIP_GATEWAY_GATEWAY_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ZIP_GATEWAY_GATEWAY_MODE.enum); else return context;
		return context;
	}
};

const ENUM_ZIP_GATEWAY_GATEWAY_MODE = {
	Standalone: 0x01, 
	Portal: 0x02, 
	enum: {
		0x01: "Standalone", 
		0x02: "Portal"
	}
};

// ZIP_GATEWAY [0x5f] GATEWAY_MODE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x02] = {
	name: "GATEWAY_MODE_GET",
	help: "Gateway Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_GATEWAY [0x5f] GATEWAY_MODE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x03] = {
	name: "GATEWAY_MODE_REPORT",
	help: "Gateway Mode Report",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_ZIP_GATEWAY_GATEWAY_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ZIP_GATEWAY_GATEWAY_MODE.enum); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] GATEWAY_PEER_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x04] = {
	name: "GATEWAY_PEER_SET",
	help: "Gateway Peer Set",
	param: { 
		'0x00': {name: "PeerProfile" /* BYTE */ }, 
		'0x01': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x02': {name: "Port" /* WORD */ }, 
		'0x03a': {name: "PeerNameLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x03b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x04': {name: "PeerName" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PeerProfile' in context) payload.writeBYTE(context['PeerProfile']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('Port' in context) payload.writeWORD(context['Port']); else return payload.asBuffer();
		if ('PeerNameLength' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('PeerNameLength' in context) _properties1 = _properties1 | ((context['PeerNameLength']) & 0x3f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PeerName' in context) payload.writeSTRING(context['PeerName'], { encoding: 'utf8', length: (payload.at(3) & 0x3f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PeerProfile'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['Port'] = payload.readWORD(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PeerNameLength'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['PeerName'] = payload.readSTRING({ encoding: 'utf8', length: payload.at(3) & 0x3f }); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] GATEWAY_PEER_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x05] = {
	name: "GATEWAY_PEER_GET",
	help: "Gateway Peer Get",
	param: { 
		'0x00': {name: "PeerProfile" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PeerProfile' in context) payload.writeBYTE(context['PeerProfile']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PeerProfile'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] GATEWAY_PEER_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x06] = {
	name: "GATEWAY_PEER_REPORT",
	help: "Gateway Peer Report",
	param: { 
		'0x00': {name: "PeerProfile" /* BYTE */ }, 
		'0x01': {name: "PeerCount" /* BYTE */ }, 
		'0x02': {name: "Ipv6Address" /* ARRAY */ }, 
		'0x03': {name: "Port" /* WORD */ }, 
		'0x04a': {name: "PeerNameLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x04b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x05': {name: "PeerName" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PeerProfile' in context) payload.writeBYTE(context['PeerProfile']); else return payload.asBuffer();
		if ('PeerCount' in context) payload.writeBYTE(context['PeerCount']); else return payload.asBuffer();
		if ('Ipv6Address' in context) payload.writeSTRING(context['Ipv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('Port' in context) payload.writeWORD(context['Port']); else return payload.asBuffer();
		if ('PeerNameLength' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('PeerNameLength' in context) _properties1 = _properties1 | ((context['PeerNameLength']) & 0x3f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('PeerName' in context) payload.writeSTRING(context['PeerName'], { encoding: 'utf8', length: (payload.at(4) & 0x3f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PeerProfile'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['PeerCount'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Ipv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['Port'] = payload.readWORD(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PeerNameLength'] = (_properties1 & 0x3f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['PeerName'] = payload.readSTRING({ encoding: 'utf8', length: payload.at(4) & 0x3f }); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] GATEWAY_LOCK_SET [0x07] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x07] = {
	name: "GATEWAY_LOCK_SET",
	help: "Gateway Lock Set",
	param: { 
		'0x00a': {name: "Lock" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Show" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Lock' in context || 'Show' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Lock']) _properties1 = _properties1 | 0x01;
			if (context['Show']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Lock'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Show'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		return context;
	}
};

// ZIP_GATEWAY [0x5f] UNSOLICITED_DESTINATION_SET [0x08] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x08] = {
	name: "UNSOLICITED_DESTINATION_SET",
	help: "Unsolicited Destination Set ",
	param: { 
		'0x00': {name: "UnsolicitedIpv6Destination" /* ARRAY */ }, 
		'0x01': {name: "UnsolicitedDestinationPort" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UnsolicitedIpv6Destination' in context) payload.writeSTRING(context['UnsolicitedIpv6Destination'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('UnsolicitedDestinationPort' in context) payload.writeWORD(context['UnsolicitedDestinationPort']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UnsolicitedIpv6Destination'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['UnsolicitedDestinationPort'] = payload.readWORD(); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] UNSOLICITED_DESTINATION_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x09] = {
	name: "UNSOLICITED_DESTINATION_GET",
	help: "Unsolicited Destination Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_GATEWAY [0x5f] UNSOLICITED_DESTINATION_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x0a] = {
	name: "UNSOLICITED_DESTINATION_REPORT",
	help: "Unsolicited Destination Report",
	param: { 
		'0x00': {name: "UnsolicitedIpv6Destination" /* ARRAY */ }, 
		'0x01': {name: "UnsolicitedDestinationPort" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UnsolicitedIpv6Destination' in context) payload.writeSTRING(context['UnsolicitedIpv6Destination'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('UnsolicitedDestinationPort' in context) payload.writeWORD(context['UnsolicitedDestinationPort']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UnsolicitedIpv6Destination'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['UnsolicitedDestinationPort'] = payload.readWORD(); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] COMMAND_APPLICATION_NODE_INFO_SET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x0b] = {
	name: "COMMAND_APPLICATION_NODE_INFO_SET",
	help: "Application Node Info Set",
	param: { 
		'0x00': {name: "NonsecureCommandClass" /* VARIANT */ }, 
		'0x01': null /* MARKER SecurityScheme0Mark handled by VARIANT */, 
		'0x02': {name: "SecurityScheme0CommandClass" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NonsecureCommandClass' in context) payload.writeSTRINGtoMARKER(context['NonsecureCommandClass'], { encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return payload.asBuffer();
		if ('SecurityScheme0CommandClass' in context) payload.writeSTRING(context['SecurityScheme0CommandClass'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NonsecureCommandClass'] = payload.readSTRINGtoMARKER({ encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return context;
		if (!payload.insufficientBytes(1)) context['SecurityScheme0CommandClass'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// ZIP_GATEWAY [0x5f] COMMAND_APPLICATION_NODE_INFO_GET [0x0c] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x0c] = {
	name: "COMMAND_APPLICATION_NODE_INFO_GET",
	help: "Application Node Info Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_GATEWAY [0x5f] COMMAND_APPLICATION_NODE_INFO_REPORT [0x0d] COMMAND 
COMMAND_CLASS.enum[0x5f].command[0x0d] = {
	name: "COMMAND_APPLICATION_NODE_INFO_REPORT",
	help: "Application Node Info Report",
	param: { 
		'0x00': {name: "NonsecureCommandClass" /* VARIANT */ }, 
		'0x01': null /* MARKER SecurityScheme0Mark handled by VARIANT */, 
		'0x02': {name: "SecurityScheme0CommandClass" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NonsecureCommandClass' in context) payload.writeSTRINGtoMARKER(context['NonsecureCommandClass'], { encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return payload.asBuffer();
		if ('SecurityScheme0CommandClass' in context) payload.writeSTRING(context['SecurityScheme0CommandClass'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NonsecureCommandClass'] = payload.readSTRINGtoMARKER({ encoding: 'hex', marker: [ 0x00, 0xf1 ] }); else return context;
		if (!payload.insufficientBytes(1)) context['SecurityScheme0CommandClass'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x60 MULTI_CHANNEL COMMANDS
 */

// MULTI_CHANNEL [0x60] MULTI_INSTANCE_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x04] = {
	name: "MULTI_INSTANCE_GET",
	help: "Multi Instance Get",
	param: { 
		'0x00': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] MULTI_INSTANCE_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x05] = {
	name: "MULTI_INSTANCE_REPORT",
	help: "Multi Instance Report",
	param: { 
		'0x00': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }, 
		'0x01a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Instances" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		if ('Res' in context || 'Instances' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('Instances' in context) _properties1 = _properties1 | ((context['Instances']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Instances'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};

// MULTI_CHANNEL [0x60] MULTI_INSTANCE_CMD_ENCAP [0x06] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x06] = {
	name: "MULTI_INSTANCE_CMD_ENCAP",
	help: "Multi Instance Cmd Encap",
	param: { 
		'0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Instance" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }, 
		'0x02': {name: "zwave.Command", alias: "zwaveCommand", encaptype: "CMD_REF" /* BYTE */ }, 
		'0x03': {name: "zwave.Payload", alias: "zwavePayload", encaptype: "CMD_DATA" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Res' in context || 'Instance' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('Instance' in context) _properties1 = _properties1 | ((context['Instance']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		if ('zwave.Command' in context) payload.writeBYTE(context['zwave.Command']); else return payload.asBuffer();
		if ('zwave.Payload' in context) payload.writeBUFFER(context['zwave.Payload'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Instance'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Command'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Payload'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] END_POINT_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x07] = {
	name: "END_POINT_GET",
	help: "Multi Channel End Point Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// MULTI_CHANNEL [0x60] END_POINT_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x08] = {
	name: "END_POINT_REPORT",
	help: "Multi Channel End Point Report",
	param: { 
		'0x00a': {name: "Identical" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Dynamic" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Res1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Res2" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "IndividualEndPoints" /* Properties2 STRUCT_BYTE */ }, 
		'0x02a': {name: "Res3" /* Properties3 STRUCT_BYTE */ }, 
		'0x02b': {name: "AggregatedEndPoints" /* Properties3 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Identical' in context || 'Dynamic' in context || 'Res1' in context) {
			let _properties1 = 0x00;
			if (context['Identical']) _properties1 = _properties1 | 0x40;
			if (context['Dynamic']) _properties1 = _properties1 | 0x80;
			if ('Res1' in context) _properties1 = _properties1 | ((context['Res1']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Res2' in context || 'IndividualEndPoints' in context) {
			let _properties2 = 0x00;
			if (context['Res2']) _properties2 = _properties2 | 0x80;
			if ('IndividualEndPoints' in context) _properties2 = _properties2 | ((context['IndividualEndPoints']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Res3' in context || 'AggregatedEndPoints' in context) {
			let _properties3 = 0x00;
			if (context['Res3']) _properties3 = _properties3 | 0x80;
			if ('AggregatedEndPoints' in context) _properties3 = _properties3 | ((context['AggregatedEndPoints']) & 0x7f);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Identical'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Dynamic'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Res1'] = (_properties1 & 0x3f); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res2'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['IndividualEndPoints'] = (_properties2 & 0x7f); else return context;
		}
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res3'] = ((_properties3 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AggregatedEndPoints'] = (_properties3 & 0x7f); else return context;
		}
		return context;
	}
};

// MULTI_CHANNEL [0x60] CAPABILITY_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x09] = {
	name: "CAPABILITY_GET",
	help: "Multi Channel Capability Get",
	param: { 
		'0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Res' in context || 'EndPoint' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};

// MULTI_CHANNEL [0x60] CAPABILITY_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0a] = {
	name: "CAPABILITY_REPORT",
	help: "Multi Channel Capability Report",
	param: { 
		'0x00a': {name: "Dynamic" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "zwave.GenericDevice", alias: "zwaveGenericDevice", encaptype: "GEN_DEV_REF" /* BYTE */ }, 
		'0x02': {name: "zwave.SpecificDevice", alias: "zwaveSpecificDevice", encaptype: "SPEC_DEV_REF" /* BYTE */ }, 
		'0x03': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Dynamic' in context || 'EndPoint' in context) {
			let _properties1 = 0x00;
			if (context['Dynamic']) _properties1 = _properties1 | 0x80;
			if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('zwave.GenericDevice' in context) payload.writeBYTE(context['zwave.GenericDevice']); else return payload.asBuffer();
		if ('zwave.SpecificDevice' in context) payload.writeBYTE(context['zwave.SpecificDevice']); else return payload.asBuffer();
		if ('zwave.CommandClass' in context) payload.writeBUFFER(context['zwave.CommandClass'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Dynamic'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.GenericDevice'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.SpecificDevice'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] END_POINT_FIND [0x0b] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0b] = {
	name: "END_POINT_FIND",
	help: "Multi Channel End Point Find",
	param: { 
		'0x00': {name: "zwave.GenericDevice", alias: "zwaveGenericDevice", encaptype: "GEN_DEV_REF" /* BYTE */ }, 
		'0x01': {name: "zwave.SpecificDevice", alias: "zwaveSpecificDevice", encaptype: "SPEC_DEV_REF" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.GenericDevice' in context) payload.writeBYTE(context['zwave.GenericDevice']); else return payload.asBuffer();
		if ('zwave.SpecificDevice' in context) payload.writeBYTE(context['zwave.SpecificDevice']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.GenericDevice'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.SpecificDevice'] = payload.readBYTE(); else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] END_POINT_FIND_REPORT [0x0c] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0c] = {
	name: "END_POINT_FIND_REPORT",
	help: "Multi Channel End Point Find Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "zwave.GenericDevice", alias: "zwaveGenericDevice", encaptype: "GEN_DEV_REF" /* BYTE */ }, 
		'0x02': {name: "zwave.SpecificDevice", alias: "zwaveSpecificDevice", encaptype: "SPEC_DEV_REF" /* BYTE */ }, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ },
				'0x03-0x00b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('zwave.GenericDevice' in context) payload.writeBYTE(context['zwave.GenericDevice']); else return payload.asBuffer();
		if ('zwave.SpecificDevice' in context) payload.writeBYTE(context['zwave.SpecificDevice']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Res' in context || 'EndPoint' in context) {
					let _properties1 = 0x00;
					if (context['Res']) _properties1 = _properties1 | 0x80;
					if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.GenericDevice'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.SpecificDevice'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(0); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
			}
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] ENCAP [0x0d] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0d] = {
	name: "ENCAP",
	help: "Multi Channel Command Encapsulation",
	param: { 
		'0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "SourceEndPoint" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "BitAddress" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "DestinationEndPoint" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ }, 
		'0x03': {name: "zwave.Command", alias: "zwaveCommand", encaptype: "CMD_REF" /* BYTE */ }, 
		'0x04': {name: "zwave.Payload", alias: "zwavePayload", encaptype: "CMD_DATA" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Res' in context || 'SourceEndPoint' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('SourceEndPoint' in context) _properties1 = _properties1 | ((context['SourceEndPoint']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('BitAddress' in context || 'DestinationEndPoint' in context) {
			let _properties2 = 0x00;
			if (context['BitAddress']) _properties2 = _properties2 | 0x80;
			if ('DestinationEndPoint' in context) _properties2 = _properties2 | ((context['DestinationEndPoint']) & 0x7f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
		if ('zwave.Command' in context) payload.writeBYTE(context['zwave.Command']); else return payload.asBuffer();
		if ('zwave.Payload' in context) payload.writeBUFFER(context['zwave.Payload'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SourceEndPoint'] = (_properties1 & 0x7f); else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['BitAddress'] = ((_properties2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['DestinationEndPoint'] = (_properties2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Command'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.Payload'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// MULTI_CHANNEL [0x60] AGGREGATED_MEMBERS_GET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0e] = {
	name: "AGGREGATED_MEMBERS_GET",
	help: "Multi Channel Aggregated Members Get",
	param: { 
		'0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "AggregatedEndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Res' in context || 'AggregatedEndPoint' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('AggregatedEndPoint' in context) _properties1 = _properties1 | ((context['AggregatedEndPoint']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AggregatedEndPoint'] = (_properties1 & 0x7f); else return context;
		}
		return context;
	}
};

// MULTI_CHANNEL [0x60] AGGREGATED_MEMBERS_REPORT [0x0f] COMMAND 
COMMAND_CLASS.enum[0x60].command[0x0f] = {
	name: "AGGREGATED_MEMBERS_REPORT",
	help: "Multi Channel Aggregated Members Report",
	param: { 
		'0x00a': {name: "Res" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "AggregatedEndPoint" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "NumberOfBitMasks" /* BYTE */ }, 
		'0x02': {name: "AggregatedMembersBitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Res' in context || 'AggregatedEndPoint' in context) {
			let _properties1 = 0x00;
			if (context['Res']) _properties1 = _properties1 | 0x80;
			if ('AggregatedEndPoint' in context) _properties1 = _properties1 | ((context['AggregatedEndPoint']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('NumberOfBitMasks' in context) payload.writeBYTE(context['NumberOfBitMasks']); else return payload.asBuffer();
		if ('AggregatedMembersBitMask' in context) payload.writeBITMASK(context['AggregatedMembersBitMask'], {length: payload.at(1) & 0xff}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Res'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AggregatedEndPoint'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['NumberOfBitMasks'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['AggregatedMembersBitMask'] = payload.readBITMASK({length: payload.at(1) & 0xff}); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x61 ZIP_PORTAL COMMANDS
 */

// ZIP_PORTAL [0x61] GATEWAY_CONFIGURATION_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x61].command[0x01] = {
	name: "GATEWAY_CONFIGURATION_SET",
	help: "Gateway Configuration Set",
	param: { 
		'0x00': {name: "LanIpv6Address" /* ARRAY */ }, 
		'0x01': {name: "LanIpv6PrefixLength" /* BYTE */ }, 
		'0x02': {name: "PortalIpv6Prefix" /* ARRAY */ }, 
		'0x03': {name: "PortalIpv6PrefixLength" /* BYTE */ }, 
		'0x04': {name: "DefaultGatewayIpv6Address" /* ARRAY */ }, 
		'0x05': {name: "PanIpv6Prefix" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LanIpv6Address' in context) payload.writeSTRING(context['LanIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('LanIpv6PrefixLength' in context) payload.writeBYTE(context['LanIpv6PrefixLength']); else return payload.asBuffer();
		if ('PortalIpv6Prefix' in context) payload.writeSTRING(context['PortalIpv6Prefix'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('PortalIpv6PrefixLength' in context) payload.writeBYTE(context['PortalIpv6PrefixLength']); else return payload.asBuffer();
		if ('DefaultGatewayIpv6Address' in context) payload.writeSTRING(context['DefaultGatewayIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('PanIpv6Prefix' in context) payload.writeSTRING(context['PanIpv6Prefix'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LanIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['LanIpv6PrefixLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['PortalIpv6Prefix'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['PortalIpv6PrefixLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DefaultGatewayIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['PanIpv6Prefix'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

// ZIP_PORTAL [0x61] GATEWAY_CONFIGURATION_STATUS [0x02] COMMAND 
COMMAND_CLASS.enum[0x61].command[0x02] = {
	name: "GATEWAY_CONFIGURATION_STATUS",
	help: "Gateway Configuration Status",
	param: { 
		'0x00': {name: "Status" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(context['Status']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ZIP_PORTAL [0x61] GATEWAY_CONFIGURATION_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x61].command[0x03] = {
	name: "GATEWAY_CONFIGURATION_GET",
	help: "Gateway Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_PORTAL [0x61] GATEWAY_CONFIGURATION_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x61].command[0x04] = {
	name: "GATEWAY_CONFIGURATION_REPORT",
	help: "Gateway Configuration Report",
	param: { 
		'0x00': {name: "LanIpv6Address" /* ARRAY */ }, 
		'0x01': {name: "LanIpv6PrefixLength" /* BYTE */ }, 
		'0x02': {name: "PortalIpv6Prefix" /* ARRAY */ }, 
		'0x03': {name: "PortalIpv6PrefixLength" /* BYTE */ }, 
		'0x04': {name: "DefaultGatewayIpv6Address" /* ARRAY */ }, 
		'0x05': {name: "PanIpv6Prefix" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LanIpv6Address' in context) payload.writeSTRING(context['LanIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('LanIpv6PrefixLength' in context) payload.writeBYTE(context['LanIpv6PrefixLength']); else return payload.asBuffer();
		if ('PortalIpv6Prefix' in context) payload.writeSTRING(context['PortalIpv6Prefix'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('PortalIpv6PrefixLength' in context) payload.writeBYTE(context['PortalIpv6PrefixLength']); else return payload.asBuffer();
		if ('DefaultGatewayIpv6Address' in context) payload.writeSTRING(context['DefaultGatewayIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('PanIpv6Prefix' in context) payload.writeSTRING(context['PanIpv6Prefix'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LanIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['LanIpv6PrefixLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['PortalIpv6Prefix'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['PortalIpv6PrefixLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DefaultGatewayIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['PanIpv6Prefix'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x62 DOOR_LOCK COMMANDS
 */

// DOOR_LOCK [0x62] OPERATION_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x01] = {
	name: "OPERATION_SET",
	help: "Door Lock Operation Set",
	param: { 
		'0x00': {name: "DoorLockMode" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DoorLockMode' in context) payload.writeBYTE(helpers.getValue(context, 'DoorLockMode', ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['DoorLockMode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE.enum); else return context;
		return context;
	}
};

const ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE = {
	DoorUnsecured: 0x00, 
	DoorUnsecuredWithTimeout: 0x01, 
	DoorUnsecuredForInsideDoorHandles: 0x10, 
	DoorUnsecuredForInsideDoorHandlesWithTimeout: 0x11, 
	DoorUnsecuredForOutsideDoorHandles: 0x20, 
	DoorUnsecuredForOutsideDoorHandlesWithTimeout: 0x21, 
	DoorlockStateUnknown: 0xfe, 
	DoorSecured: 0xff, 
	enum: {
		0x00: "DoorUnsecured", 
		0x01: "DoorUnsecuredWithTimeout", 
		0x10: "DoorUnsecuredForInsideDoorHandles", 
		0x11: "DoorUnsecuredForInsideDoorHandlesWithTimeout", 
		0x20: "DoorUnsecuredForOutsideDoorHandles", 
		0x21: "DoorUnsecuredForOutsideDoorHandlesWithTimeout", 
		0xfe: "DoorlockStateUnknown", 
		0xff: "DoorSecured"
	}
};

// DOOR_LOCK [0x62] OPERATION_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x02] = {
	name: "OPERATION_GET",
	help: "Door Lock Operation Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DOOR_LOCK [0x62] OPERATION_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x03] = {
	name: "OPERATION_REPORT",
	help: "Door Lock Operation Report",
	param: { 
		'0x00': {name: "CurrentDoorLockMode" /* CONST */ }, 
		'0x01a': {name: "InsideDoorHandlesMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "OutsideDoorHandlesMode" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "DoorCondition" /* BYTE */ }, 
		'0x03': {name: "LockTimeoutMinutes" /* BYTE */ }, 
		'0x04': {name: "LockTimeoutSeconds" /* BYTE */ }, 
		'0x05': {name: "TargetDoorLockMode" /* CONST */ }, 
		'0x06': {name: "Duration" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CurrentDoorLockMode' in context) payload.writeBYTE(helpers.getValue(context, 'CurrentDoorLockMode', ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE)); else return payload.asBuffer();
		if ('InsideDoorHandlesMode' in context || 'OutsideDoorHandlesMode' in context) {
			let _properties1 = 0x00;
			if ('InsideDoorHandlesMode' in context) _properties1 = _properties1 | ((context['InsideDoorHandlesMode']) & 0x0f);
			if ('OutsideDoorHandlesMode' in context) _properties1 = _properties1 | ((context['OutsideDoorHandlesMode'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DoorCondition' in context) payload.writeBYTE(context['DoorCondition']); else return payload.asBuffer();
		if ('LockTimeoutMinutes' in context) payload.writeBYTE(context['LockTimeoutMinutes']); else return payload.asBuffer();
		if ('LockTimeoutSeconds' in context) payload.writeBYTE(context['LockTimeoutSeconds']); else return payload.asBuffer();
		if ('TargetDoorLockMode' in context) payload.writeBYTE(helpers.getValue(context, 'TargetDoorLockMode', ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE)); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(helpers.getValue(context, 'Duration', ENUM_SWITCH_BINARY_REPORT_DURATION)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['CurrentDoorLockMode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['InsideDoorHandlesMode'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['OutsideDoorHandlesMode'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DoorCondition'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LockTimeoutMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LockTimeoutSeconds'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['TargetDoorLockMode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_REPORT_DURATION.enum); else return context;
		return context;
	}
};

// DOOR_LOCK [0x62] CONFIGURATION_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x04] = {
	name: "CONFIGURATION_SET",
	help: "Door Lock Configuration Set",
	param: { 
		'0x00': {name: "OperationType" /* CONST */ }, 
		'0x01a': {name: "InsideDoorHandlesState" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "OutsideDoorHandlesState" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "LockTimeoutMinutes" /* BYTE */ }, 
		'0x03': {name: "LockTimeoutSeconds" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OperationType' in context) payload.writeBYTE(helpers.getValue(context, 'OperationType', ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE)); else return payload.asBuffer();
		if ('InsideDoorHandlesState' in context || 'OutsideDoorHandlesState' in context) {
			let _properties1 = 0x00;
			if ('InsideDoorHandlesState' in context) _properties1 = _properties1 | ((context['InsideDoorHandlesState']) & 0x0f);
			if ('OutsideDoorHandlesState' in context) _properties1 = _properties1 | ((context['OutsideDoorHandlesState'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('LockTimeoutMinutes' in context) payload.writeBYTE(context['LockTimeoutMinutes']); else return payload.asBuffer();
		if ('LockTimeoutSeconds' in context) payload.writeBYTE(context['LockTimeoutSeconds']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['OperationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['InsideDoorHandlesState'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['OutsideDoorHandlesState'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['LockTimeoutMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LockTimeoutSeconds'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE = {
	ConstantOperation: 0x01, 
	TimedOperation: 0x02, 
	enum: {
		0x01: "ConstantOperation", 
		0x02: "TimedOperation"
	}
};

// DOOR_LOCK [0x62] CONFIGURATION_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x05] = {
	name: "CONFIGURATION_GET",
	help: "Door Lock Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DOOR_LOCK [0x62] CONFIGURATION_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x62].command[0x06] = {
	name: "CONFIGURATION_REPORT",
	help: "Door Lock Configuration Report",
	param: { 
		'0x00': {name: "OperationType" /* CONST */ }, 
		'0x01a': {name: "InsideDoorHandlesState" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "OutsideDoorHandlesState" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "LockTimeoutMinutes" /* BYTE */ }, 
		'0x03': {name: "LockTimeoutSeconds" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OperationType' in context) payload.writeBYTE(helpers.getValue(context, 'OperationType', ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE)); else return payload.asBuffer();
		if ('InsideDoorHandlesState' in context || 'OutsideDoorHandlesState' in context) {
			let _properties1 = 0x00;
			if ('InsideDoorHandlesState' in context) _properties1 = _properties1 | ((context['InsideDoorHandlesState']) & 0x0f);
			if ('OutsideDoorHandlesState' in context) _properties1 = _properties1 | ((context['OutsideDoorHandlesState'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('LockTimeoutMinutes' in context) payload.writeBYTE(context['LockTimeoutMinutes']); else return payload.asBuffer();
		if ('LockTimeoutSeconds' in context) payload.writeBYTE(context['LockTimeoutSeconds']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['OperationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['InsideDoorHandlesState'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['OutsideDoorHandlesState'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['LockTimeoutMinutes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['LockTimeoutSeconds'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x63 USER_CODE COMMANDS
 */

// USER_CODE [0x63] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x63].command[0x01] = {
	name: "SET",
	help: "User Code Set",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "UserIdStatus" /* CONST */ }, 
		'0x02': {name: "UserCode" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('UserIdStatus' in context) payload.writeBYTE(helpers.getValue(context, 'UserIdStatus', ENUM_USER_CODE_USER_ID_STATUS)); else return payload.asBuffer();
		if ('UserCode' in context) payload.writeSTRING(context['UserCode'], { encoding: 'ascii', length: 10 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_USER_CODE_USER_ID_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['UserCode'] = payload.readSTRING({ encoding: 'ascii', length: 10 }); else return context;
		return context;
	}
};

const ENUM_USER_CODE_USER_ID_STATUS = {
	AvailablenotSet: 0x00, 
	Occupied: 0x01, 
	ReservedByAdministrator: 0x02, 
	StatusNotAvailable: 0xfe, 
	enum: {
		0x00: "AvailablenotSet", 
		0x01: "Occupied", 
		0x02: "ReservedByAdministrator", 
		0xfe: "StatusNotAvailable"
	}
};

// USER_CODE [0x63] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x63].command[0x02] = {
	name: "GET",
	help: "User Code Get",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// USER_CODE [0x63] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x63].command[0x03] = {
	name: "REPORT",
	help: "User Code Report",
	param: { 
		'0x00': {name: "UserIdentifier" /* BYTE */ }, 
		'0x01': {name: "UserIdStatus" /* CONST */ }, 
		'0x02': {name: "UserCode" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UserIdentifier' in context) payload.writeBYTE(context['UserIdentifier']); else return payload.asBuffer();
		if ('UserIdStatus' in context) payload.writeBYTE(helpers.getValue(context, 'UserIdStatus', ENUM_USER_CODE_USER_ID_STATUS)); else return payload.asBuffer();
		if ('UserCode' in context) payload.writeSTRING(context['UserCode'], { encoding: 'ascii', length: 10 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['UserIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['UserIdStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_USER_CODE_USER_ID_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['UserCode'] = payload.readSTRING({ encoding: 'ascii', length: 10 }); else return context;
		return context;
	}
};

// USER_CODE [0x63] USERS_NUMBER_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x63].command[0x04] = {
	name: "USERS_NUMBER_GET",
	help: "Users Number Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// USER_CODE [0x63] USERS_NUMBER_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x63].command[0x05] = {
	name: "USERS_NUMBER_REPORT",
	help: "Users Number Report",
	param: { 
		'0x00': {name: "SupportedUsers" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedUsers' in context) payload.writeBYTE(context['SupportedUsers']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedUsers'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x64 HUMIDITY_CONTROL_SETPOINT COMMANDS
 */

// HUMIDITY_CONTROL_SETPOINT [0x64] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x01] = {
	name: "SET",
	help: "Humidity Control Setpoint Set",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Scale" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Size" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Scale' in context || 'Size' in context || 'Precision' in context) {
			let _properties2 = 0x00;
			if ('Scale' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'Scale', ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE) << 3) & 0x18); 
			if ('Size' in context) _properties2 = _properties2 | ((context['Size']) & 0x07);
			if ('Precision' in context) _properties2 = _properties2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Scale'] = helpers.lookupNameValue((_properties2 & 0x18) >> 3, ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

const ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE = {
	Humidifier: 0x01, 
	Dehumidifier: 0x02, 
	enum: {
		0x01: "Humidifier", 
		0x02: "Dehumidifier"
	}
};

const ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE = {
	Percentage: 0x00, 
	Absolute: 0x01, 
	enum: {
		0x00: "Percentage", 
		0x01: "Absolute"
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x02] = {
	name: "GET",
	help: "Humidity Control Setpoint Get",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x03] = {
	name: "REPORT",
	help: "Humidity Control Setpoint Report",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Scale" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Size" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Scale' in context || 'Size' in context || 'Precision' in context) {
			let _properties2 = 0x00;
			if ('Scale' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'Scale', ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE) << 3) & 0x18); 
			if ('Size' in context) _properties2 = _properties2 | ((context['Size']) & 0x07);
			if ('Precision' in context) _properties2 = _properties2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Scale'] = helpers.lookupNameValue((_properties2 & 0x18) >> 3, ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Humidity Control Setpoint Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HUMIDITY_CONTROL_SETPOINT [0x64] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Humidity Control Setpoint Supported Report",
	param: { 
		'0x00-0': {name: "Humidifier" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Dehumidifier" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum);
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] SCALE_SUPPORTED_GET [0x06] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x06] = {
	name: "SCALE_SUPPORTED_GET",
	help: "Humidity Control Setpoint Scale Supported Get",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] SCALE_SUPPORTED_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x07] = {
	name: "SCALE_SUPPORTED_REPORT",
	help: "Humidity Control Setpoint Scale Supported Report",
	param: { 
		'0x00a': {name: "ScaleBitMask" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ScaleBitMask' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('ScaleBitMask' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'ScaleBitMask', ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ScaleBitMask'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] CAPABILITIES_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x08] = {
	name: "CAPABILITIES_GET",
	help: "Humidity Control Setpoint Capabilities Get",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// HUMIDITY_CONTROL_SETPOINT [0x64] CAPABILITIES_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x64].command[0x09] = {
	name: "CAPABILITIES_REPORT",
	help: "Humidity Control Setpoint Capabilities Report",
	param: { 
		'0x00a': {name: "SetpointType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "Scale1" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Size1" /* Properties2 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision1" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "MinimumValue" /* VARIANT */ }, 
		'0x03a': {name: "Scale2" /* Properties3 STRUCT_BYTE */ }, 
		'0x03b': {name: "Size2" /* Properties3 STRUCT_BYTE */ }, 
		'0x03c': {name: "Precision2" /* Properties3 STRUCT_BYTE */ }, 
		'0x04': {name: "MaximumValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('MinimumValue' in context) && !(('Precision1' in context) && ('Size1' in context))) helpers.updateFLOATINGSizePrecision(context, 'MinimumValue', 'Precision1', 'Size1');
		if (('MaximumValue' in context) && !(('Precision2' in context) && ('Size2' in context))) helpers.updateFLOATINGSizePrecision(context, 'MaximumValue', 'Precision2', 'Size2');
		if ('SetpointType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('SetpointType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SetpointType', ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Scale1' in context || 'Size1' in context || 'Precision1' in context) {
			let _properties2 = 0x00;
			if ('Scale1' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'Scale1', ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE) << 3) & 0x18); 
			if ('Size1' in context) _properties2 = _properties2 | ((context['Size1']) & 0x07);
			if ('Precision1' in context) _properties2 = _properties2 | ((context['Precision1'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MinimumValue' in context) payload.writeFLOATING(context['MinimumValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('Scale2' in context || 'Size2' in context || 'Precision2' in context) {
			let _properties3 = 0x00;
			if ('Scale2' in context) _properties3 = _properties3 | ((helpers.getValue(context, 'Scale2', ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE) << 3) & 0x18); 
			if ('Size2' in context) _properties3 = _properties3 | ((context['Size2']) & 0x07);
			if ('Precision2' in context) _properties3 = _properties3 | ((context['Precision2'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('MaximumValue' in context) payload.writeFLOATING(context['MaximumValue'], {size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SetpointType'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Scale1'] = helpers.lookupNameValue((_properties2 & 0x18) >> 3, ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Size1'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Precision1'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinimumValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Scale2'] = helpers.lookupNameValue((_properties3 & 0x18) >> 3, ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Size2'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Precision2'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaximumValue'] = payload.readFLOATING({size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x65 DMX COMMANDS
 */

// DMX [0x65] ADDRESS_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x01] = {
	name: "ADDRESS_SET",
	help: "DMX Address Set",
	param: { 
		'0x00a': {name: "PageId" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ChannelId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PageId' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('PageId' in context) _properties1 = _properties1 | ((context['PageId']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ChannelId' in context) payload.writeBYTE(context['ChannelId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PageId'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ChannelId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DMX [0x65] ADDRESS_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x02] = {
	name: "ADDRESS_GET",
	help: "DMX Address Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// DMX [0x65] ADDRESS_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x03] = {
	name: "ADDRESS_REPORT",
	help: "DMX Address Report",
	param: { 
		'0x00a': {name: "PageId" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ChannelId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PageId' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('PageId' in context) _properties1 = _properties1 | ((context['PageId']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ChannelId' in context) payload.writeBYTE(context['ChannelId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PageId'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ChannelId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DMX [0x65] CAPABILITY_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x04] = {
	name: "CAPABILITY_GET",
	help: "DMX Capability Get",
	param: { 
		'0x00': {name: "ChannelId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ChannelId' in context) payload.writeBYTE(context['ChannelId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ChannelId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DMX [0x65] CAPABILITY_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x05] = {
	name: "CAPABILITY_REPORT",
	help: "DMX Capability Report",
	param: { 
		'0x00': {name: "ChannelId" /* BYTE */ }, 
		'0x01': {name: "PropertyId" /* WORD */ }, 
		'0x02': {name: "DeviceChannels" /* BYTE */ }, 
		'0x03': {name: "MaxChannels" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ChannelId' in context) payload.writeBYTE(context['ChannelId']); else return payload.asBuffer();
		if ('PropertyId' in context) payload.writeWORD(context['PropertyId']); else return payload.asBuffer();
		if ('DeviceChannels' in context) payload.writeBYTE(context['DeviceChannels']); else return payload.asBuffer();
		if ('MaxChannels' in context) payload.writeBYTE(context['MaxChannels']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ChannelId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['PropertyId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DeviceChannels'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxChannels'] = payload.readBYTE(); else return context;
		return context;
	}
};

// DMX [0x65] DATA [0x06] COMMAND 
COMMAND_CLASS.enum[0x65].command[0x06] = {
	name: "DATA",
	help: "DMX Data",
	param: { 
		'0x00': {name: "Source" /* BYTE */ }, 
		'0x01a': {name: "Page" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SequenceNo" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "DmxChannel" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Source' in context) payload.writeBYTE(context['Source']); else return payload.asBuffer();
		if ('Page' in context || 'SequenceNo' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Page' in context) _properties1 = _properties1 | ((context['Page']) & 0x0f);
			if ('SequenceNo' in context) _properties1 = _properties1 | ((context['SequenceNo'] << 4) & 0x30);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DmxChannel' in context) payload.writeBUFFER(context['DmxChannel'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Source'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Page'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['SequenceNo'] = (_properties1 & 0x30) >> 4; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['DmxChannel'] = payload.readBUFFER({}); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x66 BARRIER_OPERATOR COMMANDS
 */

// BARRIER_OPERATOR [0x66] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x01] = {
	name: "SET",
	help: "Barrier Operator Set",
	param: { 
		'0x00': {name: "TargetValue" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('TargetValue' in context) payload.writeBYTE(helpers.getValue(context, 'TargetValue', ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['TargetValue'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE.enum); else return context;
		return context;
	}
};

// BARRIER_OPERATOR [0x66] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x02] = {
	name: "GET",
	help: "Barrier Operator Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// BARRIER_OPERATOR [0x66] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x03] = {
	name: "REPORT",
	help: "Barrier Operator Report",
	param: { 
		'0x00': {name: "State" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('State' in context) payload.writeBYTE(helpers.getValue(context, 'State', ENUM_BARRIER_OPERATOR_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['State'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_BARRIER_OPERATOR_STATE.enum); else return context;
		return context;
	}
};

const ENUM_BARRIER_OPERATOR_STATE = {
	Closed: 0x00, 
	Closing: 0xfc, 
	Stopped: 0xfd, 
	Opening: 0xfe, 
	Open: 0xff, 
	enum: {
		0x00: "Closed", 
		0xfc: "Closing", 
		0xfd: "Stopped", 
		0xfe: "Opening", 
		0xff: "Open"
	}
};

// BARRIER_OPERATOR [0x66] SIGNAL_SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x04] = {
	name: "SIGNAL_SUPPORTED_GET",
	help: "Barrier Operator Signal Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// BARRIER_OPERATOR [0x66] SIGNAL_SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x05] = {
	name: "SIGNAL_SUPPORTED_REPORT",
	help: "Barrier Operator Signal Supported Report",
	param: { 
		'0x00-0': {name: "NotSupported" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "AudibleNotification" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "VisualNotification" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_), {length: 3});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 3}), ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_.enum);
		return context;
	}
};

const ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_ = {
	NotSupported: 0x00, 
	AudibleNotification: 0x01, 
	VisualNotification: 0x02, 
	enum: {
		0x00: "NotSupported", 
		0x01: "AudibleNotification", 
		0x02: "VisualNotification"
	}
};

// BARRIER_OPERATOR [0x66] SIGNAL_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x06] = {
	name: "SIGNAL_SET",
	help: "Barrier Operator Signal Set",
	param: { 
		'0x00': {name: "SubsystemType" /* CONST */ }, 
		'0x01': {name: "SubsystemState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SubsystemType' in context) payload.writeBYTE(helpers.getValue(context, 'SubsystemType', ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_)); else return payload.asBuffer();
		if ('SubsystemState' in context) payload.writeBYTE(helpers.getValue(context, 'SubsystemState', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SubsystemType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_.enum); else return context;
		if (!payload.insufficientBytes(1)) context['SubsystemState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		return context;
	}
};

// BARRIER_OPERATOR [0x66] SIGNAL_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x07] = {
	name: "SIGNAL_GET",
	help: "Barrier Operator Signal Get",
	param: { 
		'0x00': {name: "SubsystemType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SubsystemType' in context) payload.writeBYTE(helpers.getValue(context, 'SubsystemType', ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SubsystemType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_.enum); else return context;
		return context;
	}
};

// BARRIER_OPERATOR [0x66] SIGNAL_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x66].command[0x08] = {
	name: "SIGNAL_REPORT",
	help: "Barrier Operator Signal Report",
	param: { 
		'0x00': {name: "SubsystemType" /* CONST */ }, 
		'0x01': {name: "SubsystemState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SubsystemType' in context) payload.writeBYTE(helpers.getValue(context, 'SubsystemType', ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_)); else return payload.asBuffer();
		if ('SubsystemState' in context) payload.writeBYTE(helpers.getValue(context, 'SubsystemState', ENUM_SWITCH_TOGGLE_BINARY_VALUE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SubsystemType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_.enum); else return context;
		if (!payload.insufficientBytes(1)) context['SubsystemState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_TOGGLE_BINARY_VALUE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x67 NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE COMMANDS
 */

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] LAST_WORKING_ROUTE_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x01] = {
	name: "LAST_WORKING_ROUTE_SET",
	help: "Last Working Route Set",
	param: { 
		'0x00': {name: "NodeID", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "Repeater1", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "Repeater2", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x03': {name: "Repeater3", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x04': {name: "Repeater4", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x05': {name: "Speed" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NodeID' in context) payload.writeBYTE(context['NodeID']); else return payload.asBuffer();
		if ('Repeater1' in context) payload.writeBYTE(context['Repeater1']); else return payload.asBuffer();
		if ('Repeater2' in context) payload.writeBYTE(context['Repeater2']); else return payload.asBuffer();
		if ('Repeater3' in context) payload.writeBYTE(context['Repeater3']); else return payload.asBuffer();
		if ('Repeater4' in context) payload.writeBYTE(context['Repeater4']); else return payload.asBuffer();
		if ('Speed' in context) payload.writeBYTE(helpers.getValue(context, 'Speed', ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NodeID'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater1'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater3'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater4'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Speed'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED.enum); else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED = {
	'96Kbitsec': 0x01, 
	'40Kbitsec': 0x02, 
	'100Kbitsec': 0x03, 
	enum: {
		0x01: "96Kbitsec", 
		0x02: "40Kbitsec", 
		0x03: "100Kbitsec"
	}
};

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] LAST_WORKING_ROUTE_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x02] = {
	name: "LAST_WORKING_ROUTE_GET",
	help: "Last Working Route Get",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] LAST_WORKING_ROUTE_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x03] = {
	name: "LAST_WORKING_ROUTE_REPORT",
	help: "Last Working Route Report",
	param: { 
		'0x00': {name: "NodeID", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "Repeater1", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "Repeater2", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x03': {name: "Repeater3", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x04': {name: "Repeater4", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x05': {name: "Speed" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NodeID' in context) payload.writeBYTE(context['NodeID']); else return payload.asBuffer();
		if ('Repeater1' in context) payload.writeBYTE(context['Repeater1']); else return payload.asBuffer();
		if ('Repeater2' in context) payload.writeBYTE(context['Repeater2']); else return payload.asBuffer();
		if ('Repeater3' in context) payload.writeBYTE(context['Repeater3']); else return payload.asBuffer();
		if ('Repeater4' in context) payload.writeBYTE(context['Repeater4']); else return payload.asBuffer();
		if ('Speed' in context) payload.writeBYTE(helpers.getValue(context, 'Speed', ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NodeID'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater1'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater3'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Repeater4'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Speed'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED.enum); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] STATISTICS_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x04] = {
	name: "STATISTICS_GET",
	help: "Statistics Get",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] STATISTICS_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x05] = {
	name: "STATISTICS_REPORT",
	help: "Statistics Report",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "Statistics" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "Type" /* CONST */ },
				'0x01-0x01': {name: "Length" /* BYTE */ },
				'0x01-0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('Statistics' in context) {
			context['Statistics'].forEach(function(context) {
					if ('Type' in context) payload.writeBYTE(helpers.getValue(context, 'Type', ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_STATISTICS_TYPE)); else return payload.asBuffer();
				if ('Length' in context) payload.writeBYTE(context['Length']); else return payload.asBuffer();
				if ('Value' in context) payload.writeSTRING(context['Value'], { encoding: 'hex', length: (payload.at(2) & 0xff) }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		let $statistics = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Type'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_STATISTICS_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Length'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Value'] = payload.readSTRING({ encoding: 'hex', length: payload.at(2) & 0xff }); else return context;
			$statistics.push(context);
		};
		if (!payload.insufficientBytes(1)) context['Statistics'] = $statistics; else return context;
		return context;
	}
};

const ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_STATISTICS_TYPE = {
	RouteChangesrc: 0x00, 
	TransmissionCounttc: 0x01, 
	Neighborsnb: 0x02, 
	PacketErrorCountpec: 0x03, 
	SumOfTransmissionTimests: 0x04, 
	SumOfTransmissionTimesSquraredts2: 0x05, 
	enum: {
		0x00: "RouteChangesrc", 
		0x01: "TransmissionCounttc", 
		0x02: "Neighborsnb", 
		0x03: "PacketErrorCountpec", 
		0x04: "SumOfTransmissionTimests", 
		0x05: "SumOfTransmissionTimesSquraredts2"
	}
};

// NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE [0x67] STATISTICS_CLEAR [0x06] COMMAND 
COMMAND_CLASS.enum[0x67].command[0x06] = {
	name: "STATISTICS_CLEAR",
	help: "Statistics Clear",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x68 ZIP_NAMING COMMANDS
 */

// ZIP_NAMING [0x68] NAME_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x01] = {
	name: "NAME_SET",
	help: "Z/IP Name Set",
	param: { 
		'0x00': {name: "Name" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Name' in context) payload.writeSTRING(context['Name'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Name'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};

// ZIP_NAMING [0x68] NAME_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x02] = {
	name: "NAME_GET",
	help: "Z/IP Name Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_NAMING [0x68] NAME_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x03] = {
	name: "NAME_REPORT",
	help: "Z/IP Name Report",
	param: { 
		'0x00': {name: "Name" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Name' in context) payload.writeSTRING(context['Name'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Name'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};

// ZIP_NAMING [0x68] LOCATION_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x04] = {
	name: "LOCATION_SET",
	help: "Z/IP Location Set",
	param: { 
		'0x00': {name: "Location" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Location' in context) payload.writeSTRING(context['Location'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Location'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};

// ZIP_NAMING [0x68] LOCATION_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x05] = {
	name: "LOCATION_GET",
	help: "Z/IP Location Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ZIP_NAMING [0x68] LOCATION_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x68].command[0x06] = {
	name: "LOCATION_REPORT",
	help: "Z/IP Location Report",
	param: { 
		'0x00': {name: "Location" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Location' in context) payload.writeSTRING(context['Location'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Location'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x69 MAILBOX COMMANDS
 */

// MAILBOX [0x69] CONFIGURATION_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x01] = {
	name: "CONFIGURATION_GET",
	help: "Mailbox Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// MAILBOX [0x69] CONFIGURATION_SET [0x02] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x02] = {
	name: "CONFIGURATION_SET",
	help: "Mailbox Configuration Set",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ForwardingDestinationIpv6Address" /* ARRAY */ }, 
		'0x02': {name: "UdpPortNumber" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_MAILBOX_CONFIGURATION_MODE)) & 0x07); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ForwardingDestinationIpv6Address' in context) payload.writeSTRING(context['ForwardingDestinationIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('UdpPortNumber' in context) payload.writeWORD(context['UdpPortNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_MAILBOX_CONFIGURATION_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ForwardingDestinationIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['UdpPortNumber'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_MAILBOX_CONFIGURATION_MODE = {
	Disable: 0x00, 
	EnableMailboxService: 0x01, 
	EnableMailboxProxy: 0x02, 
	enum: {
		0x00: "Disable", 
		0x01: "EnableMailboxService", 
		0x02: "EnableMailboxProxy"
	}
};

// MAILBOX [0x69] CONFIGURATION_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x03] = {
	name: "CONFIGURATION_REPORT",
	help: "Mailbox Configuration Report",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "SupportedModes" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "MailboxCapacity" /* WORD */ }, 
		'0x02': {name: "ForwardingDestinationIpv6Address" /* ARRAY */ }, 
		'0x03': {name: "UdpPortNumber" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'SupportedModes' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_MAILBOX_CONFIGURATION_MODE)) & 0x07); 
			if ('SupportedModes' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'SupportedModes', ENUM_MAILBOX_CONFIGURATION_SUPPORTED_MODES) << 3) & 0x18); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MailboxCapacity' in context) payload.writeWORD(context['MailboxCapacity']); else return payload.asBuffer();
		if ('ForwardingDestinationIpv6Address' in context) payload.writeSTRING(context['ForwardingDestinationIpv6Address'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		if ('UdpPortNumber' in context) payload.writeWORD(context['UdpPortNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_MAILBOX_CONFIGURATION_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['SupportedModes'] = helpers.lookupNameValue((_properties1 & 0x18) >> 3, ENUM_MAILBOX_CONFIGURATION_SUPPORTED_MODES.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MailboxCapacity'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ForwardingDestinationIpv6Address'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		if (!payload.insufficientBytes(1)) context['UdpPortNumber'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_MAILBOX_CONFIGURATION_SUPPORTED_MODES = {
	MailboxServiceSupported: 0x00, 
	MailboxProxySupported: 0x01, 
	enum: {
		0x00: "MailboxServiceSupported", 
		0x01: "MailboxProxySupported"
	}
};

// MAILBOX [0x69] QUEUE [0x04] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x04] = {
	name: "QUEUE",
	help: "Mailbox Queue",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Last" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "QueueHandle" /* BYTE */ }, 
		'0x03': {name: "MailboxEntry" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('Mode' in context || 'Last' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_MAILBOX_QUEUE_MODE)) & 0x03); 
			if (context['Last']) _properties1 = _properties1 | 0x04;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('QueueHandle' in context) payload.writeBYTE(context['QueueHandle']); else return payload.asBuffer();
		if ('MailboxEntry' in context) payload.writeSTRING(context['MailboxEntry'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x03), ENUM_MAILBOX_QUEUE_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Last'] = ((_properties1 & 0x04) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['QueueHandle'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MailboxEntry'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

const ENUM_MAILBOX_QUEUE_MODE = {
	Push: 0x00, 
	Pop: 0x01, 
	Waiting: 0x02, 
	Ping: 0x03, 
	ACK: 0x04, 
	NACK: 0x05, 
	QueueFull: 0x06, 
	enum: {
		0x00: "Push", 
		0x01: "Pop", 
		0x02: "Waiting", 
		0x03: "Ping", 
		0x04: "ACK", 
		0x05: "NACK", 
		0x06: "QueueFull"
	}
};

// MAILBOX [0x69] WAKEUP_NOTIFICATION [0x05] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x05] = {
	name: "WAKEUP_NOTIFICATION",
	help: "Mailbox Wakeup Notification",
	param: { 
		'0x00': {name: "QueueHandle" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('QueueHandle' in context) payload.writeBYTE(context['QueueHandle']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['QueueHandle'] = payload.readBYTE(); else return context;
		return context;
	}
};

// MAILBOX [0x69] NODE_FAILING [0x06] COMMAND 
COMMAND_CLASS.enum[0x69].command[0x06] = {
	name: "NODE_FAILING",
	help: "Mailbox Failing Node",
	param: { 
		'0x00': {name: "QueueHandle" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('QueueHandle' in context) payload.writeBYTE(context['QueueHandle']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['QueueHandle'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x6a WINDOW_COVERING COMMANDS
 */

// WINDOW_COVERING [0x6a] SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x01] = {
	name: "SUPPORTED_GET",
	help: "Window Covering Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// WINDOW_COVERING [0x6a] SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x02] = {
	name: "SUPPORTED_REPORT",
	help: "Window Covering Supported Report",
	param: { 
		'0x00a': {name: "NumberOfParameterMaskBytes" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ParameterMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfParameterMaskBytes' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfParameterMaskBytes' in context) _properties1 = _properties1 | ((context['NumberOfParameterMaskBytes']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ParameterMask' in context) payload.writeBITMASK(context['ParameterMask'], {length: payload.at(0) & 0x0f}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfParameterMaskBytes'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ParameterMask'] = payload.readBITMASK({length: payload.at(0) & 0x0f}); else return context;
		return context;
	}
};

// WINDOW_COVERING [0x6a] GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x03] = {
	name: "GET",
	help: "Window Covering Get",
	param: { 
		'0x00': {name: "ParameterId" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterId' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterId', ENUM_WINDOW_COVERING_PARAMETER_ID)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_WINDOW_COVERING_PARAMETER_ID.enum); else return context;
		return context;
	}
};

const ENUM_WINDOW_COVERING_PARAMETER_ID = {
	OutLeft1: 0x00, 
	OutLeft2: 0x01, 
	OutRight1: 0x02, 
	OutRight2: 0x03, 
	InLeft1: 0x04, 
	InLeft2: 0x05, 
	InRight1: 0x06, 
	InRight2: 0x07, 
	InRightLeft1: 0x08, 
	InRightLeft2: 0x09, 
	VerticalSlatsAngle1: 0x0a, 
	InTop1: 0x0b, 
	OutBottom1: 0x0c, 
	OutBottom2: 0x0d, 
	OutTop1: 0x0e, 
	OutTop2: 0x0f, 
	InBottom1: 0x10, 
	InBottom2: 0x11, 
	InTop2: 0x12, 
	InTopBottom1: 0x13, 
	InTopBottom2: 0x14, 
	HorizontalSlatsAngle1: 0x15, 
	HorizontalSlatsAngle2: 0x16, 
	enum: {
		0x00: "OutLeft1", 
		0x01: "OutLeft2", 
		0x02: "OutRight1", 
		0x03: "OutRight2", 
		0x04: "InLeft1", 
		0x05: "InLeft2", 
		0x06: "InRight1", 
		0x07: "InRight2", 
		0x08: "InRightLeft1", 
		0x09: "InRightLeft2", 
		0x0a: "VerticalSlatsAngle1", 
		0x0b: "InTop1", 
		0x0c: "OutBottom1", 
		0x0d: "OutBottom2", 
		0x0e: "OutTop1", 
		0x0f: "OutTop2", 
		0x10: "InBottom1", 
		0x11: "InBottom2", 
		0x12: "InTop2", 
		0x13: "InTopBottom1", 
		0x14: "InTopBottom2", 
		0x15: "HorizontalSlatsAngle1", 
		0x16: "HorizontalSlatsAngle2"
	}
};

// WINDOW_COVERING [0x6a] REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x04] = {
	name: "REPORT",
	help: "Window Covering Report",
	param: { 
		'0x00': {name: "ParameterId" /* CONST */ }, 
		'0x01': {name: "CurrentValue" /* BYTE */ }, 
		'0x02': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterId' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterId', ENUM_WINDOW_COVERING_PARAMETER_ID)); else return payload.asBuffer();
		if ('CurrentValue' in context) payload.writeBYTE(context['CurrentValue']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_WINDOW_COVERING_PARAMETER_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['CurrentValue'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};

// WINDOW_COVERING [0x6a] SET [0x05] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x05] = {
	name: "SET",
	help: "Window Covering Set",
	param: { 
		'0x00a': {name: "ParameterCount" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "ParameterId" /* CONST */ },
				'0x01-0x01': {name: "Value" /* BYTE */ }, 
		'0x02': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterCount' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('ParameterCount' in context) _properties1 = _properties1 | ((context['ParameterCount']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(0) & 0x1f)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('ParameterId' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterId', ENUM_WINDOW_COVERING_PARAMETER_ID)); else return payload.asBuffer();
				if ('Value' in context) payload.writeBYTE(context['Value']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ParameterCount'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(0) & 0x1f; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['ParameterId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_WINDOW_COVERING_PARAMETER_ID.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Value'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};

// WINDOW_COVERING [0x6a] START_LEVEL_CHANGE [0x06] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x06] = {
	name: "START_LEVEL_CHANGE",
	help: "Window Covering Start Level Change",
	param: { 
		'0x00a': {name: "UpDown" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Res2" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Res1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ParameterId" /* CONST */ }, 
		'0x02': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('UpDown' in context || 'Res2' in context || 'Res1' in context) {
			let _properties1 = 0x00;
			if (context['UpDown']) _properties1 = _properties1 | 0x40;
			if (context['Res2']) _properties1 = _properties1 | 0x80;
			if ('Res1' in context) _properties1 = _properties1 | ((context['Res1']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ParameterId' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterId', ENUM_WINDOW_COVERING_PARAMETER_ID)); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['UpDown'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Res2'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Res1'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['ParameterId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_WINDOW_COVERING_PARAMETER_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};

// WINDOW_COVERING [0x6a] STOP_LEVEL_CHANGE [0x07] COMMAND 
COMMAND_CLASS.enum[0x6a].command[0x07] = {
	name: "STOP_LEVEL_CHANGE",
	help: "Window Covering Stop Level Change",
	param: { 
		'0x00': {name: "ParameterId" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterId' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterId', ENUM_WINDOW_COVERING_PARAMETER_ID)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_WINDOW_COVERING_PARAMETER_ID.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x6b IRRIGATION COMMANDS
 */

// IRRIGATION [0x6b] SYSTEM_INFO_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x01] = {
	name: "SYSTEM_INFO_GET",
	help: "Irrigation System Info Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// IRRIGATION [0x6b] SYSTEM_INFO_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x02] = {
	name: "SYSTEM_INFO_REPORT",
	help: "Irrigation System Info Report",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved2" /* Properties1 STRUCT_BYTE */ }, 
		'0x00d': {name: "Reserved3" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "TotalNumberOfValves" /* BYTE */ }, 
		'0x02': {name: "TotalNumberOfValveTables" /* BYTE */ }, 
		'0x03a': {name: "ValveTableMaxSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x03b': {name: "Reserved" /* Properties2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MasterValve' in context || 'Reserved1' in context || 'Reserved2' in context || 'Reserved3' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1'] << 1) & 0x06);
			if ('Reserved2' in context) _properties1 = _properties1 | ((context['Reserved2'] << 3) & 0x18);
			if ('Reserved3' in context) _properties1 = _properties1 | ((context['Reserved3'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('TotalNumberOfValves' in context) payload.writeBYTE(context['TotalNumberOfValves']); else return payload.asBuffer();
		if ('TotalNumberOfValveTables' in context) payload.writeBYTE(context['TotalNumberOfValveTables']); else return payload.asBuffer();
		if ('ValveTableMaxSize' in context || 'Reserved' in context) {
			let _properties2 = 0x00;
			if ('ValveTableMaxSize' in context) _properties2 = _properties2 | ((context['ValveTableMaxSize']) & 0x0f);
			if ('Reserved' in context) _properties2 = _properties2 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0x06) >> 1; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved3'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['TotalNumberOfValves'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['TotalNumberOfValveTables'] = payload.readBYTE(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ValveTableMaxSize'] = (_properties2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties2 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// IRRIGATION [0x6b] SYSTEM_STATUS_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x03] = {
	name: "SYSTEM_STATUS_GET",
	help: "Irrigation System Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// IRRIGATION [0x6b] SYSTEM_STATUS_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x04] = {
	name: "SYSTEM_STATUS_REPORT",
	help: "Irrigation System Status Report",
	param: { 
		'0x00': {name: "SystemVoltage" /* BYTE */ }, 
		'0x01': {name: "SensorStatus" /* CONST */ }, 
		'0x02a': {name: "FlowSize" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "FlowScale" /* Properties1 STRUCT_BYTE */ }, 
		'0x02c': {name: "FlowPrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x03': {name: "FlowValue" /* VARIANT */ }, 
		'0x04a': {name: "PressureSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x04b': {name: "PressureScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x04c': {name: "PressurePrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x05': {name: "PressureValue" /* VARIANT */ }, 
		'0x06': {name: "ShutoffDuration" /* BYTE */ }, 
		'0x07-0': {name: "NotProgrammed" /* SystemErrorStatus BITMASK */ }, 
		'0x07-1': {name: "EmergencyShutdown" /* SystemErrorStatus BITMASK */ }, 
		'0x07-2': {name: "HighThresholdTriggered" /* SystemErrorStatus BITMASK */ }, 
		'0x07-3': {name: "LowThresholdTriggered" /* SystemErrorStatus BITMASK */ }, 
		'0x07-4': {name: "ValveErrors" /* SystemErrorStatus BITMASK */ }, 
		'0x08a': {name: "MasterValve" /* Properties3 STRUCT_BYTE */ }, 
		'0x08b': {name: "Reserved" /* Properties3 STRUCT_BYTE */ }, 
		'0x09': {name: "ValveId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('FlowValue' in context) && !(('FlowPrecision' in context) && ('FlowSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'FlowValue', 'FlowPrecision', 'FlowSize');
		if (('PressureValue' in context) && !(('PressurePrecision' in context) && ('PressureSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'PressureValue', 'PressurePrecision', 'PressureSize');
		if ('SystemVoltage' in context) payload.writeBYTE(context['SystemVoltage']); else return payload.asBuffer();
		if ('SensorStatus' in context) payload.writeBYTE(helpers.getValue(context, 'SensorStatus', ENUM_IRRIGATION_SYSTEM_STATUS_SENSOR_STATUS)); else return payload.asBuffer();
		if ('FlowSize' in context || 'FlowScale' in context || 'FlowPrecision' in context) {
			let _properties1 = 0x00;
			if ('FlowSize' in context) _properties1 = _properties1 | ((context['FlowSize']) & 0x07);
			if ('FlowScale' in context) _properties1 = _properties1 | ((context['FlowScale'] << 3) & 0x18);
			if ('FlowPrecision' in context) _properties1 = _properties1 | ((context['FlowPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('FlowValue' in context) payload.writeFLOATING(context['FlowValue'], {size: payload.at(2) & 0x07, precision: (payload.at(2) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('PressureSize' in context || 'PressureScale' in context || 'PressurePrecision' in context) {
			let _properties2 = 0x00;
			if ('PressureSize' in context) _properties2 = _properties2 | ((context['PressureSize']) & 0x07);
			if ('PressureScale' in context) _properties2 = _properties2 | ((context['PressureScale'] << 3) & 0x18);
			if ('PressurePrecision' in context) _properties2 = _properties2 | ((context['PressurePrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('PressureValue' in context) payload.writeFLOATING(context['PressureValue'], {size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('ShutoffDuration' in context) payload.writeBYTE(context['ShutoffDuration']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_SYSTEM_STATUS_SYSTEM_ERROR_STATUS), {length: 1});
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties3 = 0x00;
			if (context['MasterValve']) _properties3 = _properties3 | 0x01;
			if ('Reserved' in context) _properties3 = _properties3 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SystemVoltage'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_IRRIGATION_SYSTEM_STATUS_SENSOR_STATUS.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FlowSize'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['FlowScale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['FlowPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FlowValue'] = payload.readFLOATING({size: payload.at(2) & 0x07, precision: (payload.at(2) & 0xe0) >> 5 }); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PressureSize'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['PressureScale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['PressurePrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['PressureValue'] = payload.readFLOATING({size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return context;
		if (!payload.insufficientBytes(1)) context['ShutoffDuration'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_SYSTEM_STATUS_SYSTEM_ERROR_STATUS.enum);
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties3 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties3 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_IRRIGATION_SYSTEM_STATUS_SENSOR_STATUS = {
	FlowSensorDetected: 0x00, 
	PressureSensorDetected: 0x01, 
	RainSensorDetected: 0x02, 
	MoistureSensorDetected: 0x03, 
	enum: {
		0x00: "FlowSensorDetected", 
		0x01: "PressureSensorDetected", 
		0x02: "RainSensorDetected", 
		0x03: "MoistureSensorDetected"
	}
};

const ENUM_IRRIGATION_SYSTEM_STATUS_SYSTEM_ERROR_STATUS = {
	NotProgrammed: 0x00, 
	EmergencyShutdown: 0x01, 
	HighThresholdTriggered: 0x02, 
	LowThresholdTriggered: 0x03, 
	ValveErrors: 0x04, 
	enum: {
		0x00: "NotProgrammed", 
		0x01: "EmergencyShutdown", 
		0x02: "HighThresholdTriggered", 
		0x03: "LowThresholdTriggered", 
		0x04: "ValveErrors"
	}
};

// IRRIGATION [0x6b] SYSTEM_CONFIG_SET [0x05] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x05] = {
	name: "SYSTEM_CONFIG_SET",
	help: "Irrigation System Config Set",
	param: { 
		'0x00': {name: "MasterValveDelay" /* BYTE */ }, 
		'0x01a': {name: "HighPressureThresholdSize" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "HighPressureThresholdScale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "HighPressureThresholdPrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "HighPressureThresholdValue" /* VARIANT */ }, 
		'0x03a': {name: "LowPressureThresholdSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x03b': {name: "LowPressureThresholdScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x03c': {name: "LowPressureThresholdPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x04': {name: "LowPressureThresholdValue" /* VARIANT */ }, 
		'0x05-0': {name: "RainSensorPolarity" /* SensorPolarity BITMASK */ }, 
		'0x05-1': {name: "MoistureSensorPolarity" /* SensorPolarity BITMASK */ }, 
		'0x05-2': {name: "Valid" /* SensorPolarity BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('HighPressureThresholdValue' in context) && !(('HighPressureThresholdPrecision' in context) && ('HighPressureThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'HighPressureThresholdValue', 'HighPressureThresholdPrecision', 'HighPressureThresholdSize');
		if (('LowPressureThresholdValue' in context) && !(('LowPressureThresholdPrecision' in context) && ('LowPressureThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'LowPressureThresholdValue', 'LowPressureThresholdPrecision', 'LowPressureThresholdSize');
		if ('MasterValveDelay' in context) payload.writeBYTE(context['MasterValveDelay']); else return payload.asBuffer();
		if ('HighPressureThresholdSize' in context || 'HighPressureThresholdScale' in context || 'HighPressureThresholdPrecision' in context) {
			let _properties1 = 0x00;
			if ('HighPressureThresholdSize' in context) _properties1 = _properties1 | ((context['HighPressureThresholdSize']) & 0x07);
			if ('HighPressureThresholdScale' in context) _properties1 = _properties1 | ((context['HighPressureThresholdScale'] << 3) & 0x18);
			if ('HighPressureThresholdPrecision' in context) _properties1 = _properties1 | ((context['HighPressureThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('HighPressureThresholdValue' in context) payload.writeFLOATING(context['HighPressureThresholdValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('LowPressureThresholdSize' in context || 'LowPressureThresholdScale' in context || 'LowPressureThresholdPrecision' in context) {
			let _properties2 = 0x00;
			if ('LowPressureThresholdSize' in context) _properties2 = _properties2 | ((context['LowPressureThresholdSize']) & 0x07);
			if ('LowPressureThresholdScale' in context) _properties2 = _properties2 | ((context['LowPressureThresholdScale'] << 3) & 0x18);
			if ('LowPressureThresholdPrecision' in context) _properties2 = _properties2 | ((context['LowPressureThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('LowPressureThresholdValue' in context) payload.writeFLOATING(context['LowPressureThresholdValue'], {size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MasterValveDelay'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdSize'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdScale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['HighPressureThresholdValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdSize'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdScale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['LowPressureThresholdValue'] = payload.readFLOATING({size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY.enum);
		return context;
	}
};

const ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY = {
	RainSensorPolarity: 0x00, 
	MoistureSensorPolarity: 0x01, 
	Valid: 0x07, 
	enum: {
		0x00: "RainSensorPolarity", 
		0x01: "MoistureSensorPolarity", 
		0x07: "Valid"
	}
};

// IRRIGATION [0x6b] SYSTEM_CONFIG_GET [0x06] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x06] = {
	name: "SYSTEM_CONFIG_GET",
	help: "Irrigation System Config Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// IRRIGATION [0x6b] SYSTEM_CONFIG_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x07] = {
	name: "SYSTEM_CONFIG_REPORT",
	help: "Irrigation System Config Report",
	param: { 
		'0x00': {name: "MasterValveDelay" /* BYTE */ }, 
		'0x01a': {name: "HighPressureThresholdSize" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "HighPressureThresholdScale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "HighPressureThresholdPrecision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "HighPressureThresholdValue" /* VARIANT */ }, 
		'0x03a': {name: "LowPressureThresholdSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x03b': {name: "LowPressureThresholdScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x03c': {name: "LowPressureThresholdPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x04': {name: "LowPressureThresholdValue" /* VARIANT */ }, 
		'0x05-0': {name: "RainSensorPolarity" /* SensorPolarity BITMASK */ }, 
		'0x05-1': {name: "MoistureSensorPolarity" /* SensorPolarity BITMASK */ }, 
		'0x05-2': {name: "Valid" /* SensorPolarity BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('HighPressureThresholdValue' in context) && !(('HighPressureThresholdPrecision' in context) && ('HighPressureThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'HighPressureThresholdValue', 'HighPressureThresholdPrecision', 'HighPressureThresholdSize');
		if (('LowPressureThresholdValue' in context) && !(('LowPressureThresholdPrecision' in context) && ('LowPressureThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'LowPressureThresholdValue', 'LowPressureThresholdPrecision', 'LowPressureThresholdSize');
		if ('MasterValveDelay' in context) payload.writeBYTE(context['MasterValveDelay']); else return payload.asBuffer();
		if ('HighPressureThresholdSize' in context || 'HighPressureThresholdScale' in context || 'HighPressureThresholdPrecision' in context) {
			let _properties1 = 0x00;
			if ('HighPressureThresholdSize' in context) _properties1 = _properties1 | ((context['HighPressureThresholdSize']) & 0x07);
			if ('HighPressureThresholdScale' in context) _properties1 = _properties1 | ((context['HighPressureThresholdScale'] << 3) & 0x18);
			if ('HighPressureThresholdPrecision' in context) _properties1 = _properties1 | ((context['HighPressureThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('HighPressureThresholdValue' in context) payload.writeFLOATING(context['HighPressureThresholdValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('LowPressureThresholdSize' in context || 'LowPressureThresholdScale' in context || 'LowPressureThresholdPrecision' in context) {
			let _properties2 = 0x00;
			if ('LowPressureThresholdSize' in context) _properties2 = _properties2 | ((context['LowPressureThresholdSize']) & 0x07);
			if ('LowPressureThresholdScale' in context) _properties2 = _properties2 | ((context['LowPressureThresholdScale'] << 3) & 0x18);
			if ('LowPressureThresholdPrecision' in context) _properties2 = _properties2 | ((context['LowPressureThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('LowPressureThresholdValue' in context) payload.writeFLOATING(context['LowPressureThresholdValue'], {size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MasterValveDelay'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdSize'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdScale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['HighPressureThresholdPrecision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['HighPressureThresholdValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdSize'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdScale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['LowPressureThresholdPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['LowPressureThresholdValue'] = payload.readFLOATING({size: payload.at(3) & 0x07, precision: (payload.at(3) & 0xe0) >> 5 }); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY.enum);
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_INFO_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x08] = {
	name: "VALVE_INFO_GET",
	help: "Irrigation Valve Info Get",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_INFO_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x09] = {
	name: "VALVE_INFO_REPORT",
	help: "Irrigation Valve Info Report",
	param: { 
		'0x00a': {name: "Master" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Connected" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }, 
		'0x02': {name: "NominalCurrent" /* BYTE */ }, 
		'0x03-0': {name: "ShortCircuit" /* ValveErrorStatus BITMASK */ }, 
		'0x03-1': {name: "CurrentHighThreshold" /* ValveErrorStatus BITMASK */ }, 
		'0x03-2': {name: "CurrentLowThreshold" /* ValveErrorStatus BITMASK */ }, 
		'0x03-3': {name: "MaximumFlow" /* ValveErrorStatus BITMASK */ }, 
		'0x03-4': {name: "FlowHighThreshold" /* ValveErrorStatus BITMASK */ }, 
		'0x03-5': {name: "FlowLowThreshold" /* ValveErrorStatus BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Master' in context || 'Connected' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Master']) _properties1 = _properties1 | 0x01;
			if (context['Connected']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		if ('NominalCurrent' in context) payload.writeBYTE(context['NominalCurrent']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_VALVE_INFO_VALVE_ERROR_STATUS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Master'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Connected'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NominalCurrent'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_VALVE_INFO_VALVE_ERROR_STATUS.enum);
		return context;
	}
};

const ENUM_IRRIGATION_VALVE_INFO_VALVE_ERROR_STATUS = {
	ShortCircuit: 0x00, 
	CurrentHighThreshold: 0x01, 
	CurrentLowThreshold: 0x02, 
	MaximumFlow: 0x03, 
	FlowHighThreshold: 0x04, 
	FlowLowThreshold: 0x05, 
	enum: {
		0x00: "ShortCircuit", 
		0x01: "CurrentHighThreshold", 
		0x02: "CurrentLowThreshold", 
		0x03: "MaximumFlow", 
		0x04: "FlowHighThreshold", 
		0x05: "FlowLowThreshold"
	}
};

// IRRIGATION [0x6b] VALVE_CONFIG_SET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0a] = {
	name: "VALVE_CONFIG_SET",
	help: "Irrigation Valve Config Set",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }, 
		'0x02': {name: "NominalCurrentHighThreshold" /* BYTE */ }, 
		'0x03': {name: "NominalCurrentLowThreshold" /* BYTE */ }, 
		'0x04a': {name: "MaximumFlowSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x04b': {name: "MaximumFlowScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x04c': {name: "MaximumFlowPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x05': {name: "MaximumFlowValue" /* VARIANT */ }, 
		'0x06a': {name: "FlowHighThresholdSize" /* Properties3 STRUCT_BYTE */ }, 
		'0x06b': {name: "FlowHighThresholdScale" /* Properties3 STRUCT_BYTE */ }, 
		'0x06c': {name: "FlowHighThresholdPrecision" /* Properties3 STRUCT_BYTE */ }, 
		'0x07': {name: "FlowHighThresholdValue" /* VARIANT */ }, 
		'0x08a': {name: "FlowLowThresholdSize" /* Properties4 STRUCT_BYTE */ }, 
		'0x08b': {name: "FlowLowThresholdScale" /* Properties4 STRUCT_BYTE */ }, 
		'0x08c': {name: "FlowLowThresholdPrecision" /* Properties4 STRUCT_BYTE */ }, 
		'0x09': {name: "FlowLowThresholdValue" /* VARIANT */ }, 
		'0x0a-0': {name: "UseRainSensor" /* SensorUsage BITMASK */ }, 
		'0x0a-1': {name: "UseMoistureSensor" /* SensorUsage BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('MaximumFlowValue' in context) && !(('MaximumFlowPrecision' in context) && ('MaximumFlowSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'MaximumFlowValue', 'MaximumFlowPrecision', 'MaximumFlowSize');
		if (('FlowHighThresholdValue' in context) && !(('FlowHighThresholdPrecision' in context) && ('FlowHighThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'FlowHighThresholdValue', 'FlowHighThresholdPrecision', 'FlowHighThresholdSize');
		if (('FlowLowThresholdValue' in context) && !(('FlowLowThresholdPrecision' in context) && ('FlowLowThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'FlowLowThresholdValue', 'FlowLowThresholdPrecision', 'FlowLowThresholdSize');
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		if ('NominalCurrentHighThreshold' in context) payload.writeBYTE(context['NominalCurrentHighThreshold']); else return payload.asBuffer();
		if ('NominalCurrentLowThreshold' in context) payload.writeBYTE(context['NominalCurrentLowThreshold']); else return payload.asBuffer();
		if ('MaximumFlowSize' in context || 'MaximumFlowScale' in context || 'MaximumFlowPrecision' in context) {
			let _properties2 = 0x00;
			if ('MaximumFlowSize' in context) _properties2 = _properties2 | ((context['MaximumFlowSize']) & 0x07);
			if ('MaximumFlowScale' in context) _properties2 = _properties2 | ((context['MaximumFlowScale'] << 3) & 0x18);
			if ('MaximumFlowPrecision' in context) _properties2 = _properties2 | ((context['MaximumFlowPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MaximumFlowValue' in context) payload.writeFLOATING(context['MaximumFlowValue'], {size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('FlowHighThresholdSize' in context || 'FlowHighThresholdScale' in context || 'FlowHighThresholdPrecision' in context) {
			let _properties3 = 0x00;
			if ('FlowHighThresholdSize' in context) _properties3 = _properties3 | ((context['FlowHighThresholdSize']) & 0x07);
			if ('FlowHighThresholdScale' in context) _properties3 = _properties3 | ((context['FlowHighThresholdScale'] << 3) & 0x18);
			if ('FlowHighThresholdPrecision' in context) _properties3 = _properties3 | ((context['FlowHighThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('FlowHighThresholdValue' in context) payload.writeFLOATING(context['FlowHighThresholdValue'], {size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('FlowLowThresholdSize' in context || 'FlowLowThresholdScale' in context || 'FlowLowThresholdPrecision' in context) {
			let _properties4 = 0x00;
			if ('FlowLowThresholdSize' in context) _properties4 = _properties4 | ((context['FlowLowThresholdSize']) & 0x07);
			if ('FlowLowThresholdScale' in context) _properties4 = _properties4 | ((context['FlowLowThresholdScale'] << 3) & 0x18);
			if ('FlowLowThresholdPrecision' in context) _properties4 = _properties4 | ((context['FlowLowThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ('FlowLowThresholdValue' in context) payload.writeFLOATING(context['FlowLowThresholdValue'], {size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NominalCurrentHighThreshold'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NominalCurrentLowThreshold'] = payload.readBYTE(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MaximumFlowSize'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['MaximumFlowScale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['MaximumFlowPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaximumFlowValue'] = payload.readFLOATING({size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdSize'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdScale'] = (_properties3 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdPrecision'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FlowHighThresholdValue'] = payload.readFLOATING({size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return context;
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdSize'] = (_properties4 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdScale'] = (_properties4 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdPrecision'] = (_properties4 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FlowLowThresholdValue'] = payload.readFLOATING({size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE.enum);
		return context;
	}
};

const ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE = {
	UseRainSensor: 0x00, 
	UseMoistureSensor: 0x01, 
	enum: {
		0x00: "UseRainSensor", 
		0x01: "UseMoistureSensor"
	}
};

// IRRIGATION [0x6b] VALVE_CONFIG_GET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0b] = {
	name: "VALVE_CONFIG_GET",
	help: "Irrigation Valve Config Get",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_CONFIG_REPORT [0x0c] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0c] = {
	name: "VALVE_CONFIG_REPORT",
	help: "Irrigation Valve Config Report",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }, 
		'0x02': {name: "NominalCurrentHighThreshold" /* BYTE */ }, 
		'0x03': {name: "NominalCurrentLowThreshold" /* BYTE */ }, 
		'0x04a': {name: "MaximumFlowSize" /* Properties2 STRUCT_BYTE */ }, 
		'0x04b': {name: "MaximumFlowScale" /* Properties2 STRUCT_BYTE */ }, 
		'0x04c': {name: "MaximumFlowPrecision" /* Properties2 STRUCT_BYTE */ }, 
		'0x05': {name: "MaximumFlowValue" /* VARIANT */ }, 
		'0x06a': {name: "FlowHighThresholdSize" /* Properties3 STRUCT_BYTE */ }, 
		'0x06b': {name: "FlowHighThresholdScale" /* Properties3 STRUCT_BYTE */ }, 
		'0x06c': {name: "FlowHighThresholdPrecision" /* Properties3 STRUCT_BYTE */ }, 
		'0x07': {name: "FlowHighThresholdValue" /* VARIANT */ }, 
		'0x08a': {name: "FlowLowThresholdSize" /* Properties4 STRUCT_BYTE */ }, 
		'0x08b': {name: "FlowLowThresholdScale" /* Properties4 STRUCT_BYTE */ }, 
		'0x08c': {name: "FlowLowThresholdPrecision" /* Properties4 STRUCT_BYTE */ }, 
		'0x09': {name: "FlowLowThresholdValue" /* VARIANT */ }, 
		'0x0a-0': {name: "UseRainSensor" /* SensorUsage BITMASK */ }, 
		'0x0a-1': {name: "UseMoistureSensor" /* SensorUsage BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('MaximumFlowValue' in context) && !(('MaximumFlowPrecision' in context) && ('MaximumFlowSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'MaximumFlowValue', 'MaximumFlowPrecision', 'MaximumFlowSize');
		if (('FlowHighThresholdValue' in context) && !(('FlowHighThresholdPrecision' in context) && ('FlowHighThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'FlowHighThresholdValue', 'FlowHighThresholdPrecision', 'FlowHighThresholdSize');
		if (('FlowLowThresholdValue' in context) && !(('FlowLowThresholdPrecision' in context) && ('FlowLowThresholdSize' in context))) helpers.updateFLOATINGSizePrecision(context, 'FlowLowThresholdValue', 'FlowLowThresholdPrecision', 'FlowLowThresholdSize');
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		if ('NominalCurrentHighThreshold' in context) payload.writeBYTE(context['NominalCurrentHighThreshold']); else return payload.asBuffer();
		if ('NominalCurrentLowThreshold' in context) payload.writeBYTE(context['NominalCurrentLowThreshold']); else return payload.asBuffer();
		if ('MaximumFlowSize' in context || 'MaximumFlowScale' in context || 'MaximumFlowPrecision' in context) {
			let _properties2 = 0x00;
			if ('MaximumFlowSize' in context) _properties2 = _properties2 | ((context['MaximumFlowSize']) & 0x07);
			if ('MaximumFlowScale' in context) _properties2 = _properties2 | ((context['MaximumFlowScale'] << 3) & 0x18);
			if ('MaximumFlowPrecision' in context) _properties2 = _properties2 | ((context['MaximumFlowPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('MaximumFlowValue' in context) payload.writeFLOATING(context['MaximumFlowValue'], {size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('FlowHighThresholdSize' in context || 'FlowHighThresholdScale' in context || 'FlowHighThresholdPrecision' in context) {
			let _properties3 = 0x00;
			if ('FlowHighThresholdSize' in context) _properties3 = _properties3 | ((context['FlowHighThresholdSize']) & 0x07);
			if ('FlowHighThresholdScale' in context) _properties3 = _properties3 | ((context['FlowHighThresholdScale'] << 3) & 0x18);
			if ('FlowHighThresholdPrecision' in context) _properties3 = _properties3 | ((context['FlowHighThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties3);
		} else return payload.asBuffer();;
		if ('FlowHighThresholdValue' in context) payload.writeFLOATING(context['FlowHighThresholdValue'], {size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return payload.asBuffer();
		if ('FlowLowThresholdSize' in context || 'FlowLowThresholdScale' in context || 'FlowLowThresholdPrecision' in context) {
			let _properties4 = 0x00;
			if ('FlowLowThresholdSize' in context) _properties4 = _properties4 | ((context['FlowLowThresholdSize']) & 0x07);
			if ('FlowLowThresholdScale' in context) _properties4 = _properties4 | ((context['FlowLowThresholdScale'] << 3) & 0x18);
			if ('FlowLowThresholdPrecision' in context) _properties4 = _properties4 | ((context['FlowLowThresholdPrecision'] << 5) & 0xe0);
			payload.writeBYTE(_properties4);
		} else return payload.asBuffer();;
		if ('FlowLowThresholdValue' in context) payload.writeFLOATING(context['FlowLowThresholdValue'], {size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NominalCurrentHighThreshold'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NominalCurrentLowThreshold'] = payload.readBYTE(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MaximumFlowSize'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['MaximumFlowScale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['MaximumFlowPrecision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MaximumFlowValue'] = payload.readFLOATING({size: payload.at(4) & 0x07, precision: (payload.at(4) & 0xe0) >> 5 }); else return context;
		{
			let _properties3 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdSize'] = (_properties3 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdScale'] = (_properties3 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['FlowHighThresholdPrecision'] = (_properties3 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FlowHighThresholdValue'] = payload.readFLOATING({size: payload.at(6) & 0x07, precision: (payload.at(6) & 0xe0) >> 5 }); else return context;
		{
			let _properties4 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdSize'] = (_properties4 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdScale'] = (_properties4 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['FlowLowThresholdPrecision'] = (_properties4 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FlowLowThresholdValue'] = payload.readFLOATING({size: payload.at(8) & 0x07, precision: (payload.at(8) & 0xe0) >> 5 }); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE.enum);
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_RUN [0x0d] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0d] = {
	name: "VALVE_RUN",
	help: "Irrigation Valve Run",
	param: { 
		'0x00a': {name: "MasterValve" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ValveId" /* BYTE */ }, 
		'0x02': {name: "Duration" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MasterValve' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['MasterValve']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
		if ('Duration' in context) payload.writeWORD(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['MasterValve'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readWORD(); else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_TABLE_SET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0e] = {
	name: "VALVE_TABLE_SET",
	help: "Irrigation Valve Table Set",
	param: { 
		'0x00': {name: "ValveTableId" /* BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "ValveId" /* BYTE */ },
				'0x01-0x01': {name: "Duration" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ValveTableId' in context) payload.writeBYTE(context['ValveTableId']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
				if ('Duration' in context) payload.writeWORD(context['Duration']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ValveTableId'] = payload.readBYTE(); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Duration'] = payload.readWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_TABLE_GET [0x0f] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x0f] = {
	name: "VALVE_TABLE_GET",
	help: "Irrigation Valve Table Get",
	param: { 
		'0x00': {name: "ValveTableId" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ValveTableId' in context) payload.writeBYTE(context['ValveTableId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ValveTableId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_TABLE_REPORT [0x10] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x10] = {
	name: "VALVE_TABLE_REPORT",
	help: "Irrigation Valve Table Report",
	param: { 
		'0x00': {name: "ValveTableId" /* BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "ValveId" /* BYTE */ },
				'0x01-0x01': {name: "Duration" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ValveTableId' in context) payload.writeBYTE(context['ValveTableId']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('ValveId' in context) payload.writeBYTE(context['ValveId']); else return payload.asBuffer();
				if ('Duration' in context) payload.writeWORD(context['Duration']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ValveTableId'] = payload.readBYTE(); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['ValveId'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Duration'] = payload.readWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// IRRIGATION [0x6b] VALVE_TABLE_RUN [0x11] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x11] = {
	name: "VALVE_TABLE_RUN",
	help: "Irrigation Valve Table Run",
	param: { 
		'0x00': {name: "ValveTableId" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ValveTableId' in context) payload.writeSTRING(context['ValveTableId'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ValveTableId'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// IRRIGATION [0x6b] SYSTEM_SHUTOFF [0x12] COMMAND 
COMMAND_CLASS.enum[0x6b].command[0x12] = {
	name: "SYSTEM_SHUTOFF",
	help: "Irrigation System Shutoff",
	param: { 
		'0x00': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x6c SUPERVISION COMMANDS
 */

// SUPERVISION [0x6c] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x6c].command[0x01] = {
	name: "GET",
	help: "Supervision Get",
	param: { 
		'0x00a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "StatusUpdates" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "SessionId" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "EncapsulatedCommandLength" /* BYTE */ }, 
		'0x02': {name: "zwave.EncapsulatedCommand", alias: "zwaveEncapsulatedCommand", encaptype: "CMD_ENCAP" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context || 'StatusUpdates' in context || 'SessionId' in context) {
			let _properties1 = 0x00;
			if (context['Reserved']) _properties1 = _properties1 | 0x40;
			if (context['StatusUpdates']) _properties1 = _properties1 | 0x80;
			if ('SessionId' in context) _properties1 = _properties1 | ((context['SessionId']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('EncapsulatedCommandLength' in context) payload.writeBYTE(context['EncapsulatedCommandLength']); else return payload.asBuffer();
		if ('zwave.EncapsulatedCommand' in context) payload.writeBUFFER(context['zwave.EncapsulatedCommand'], { length: (payload.at(1) & 0xff) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['StatusUpdates'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['EncapsulatedCommandLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.EncapsulatedCommand'] = payload.readBUFFER({ length: payload.at(1) & 0xff }); else return context;
		return context;
	}
};

// SUPERVISION [0x6c] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x6c].command[0x02] = {
	name: "REPORT",
	help: "Supervision Report",
	param: { 
		'0x00a': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "MoreStatusUpdates" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "SessionId" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "Status" /* CONST */ }, 
		'0x02': {name: "Duration" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved' in context || 'MoreStatusUpdates' in context || 'SessionId' in context) {
			let _properties1 = 0x00;
			if (context['Reserved']) _properties1 = _properties1 | 0x40;
			if (context['MoreStatusUpdates']) _properties1 = _properties1 | 0x80;
			if ('SessionId' in context) _properties1 = _properties1 | ((context['SessionId']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_SUPERVISION_STATUS)); else return payload.asBuffer();
		if ('Duration' in context) payload.writeBYTE(context['Duration']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MoreStatusUpdates'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SessionId'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SUPERVISION_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Duration'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_SUPERVISION_STATUS = {
	NoSupport: 0x00, 
	Working: 0x01, 
	Fail: 0x02, 
	Busy: 0x03, 
	Success: 0xff, 
	enum: {
		0x00: "NoSupport", 
		0x01: "Working", 
		0x02: "Fail", 
		0x03: "Busy", 
		0xff: "Success"
	}
};



/*
 * COMMAND_CLASS 0x6d HUMIDITY_CONTROL_MODE COMMANDS
 */

// HUMIDITY_CONTROL_MODE [0x6d] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x6d].command[0x01] = {
	name: "SET",
	help: "Humidity Control Mode Set",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_HUMIDITY_CONTROL_MODE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

const ENUM_HUMIDITY_CONTROL_MODE = {
	Off: 0x00, 
	Humidify: 0x01, 
	Dehumidify: 0x02, 
	enum: {
		0x00: "Off", 
		0x01: "Humidify", 
		0x02: "Dehumidify"
	}
};

// HUMIDITY_CONTROL_MODE [0x6d] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x6d].command[0x02] = {
	name: "GET",
	help: "Humidity Control Mode Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HUMIDITY_CONTROL_MODE [0x6d] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x6d].command[0x03] = {
	name: "REPORT",
	help: "Humidity Control Mode Report",
	param: { 
		'0x00a': {name: "Mode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('Mode' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Mode', ENUM_HUMIDITY_CONTROL_MODE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_MODE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// HUMIDITY_CONTROL_MODE [0x6d] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x6d].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Humidity Control Mode Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HUMIDITY_CONTROL_MODE [0x6d] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x6d].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Humidity Control Mode Supported Report",
	param: { 
		'0x00-0': {name: "Off" /* BitMask BITMASK */ }, 
		'0x00-1': {name: "Humidify" /* BitMask BITMASK */ }, 
		'0x00-2': {name: "Dehumidify" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_HUMIDITY_CONTROL_MODE), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_HUMIDITY_CONTROL_MODE.enum);
		return context;
	}
};



/*
 * COMMAND_CLASS 0x6e HUMIDITY_CONTROL_OPERATING_STATE COMMANDS
 */

// HUMIDITY_CONTROL_OPERATING_STATE [0x6e] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x6e].command[0x01] = {
	name: "GET",
	help: "Humidity Control Operating State Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// HUMIDITY_CONTROL_OPERATING_STATE [0x6e] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x6e].command[0x02] = {
	name: "REPORT",
	help: "Humidity Control Operating State Report",
	param: { 
		'0x00a': {name: "OperatingState" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('OperatingState' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('OperatingState' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'OperatingState', ENUM_HUMIDITY_CONTROL_OPERATING_STATE)) & 0x0f); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0xf0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['OperatingState'] = helpers.lookupNameValue((_properties1 & 0x0f), ENUM_HUMIDITY_CONTROL_OPERATING_STATE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

const ENUM_HUMIDITY_CONTROL_OPERATING_STATE = {
	Idle: 0x00, 
	Humidifying: 0x01, 
	Dehumidifying: 0x02, 
	enum: {
		0x00: "Idle", 
		0x01: "Humidifying", 
		0x02: "Dehumidifying"
	}
};



/*
 * COMMAND_CLASS 0x6f ENTRY_CONTROL COMMANDS
 */

// ENTRY_CONTROL [0x6f] NOTIFICATION [0x01] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x01] = {
	name: "NOTIFICATION",
	help: "Entry Control Notification",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "DataType" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "EventType" /* CONST */ }, 
		'0x03': {name: "EventDataLength" /* BYTE */ }, 
		'0x04': {name: "EventData" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('DataType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('DataType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'DataType', ENUM_ENTRY_CONTROL_NOTIFICATION_DATA_TYPE)) & 0x03); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('EventType' in context) payload.writeBYTE(helpers.getValue(context, 'EventType', ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE)); else return payload.asBuffer();
		if ('EventDataLength' in context) payload.writeBYTE(context['EventDataLength']); else return payload.asBuffer();
		if ((payload.at(0) & 0xff) !== 0) /* optional flag for EventData */ {
			if ('EventData' in context) payload.writeSTRING(context['EventData'], { encoding: 'hex', length: (payload.at(3) & 0xff) }); else return payload.asBuffer();
		}
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DataType'] = helpers.lookupNameValue((_properties1 & 0x03), ENUM_ENTRY_CONTROL_NOTIFICATION_DATA_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['EventType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['EventDataLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['EventData'] = payload.readSTRING({ encoding: 'hex', length: payload.at(3) & 0xff }); else return context;
		return context;
	}
};

const ENUM_ENTRY_CONTROL_NOTIFICATION_DATA_TYPE = {
	NA: 0x00, 
	RAW: 0x01, 
	ASCII: 0x02, 
	MD5: 0x03, 
	enum: {
		0x00: "NA", 
		0x01: "RAW", 
		0x02: "ASCII", 
		0x03: "MD5"
	}
};

const ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE = {
	Caching: 0x00, 
	CachedKeys: 0x01, 
	Enter: 0x02, 
	DisarmAll: 0x03, 
	ArmAll: 0x04, 
	ArmAway: 0x05, 
	ArmHome: 0x06, 
	ExitDelay: 0x07, 
	Arm1: 0x08, 
	Arm2: 0x09, 
	Arm3: 0x0a, 
	Arm4: 0x0b, 
	Arm5: 0x0c, 
	Arm6: 0x0d, 
	RFID: 0x0e, 
	Bell: 0x0f, 
	Fire: 0x10, 
	Police: 0x11, 
	AlertPanic: 0x12, 
	AlertMedical: 0x13, 
	GateOpen: 0x14, 
	GateClose: 0x15, 
	Lock: 0x16, 
	Unlock: 0x17, 
	Test: 0x18, 
	Cancel: 0x19, 
	enum: {
		0x00: "Caching", 
		0x01: "CachedKeys", 
		0x02: "Enter", 
		0x03: "DisarmAll", 
		0x04: "ArmAll", 
		0x05: "ArmAway", 
		0x06: "ArmHome", 
		0x07: "ExitDelay", 
		0x08: "Arm1", 
		0x09: "Arm2", 
		0x0a: "Arm3", 
		0x0b: "Arm4", 
		0x0c: "Arm5", 
		0x0d: "Arm6", 
		0x0e: "RFID", 
		0x0f: "Bell", 
		0x10: "Fire", 
		0x11: "Police", 
		0x12: "AlertPanic", 
		0x13: "AlertMedical", 
		0x14: "GateOpen", 
		0x15: "GateClose", 
		0x16: "Lock", 
		0x17: "Unlock", 
		0x18: "Test", 
		0x19: "Cancel"
	}
};

// ENTRY_CONTROL [0x6f] KEY_SUPPORTED_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x02] = {
	name: "KEY_SUPPORTED_GET",
	help: "Entry Control Key Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ENTRY_CONTROL [0x6f] KEY_SUPPORTED_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x03] = {
	name: "KEY_SUPPORTED_REPORT",
	help: "Entry Control Key Supported Report",
	param: { 
		'0x00': {name: "KeySupportedBitMaskLength" /* BYTE */ }, 
		'0x01': {name: "KeySupportedBitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('KeySupportedBitMaskLength' in context) payload.writeBYTE(context['KeySupportedBitMaskLength']); else return payload.asBuffer();
		if ('KeySupportedBitMask' in context) payload.writeBITMASK(context['KeySupportedBitMask'], {length: payload.at(0) & 0xff}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['KeySupportedBitMaskLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeySupportedBitMask'] = payload.readBITMASK({length: payload.at(0) & 0xff}); else return context;
		return context;
	}
};

// ENTRY_CONTROL [0x6f] EVENT_SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x04] = {
	name: "EVENT_SUPPORTED_GET",
	help: "Entry Control Event Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ENTRY_CONTROL [0x6f] EVENT_SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x05] = {
	name: "EVENT_SUPPORTED_REPORT",
	help: "Entry Control Event Supported Report",
	param: { 
		'0x00a': {name: "DataTypeSupportedBitMaskLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01-0': {name: "NA" /* DataTypeSupportedBitMask BITMASK */ }, 
		'0x01-1': {name: "Raw" /* DataTypeSupportedBitMask BITMASK */ }, 
		'0x01-2': {name: "ASCII" /* DataTypeSupportedBitMask BITMASK */ }, 
		'0x01-3': {name: "MD5" /* DataTypeSupportedBitMask BITMASK */ }, 
		'0x02a': {name: "EventSupportedBitMaskLength" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }, 
		'0x03-0': {name: "Caching" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-1': {name: "CachedKeys" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-2': {name: "Enter" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-3': {name: "DisarmAll" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-4': {name: "ArmAll" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-5': {name: "ArmAway" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-6': {name: "ArmHome" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-7': {name: "ExitDelay" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-8': {name: "Arm1" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-9': {name: "Arm2" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-10': {name: "Arm3" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-11': {name: "Arm4" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-12': {name: "Arm5" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-13': {name: "Arm6" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-14': {name: "RFID" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-15': {name: "Bell" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-16': {name: "Fire" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-17': {name: "Police" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-18': {name: "AlertPanic" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-19': {name: "AlertMedical" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-20': {name: "GateOpen" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-21': {name: "GateClose" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-22': {name: "Lock" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-23': {name: "Unlock" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-24': {name: "Test" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x03-25': {name: "Cancel" /* EventTypeSupportedBitMask BITMASK */ }, 
		'0x04': {name: "KeyCachedSizeSupportedMinimum" /* BYTE */ }, 
		'0x05': {name: "KeyCachedSizeSupportedMaximum" /* BYTE */ }, 
		'0x06': {name: "KeyCachedTimeoutSupportedMinimum" /* BYTE */ }, 
		'0x07': {name: "KeyCachedTimeoutSupportedMaximum" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DataTypeSupportedBitMaskLength' in context || 'Reserved1' in context) {
			let _properties1 = 0x00;
			if ('DataTypeSupportedBitMaskLength' in context) _properties1 = _properties1 | ((context['DataTypeSupportedBitMaskLength']) & 0x03);
			if ('Reserved1' in context) _properties1 = _properties1 | ((context['Reserved1'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_ENTRY_CONTROL_EVENT_SUPPORTED_DATA_TYPE_SUPPORTED_), {length: 4});
		if ('EventSupportedBitMaskLength' in context || 'Reserved2' in context) {
			let _properties2 = 0x00;
			if ('EventSupportedBitMaskLength' in context) _properties2 = _properties2 | ((context['EventSupportedBitMaskLength']) & 0x1f);
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE), {length: 26});
		if ('KeyCachedSizeSupportedMinimum' in context) payload.writeBYTE(context['KeyCachedSizeSupportedMinimum']); else return payload.asBuffer();
		if ('KeyCachedSizeSupportedMaximum' in context) payload.writeBYTE(context['KeyCachedSizeSupportedMaximum']); else return payload.asBuffer();
		if ('KeyCachedTimeoutSupportedMinimum' in context) payload.writeBYTE(context['KeyCachedTimeoutSupportedMinimum']); else return payload.asBuffer();
		if ('KeyCachedTimeoutSupportedMaximum' in context) payload.writeBYTE(context['KeyCachedTimeoutSupportedMaximum']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DataTypeSupportedBitMaskLength'] = (_properties1 & 0x03); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		helpers.setNameFlags(context, payload.readBITMASK({length: 4}), ENUM_ENTRY_CONTROL_EVENT_SUPPORTED_DATA_TYPE_SUPPORTED_.enum);
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['EventSupportedBitMaskLength'] = (_properties2 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		helpers.setNameFlags(context, payload.readBITMASK({length: 26}), ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE.enum);
		if (!payload.insufficientBytes(1)) context['KeyCachedSizeSupportedMinimum'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeyCachedSizeSupportedMaximum'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeyCachedTimeoutSupportedMinimum'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeyCachedTimeoutSupportedMaximum'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_ENTRY_CONTROL_EVENT_SUPPORTED_DATA_TYPE_SUPPORTED_ = {
	NA: 0x00, 
	Raw: 0x01, 
	ASCII: 0x02, 
	MD5: 0x03, 
	enum: {
		0x00: "NA", 
		0x01: "Raw", 
		0x02: "ASCII", 
		0x03: "MD5"
	}
};

// ENTRY_CONTROL [0x6f] CONFIGURATION_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x06] = {
	name: "CONFIGURATION_SET",
	help: "Entry Control Configuration Set",
	param: { 
		'0x00': {name: "KeyCacheSize" /* BYTE */ }, 
		'0x01': {name: "KeyCacheTimeout" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('KeyCacheSize' in context) payload.writeBYTE(context['KeyCacheSize']); else return payload.asBuffer();
		if ('KeyCacheTimeout' in context) payload.writeBYTE(context['KeyCacheTimeout']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['KeyCacheSize'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeyCacheTimeout'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ENTRY_CONTROL [0x6f] CONFIGURATION_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x07] = {
	name: "CONFIGURATION_GET",
	help: "Entry Control Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ENTRY_CONTROL [0x6f] CONFIGURATION_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x6f].command[0x08] = {
	name: "CONFIGURATION_REPORT",
	help: "Entry Control Configuration Report",
	param: { 
		'0x00': {name: "KeyCacheSize" /* BYTE */ }, 
		'0x01': {name: "KeyCacheTimeout" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('KeyCacheSize' in context) payload.writeBYTE(context['KeyCacheSize']); else return payload.asBuffer();
		if ('KeyCacheTimeout' in context) payload.writeBYTE(context['KeyCacheTimeout']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['KeyCacheSize'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['KeyCacheTimeout'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x70 CONFIGURATION COMMANDS
 */

// CONFIGURATION [0x70] DEFAULT_RESET [0x01] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x01] = {
	name: "DEFAULT_RESET",
	help: "Configuration Default Reset",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CONFIGURATION [0x70] SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x04] = {
	name: "SET",
	help: "Configuration Set",
	param: { 
		'0x00': {name: "ParameterNumber" /* BYTE */ }, 
		'0x01a': {name: "Default" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "Size" /* Level STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "ConfigurationValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeBYTE(context['ParameterNumber']); else return payload.asBuffer();
		if ('Default' in context || 'Size' in context || 'Reserved' in context) {
			let _level = 0x00;
			if (context['Default']) _level = _level | 0x80;
			if ('Size' in context) _level = _level | ((context['Size']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0x78);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('ConfigurationValue' in context) payload.writeINTEGER(context['ConfigurationValue'], {size: payload.at(1) & 0x07, format: 0x00 /* SignedInteger */ }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readBYTE(); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Default'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0x78) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ConfigurationValue'] = payload.readINTEGER({size: payload.at(1) & 0x07, format: 0x00 /* SignedInteger */ }); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x05] = {
	name: "GET",
	help: "Configuration Get",
	param: { 
		'0x00': {name: "ParameterNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeBYTE(context['ParameterNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x06] = {
	name: "REPORT",
	help: "Configuration Report",
	param: { 
		'0x00': {name: "ParameterNumber" /* BYTE */ }, 
		'0x01a': {name: "Size" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "ConfigurationValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeBYTE(context['ParameterNumber']); else return payload.asBuffer();
		if ('Size' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('Size' in context) _level = _level | ((context['Size']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('ConfigurationValue' in context) payload.writeINTEGER(context['ConfigurationValue'], {size: payload.at(1) & 0x07, format: 0x00 /* SignedInteger */ }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readBYTE(); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ConfigurationValue'] = payload.readINTEGER({size: payload.at(1) & 0x07, format: 0x00 /* SignedInteger */ }); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] BULK_SET [0x07] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x07] = {
	name: "BULK_SET",
	help: "Configuration Bulk Set",
	param: { 
		'0x00': {name: "ParameterOffset" /* WORD */ }, 
		'0x01': {name: "NumberOfParameters" /* BYTE */ }, 
		'0x02a': {name: "Handshake" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "Default" /* Properties1 STRUCT_BYTE */ }, 
		'0x02c': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x02d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00': {name: "Parameter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterOffset' in context) payload.writeWORD(context['ParameterOffset']); else return payload.asBuffer();
		if ('NumberOfParameters' in context) payload.writeBYTE(context['NumberOfParameters']); else return payload.asBuffer();
		if ('Handshake' in context || 'Default' in context || 'Size' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Handshake']) _properties1 = _properties1 | 0x40;
			if (context['Default']) _properties1 = _properties1 | 0x80;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0x38);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(1))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Parameter' in context) payload.writeINTEGER(context['Parameter'], {size: payload.at(2) & 0x07, format: 0x00 /* SignedInteger */ }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterOffset'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfParameters'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Handshake'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Default'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x38) >> 3; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(1); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Parameter'] = payload.readINTEGER({size: payload.at(2) & 0x07, format: 0x00 /* SignedInteger */ }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// CONFIGURATION [0x70] BULK_GET [0x08] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x08] = {
	name: "BULK_GET",
	help: "Configuration Bulk Get",
	param: { 
		'0x00': {name: "ParameterOffset" /* WORD */ }, 
		'0x01': {name: "NumberOfParameters" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterOffset' in context) payload.writeWORD(context['ParameterOffset']); else return payload.asBuffer();
		if ('NumberOfParameters' in context) payload.writeBYTE(context['NumberOfParameters']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterOffset'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfParameters'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] BULK_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x09] = {
	name: "BULK_REPORT",
	help: "Configuration Bulk Report",
	param: { 
		'0x00': {name: "ParameterOffset" /* WORD */ }, 
		'0x01': {name: "NumberOfParameters" /* BYTE */ }, 
		'0x02': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x03a': {name: "Handshake" /* Properties1 STRUCT_BYTE */ }, 
		'0x03b': {name: "Default" /* Properties1 STRUCT_BYTE */ }, 
		'0x03c': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x03d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x04': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x04-0x00': {name: "Parameter" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterOffset' in context) payload.writeWORD(context['ParameterOffset']); else return payload.asBuffer();
		if ('NumberOfParameters' in context) payload.writeBYTE(context['NumberOfParameters']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('Handshake' in context || 'Default' in context || 'Size' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Handshake']) _properties1 = _properties1 | 0x40;
			if (context['Default']) _properties1 = _properties1 | 0x80;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0x38);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(1))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('Parameter' in context) payload.writeINTEGER(context['Parameter'], {size: payload.at(3) & 0x07, format: 0x00 /* SignedInteger */ }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterOffset'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfParameters'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Handshake'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Default'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x38) >> 3; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(1); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Parameter'] = payload.readINTEGER({size: payload.at(3) & 0x07, format: 0x00 /* SignedInteger */ }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// CONFIGURATION [0x70] NAME_GET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0a] = {
	name: "NAME_GET",
	help: "Configuration Name Get",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] NAME_REPORT [0x0b] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0b] = {
	name: "NAME_REPORT",
	help: "Configuration Name Report",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }, 
		'0x01': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x02': {name: "Name" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('Name' in context) payload.writeSTRING(context['Name'], { encoding: 'utf8' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Name'] = payload.readSTRING({ encoding: 'utf8' }); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] INFO_GET [0x0c] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0c] = {
	name: "INFO_GET",
	help: "Configuration Info Get",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] INFO_REPORT [0x0d] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0d] = {
	name: "INFO_REPORT",
	help: "Configuration Info Report",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }, 
		'0x01': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x02': {name: "Info" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('Info' in context) payload.writeBUFFER(context['Info'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Info'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] PROPERTIES_GET [0x0e] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0e] = {
	name: "PROPERTIES_GET",
	help: "Configuration Properties Get",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		return context;
	}
};

// CONFIGURATION [0x70] PROPERTIES_REPORT [0x0f] COMMAND 
COMMAND_CLASS.enum[0x70].command[0x0f] = {
	name: "PROPERTIES_REPORT",
	help: "Configuration Properties Report",
	param: { 
		'0x00': {name: "ParameterNumber" /* WORD */ }, 
		'0x01a': {name: "Format" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Readonly" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "ReinclusionRequired" /* Properties1 STRUCT_BYTE */ }, 
		'0x01d': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "MinValue" /* VARIANT */ }, 
		'0x03': {name: "MaxValue" /* VARIANT */ }, 
		'0x04': {name: "DefaultValue" /* VARIANT */ }, 
		'0x05': {name: "NextParameterNumber" /* WORD */ }, 
		'0x06a': {name: "Advanced" /* Properties2 STRUCT_BYTE */ }, 
		'0x06b': {name: "NoBulkSupport" /* Properties2 STRUCT_BYTE */ }, 
		'0x06c': {name: "Reserved1" /* Properties2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeWORD(context['ParameterNumber']); else return payload.asBuffer();
		if ('Format' in context || 'Readonly' in context || 'ReinclusionRequired' in context || 'Size' in context) {
			let _properties1 = 0x00;
			if ('Format' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'Format', ENUM_CONFIGURATION_PROPERTIES_FORMAT) << 3) & 0x38); 
			if (context['Readonly']) _properties1 = _properties1 | 0x40;
			if (context['ReinclusionRequired']) _properties1 = _properties1 | 0x80;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('MinValue' in context) payload.writeINTEGER(context['MinValue'], {size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return payload.asBuffer();
		if ('MaxValue' in context) payload.writeINTEGER(context['MaxValue'], {size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return payload.asBuffer();
		if ('DefaultValue' in context) payload.writeINTEGER(context['DefaultValue'], {size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return payload.asBuffer();
		if ('NextParameterNumber' in context) payload.writeWORD(context['NextParameterNumber']); else return payload.asBuffer();
		if ('Advanced' in context || 'NoBulkSupport' in context || 'Reserved1' in context) {
			let _properties2 = 0x00;
			if (context['Advanced']) _properties2 = _properties2 | 0x01;
			if (context['NoBulkSupport']) _properties2 = _properties2 | 0x02;
			if ('Reserved1' in context) _properties2 = _properties2 | ((context['Reserved1'] << 2) & 0xfc);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = payload.readWORD(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Format'] = helpers.lookupNameValue((_properties1 & 0x38) >> 3, ENUM_CONFIGURATION_PROPERTIES_FORMAT.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Readonly'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ReinclusionRequired'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinValue'] = payload.readINTEGER({size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return context;
		if (!payload.insufficientBytes(1)) context['MaxValue'] = payload.readINTEGER({size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return context;
		if (!payload.insufficientBytes(1)) context['DefaultValue'] = payload.readINTEGER({size: payload.at(1) & 0x07, format: (payload.at(1) & 0x38) >> 3 /* see ENUM */ }); else return context;
		if (!payload.insufficientBytes(1)) context['NextParameterNumber'] = payload.readWORD(); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Advanced'] = ((_properties2 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NoBulkSupport'] = ((_properties2 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_properties2 & 0xfc) >> 2; else return context;
		}
		return context;
	}
};

const ENUM_CONFIGURATION_PROPERTIES_FORMAT = {
	SignedInteger: 0x00, 
	UnsignedInteger: 0x01, 
	Enumerated: 0x02, 
	BitField: 0x03, 
	enum: {
		0x00: "SignedInteger", 
		0x01: "UnsignedInteger", 
		0x02: "Enumerated", 
		0x03: "BitField"
	}
};



/*
 * COMMAND_CLASS 0x71 NOTIFICATION COMMANDS
 */

// NOTIFICATION [0x71] EVENT_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x01] = {
	name: "EVENT_SUPPORTED_GET",
	help: "Event Supported Get",
	param: { 
		'0x00': {name: "NotificationType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NotificationType' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationType', ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NotificationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE = {
	Reserved: 0x00, 
	Smoke: 0x01, 
	CO: 0x02, 
	CO2: 0x03, 
	Heat: 0x04, 
	Water: 0x05, 
	AccessControl: 0x06, 
	HomeSecurity: 0x07, 
	PowerManagement: 0x08, 
	System: 0x09, 
	Emergency: 0x0a, 
	Clock: 0x0b, 
	Appliance: 0x0c, 
	HomeHealth: 0x0d, 
	Siren: 0x0e, 
	WaterValve: 0x0f, 
	WeatherAlarm: 0x10, 
	Irrigation: 0x11, 
	GasAlarm: 0x12, 
	First: 0xff, 
	enum: {
		0x00: "Reserved", 
		0x01: "Smoke", 
		0x02: "CO", 
		0x03: "CO2", 
		0x04: "Heat", 
		0x05: "Water", 
		0x06: "AccessControl", 
		0x07: "HomeSecurity", 
		0x08: "PowerManagement", 
		0x09: "System", 
		0x0a: "Emergency", 
		0x0b: "Clock", 
		0x0c: "Appliance", 
		0x0d: "HomeHealth", 
		0x0e: "Siren", 
		0x0f: "WaterValve", 
		0x10: "WeatherAlarm", 
		0x11: "Irrigation", 
		0x12: "GasAlarm", 
		0xff: "First"
	}
};

// NOTIFICATION [0x71] EVENT_SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x02] = {
	name: "EVENT_SUPPORTED_REPORT",
	help: "Event Supported Report",
	param: { 
		'0x00': {name: "NotificationType" /* CONST */ }, 
		'0x01a': {name: "NumberOfBitMasks" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "BitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NotificationType' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationType', ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE)); else return payload.asBuffer();
		if ('NumberOfBitMasks' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('NumberOfBitMasks' in context) _properties1 = _properties1 | ((context['NumberOfBitMasks']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('BitMask' in context) payload.writeBITMASK(context['BitMask'], {length: payload.at(1) & 0x1f}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NotificationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['NumberOfBitMasks'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['BitMask'] = payload.readBITMASK({length: payload.at(1) & 0x1f}); else return context;
		return context;
	}
};

// NOTIFICATION [0x71] GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x04] = {
	name: "GET",
	help: "Notification Get",
	param: { 
		'0x00': {name: "V1AlarmType" /* BYTE */ }, 
		'0x01': {name: "NotificationType" /* CONST */ }, 
		'0x02': {name: "Event" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('V1AlarmType' in context) payload.writeBYTE(context['V1AlarmType']); else return payload.asBuffer();
		if ('NotificationType' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationType', ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE)); else return payload.asBuffer();
		if ('Event' in context) payload.writeBYTE(context['Event']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['V1AlarmType'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NotificationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Event'] = payload.readBYTE(); else return context;
		return context;
	}
};

// NOTIFICATION [0x71] REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x05] = {
	name: "REPORT",
	help: "Notification Report",
	param: { 
		'0x00': {name: "V1AlarmType" /* BYTE */ }, 
		'0x01': {name: "V1AlarmLevel" /* BYTE */ }, 
		'0x02': {name: "Reserved" /* BYTE */ }, 
		'0x03': {name: "NotificationStatus" /* CONST */ }, 
		'0x04': {name: "NotificationType" /* CONST */ }, 
		'0x05': {name: "Event" /* BYTE */ }, 
		'0x06a': {name: "Sequence" /* Properties1 STRUCT_BYTE */ }, 
		'0x06b': {name: "EventParametersLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x06c': {name: "Reserved2" /* Properties1 STRUCT_BYTE */ }, 
		'0x07': {name: "EventParameter" /* VARIANT */ }, 
		'0x08': {name: "SequenceNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('V1AlarmType' in context) payload.writeBYTE(context['V1AlarmType']); else return payload.asBuffer();
		if ('V1AlarmLevel' in context) payload.writeBYTE(context['V1AlarmLevel']); else return payload.asBuffer();
		if ('Reserved' in context) payload.writeBYTE(context['Reserved']); else return payload.asBuffer();
		if ('NotificationStatus' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationStatus', ENUM_NOTIFICATION_NOTIFICATION_STATUS)); else return payload.asBuffer();
		if ('NotificationType' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationType', ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE)); else return payload.asBuffer();
		if ('Event' in context) payload.writeBYTE(context['Event']); else return payload.asBuffer();
		if ('Sequence' in context || 'EventParametersLength' in context || 'Reserved2' in context) {
			let _properties1 = 0x00;
			if (context['Sequence']) _properties1 = _properties1 | 0x80;
			if ('EventParametersLength' in context) _properties1 = _properties1 | ((context['EventParametersLength']) & 0x1f);
			if ('Reserved2' in context) _properties1 = _properties1 | ((context['Reserved2'] << 5) & 0x60);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('EventParameter' in context) payload.writeSTRING(context['EventParameter'], { encoding: 'hex', length: (payload.at(6) & 0x1f) }); else return payload.asBuffer();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['V1AlarmType'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['V1AlarmLevel'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Reserved'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NotificationStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_NOTIFICATION_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NotificationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Event'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Sequence'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['EventParametersLength'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties1 & 0x60) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['EventParameter'] = payload.readSTRING({ encoding: 'hex', length: payload.at(6) & 0x1f }); else return context;
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_NOTIFICATION_NOTIFICATION_STATUS = {
	Off: 0x00, 
	NoPendingNotifications: 0xfe, 
	On: 0xff, 
	enum: {
		0x00: "Off", 
		0xfe: "NoPendingNotifications", 
		0xff: "On"
	}
};

// NOTIFICATION [0x71] SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x06] = {
	name: "SET",
	help: "Notification Set",
	param: { 
		'0x00': {name: "NotificationType" /* CONST */ }, 
		'0x01': {name: "NotificationStatus" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NotificationType' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationType', ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE)); else return payload.asBuffer();
		if ('NotificationStatus' in context) payload.writeBYTE(helpers.getValue(context, 'NotificationStatus', ENUM_NOTIFICATION_NOTIFICATION_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NotificationType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NotificationStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_NOTIFICATION_NOTIFICATION_STATUS.enum); else return context;
		return context;
	}
};

// NOTIFICATION [0x71] SUPPORTED_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x07] = {
	name: "SUPPORTED_GET",
	help: "Notification Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// NOTIFICATION [0x71] SUPPORTED_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x71].command[0x08] = {
	name: "SUPPORTED_REPORT",
	help: "Notification Supported Report",
	param: { 
		'0x00a': {name: "V1Alarm" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "NumberOfBitMasks" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01-0': {name: "Reserved" /* BitMask BITMASK */ }, 
		'0x01-1': {name: "Smoke" /* BitMask BITMASK */ }, 
		'0x01-2': {name: "CO" /* BitMask BITMASK */ }, 
		'0x01-3': {name: "CO2" /* BitMask BITMASK */ }, 
		'0x01-4': {name: "Heat" /* BitMask BITMASK */ }, 
		'0x01-5': {name: "Water" /* BitMask BITMASK */ }, 
		'0x01-6': {name: "AccessControl" /* BitMask BITMASK */ }, 
		'0x01-7': {name: "HomeSecurity" /* BitMask BITMASK */ }, 
		'0x01-8': {name: "PowerManagement" /* BitMask BITMASK */ }, 
		'0x01-9': {name: "System" /* BitMask BITMASK */ }, 
		'0x01-10': {name: "Emergency" /* BitMask BITMASK */ }, 
		'0x01-11': {name: "Clock" /* BitMask BITMASK */ }, 
		'0x01-12': {name: "Appliance" /* BitMask BITMASK */ }, 
		'0x01-13': {name: "HomeHealth" /* BitMask BITMASK */ }, 
		'0x01-14': {name: "Siren" /* BitMask BITMASK */ }, 
		'0x01-15': {name: "WaterValve" /* BitMask BITMASK */ }, 
		'0x01-16': {name: "WeatherAlarm" /* BitMask BITMASK */ }, 
		'0x01-17': {name: "Irrigation" /* BitMask BITMASK */ }, 
		'0x01-18': {name: "GasAlarm" /* BitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('V1Alarm' in context || 'NumberOfBitMasks' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['V1Alarm']) _properties1 = _properties1 | 0x80;
			if ('NumberOfBitMasks' in context) _properties1 = _properties1 | ((context['NumberOfBitMasks']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0x60);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE), {length: 19});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['V1Alarm'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfBitMasks'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x60) >> 5; else return context;
		}
		helpers.setNameFlags(context, payload.readBITMASK({length: 19}), ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE.enum);
		return context;
	}
};



/*
 * COMMAND_CLASS 0x72 MANUFACTURER_SPECIFIC COMMANDS
 */

// MANUFACTURER_SPECIFIC [0x72] GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x72].command[0x04] = {
	name: "GET",
	help: "Manufacturer Specific Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// MANUFACTURER_SPECIFIC [0x72] REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x72].command[0x05] = {
	name: "REPORT",
	help: "Manufacturer Specific Report",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "ProductTypeId" /* WORD */ }, 
		'0x02': {name: "ProductId" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('ProductTypeId' in context) payload.writeWORD(context['ProductTypeId']); else return payload.asBuffer();
		if ('ProductId' in context) payload.writeWORD(context['ProductId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ProductTypeId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['ProductId'] = payload.readWORD(); else return context;
		return context;
	}
};

// MANUFACTURER_SPECIFIC [0x72] DEVICE_SPECIFIC_GET [0x06] COMMAND 
COMMAND_CLASS.enum[0x72].command[0x06] = {
	name: "DEVICE_SPECIFIC_GET",
	help: "Device Specific Get",
	param: { 
		'0x00a': {name: "DeviceIdType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DeviceIdType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('DeviceIdType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'DeviceIdType', ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE)) & 0x07); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DeviceIdType'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		return context;
	}
};

const ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE = {
	Reserved: 0x00, 
	SerialNumber: 0x01, 
	enum: {
		0x00: "Reserved", 
		0x01: "SerialNumber"
	}
};

// MANUFACTURER_SPECIFIC [0x72] DEVICE_SPECIFIC_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x72].command[0x07] = {
	name: "DEVICE_SPECIFIC_REPORT",
	help: "Device Specific Report",
	param: { 
		'0x00a': {name: "DeviceIdType" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01a': {name: "DeviceIdDataFormat" /* Properties2 STRUCT_BYTE */ }, 
		'0x01b': {name: "DeviceIdDataLengthIndicator" /* Properties2 STRUCT_BYTE */ }, 
		'0x02': {name: "DeviceIdData" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('DeviceIdType' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('DeviceIdType' in context) _properties1 = _properties1 | ((helpers.getValue(context, 'DeviceIdType', ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE)) & 0x07); 
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('DeviceIdDataFormat' in context || 'DeviceIdDataLengthIndicator' in context) {
			let _properties2 = 0x00;
			if ('DeviceIdDataFormat' in context) _properties2 = _properties2 | ((helpers.getValue(context, 'DeviceIdDataFormat', ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_DATA_FORMAT) << 5) & 0xe0); 
			if ('DeviceIdDataLengthIndicator' in context) _properties2 = _properties2 | ((context['DeviceIdDataLengthIndicator']) & 0x1f);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('DeviceIdData' in context) payload.writeSTRING(context['DeviceIdData'], { encoding: 'hex', length: (payload.at(1) & 0x1f) }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DeviceIdType'] = helpers.lookupNameValue((_properties1 & 0x07), ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['DeviceIdDataFormat'] = helpers.lookupNameValue((_properties2 & 0xe0) >> 5, ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_DATA_FORMAT.enum); else return context;
			if (!payload.insufficientBytes(1)) context['DeviceIdDataLengthIndicator'] = (_properties2 & 0x1f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['DeviceIdData'] = payload.readSTRING({ encoding: 'hex', length: payload.at(1) & 0x1f }); else return context;
		return context;
	}
};

const ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_DATA_FORMAT = {
	Reserved: 0x00, 
	Binary: 0x01, 
	enum: {
		0x00: "Reserved", 
		0x01: "Binary"
	}
};



/*
 * COMMAND_CLASS 0x73 POWERLEVEL COMMANDS
 */

// POWERLEVEL [0x73] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x01] = {
	name: "SET",
	help: "Powerlevel Set",
	param: { 
		'0x00': {name: "PowerLevel" /* CONST */ }, 
		'0x01': {name: "Timeout" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PowerLevel' in context) payload.writeBYTE(helpers.getValue(context, 'PowerLevel', ENUM_POWERLEVEL_POWER_LEVEL)); else return payload.asBuffer();
		if ('Timeout' in context) payload.writeBYTE(context['Timeout']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PowerLevel'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_POWERLEVEL_POWER_LEVEL.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Timeout'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_POWERLEVEL_POWER_LEVEL = {
	NormalPower: 0x00, 
	minus1dBm: 0x01, 
	minus2dBm: 0x02, 
	minus3dBm: 0x03, 
	minus4dBm: 0x04, 
	minus5dBm: 0x05, 
	minus6dBm: 0x06, 
	minus7dBm: 0x07, 
	minus8dBm: 0x08, 
	minus9dBm: 0x09, 
	enum: {
		0x00: "NormalPower", 
		0x01: "minus1dBm", 
		0x02: "minus2dBm", 
		0x03: "minus3dBm", 
		0x04: "minus4dBm", 
		0x05: "minus5dBm", 
		0x06: "minus6dBm", 
		0x07: "minus7dBm", 
		0x08: "minus8dBm", 
		0x09: "minus9dBm"
	}
};

// POWERLEVEL [0x73] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x02] = {
	name: "GET",
	help: "Powerlevel Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// POWERLEVEL [0x73] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x03] = {
	name: "REPORT",
	help: "Powerlevel Report",
	param: { 
		'0x00': {name: "PowerLevel" /* CONST */ }, 
		'0x01': {name: "Timeout" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('PowerLevel' in context) payload.writeBYTE(helpers.getValue(context, 'PowerLevel', ENUM_POWERLEVEL_POWER_LEVEL)); else return payload.asBuffer();
		if ('Timeout' in context) payload.writeBYTE(context['Timeout']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['PowerLevel'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_POWERLEVEL_POWER_LEVEL.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Timeout'] = payload.readBYTE(); else return context;
		return context;
	}
};

// POWERLEVEL [0x73] TEST_NODE_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x04] = {
	name: "TEST_NODE_SET",
	help: "Powerlevel Test Node Set",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "PowerLevel" /* CONST */ }, 
		'0x02': {name: "TestFrameCount" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('PowerLevel' in context) payload.writeBYTE(helpers.getValue(context, 'PowerLevel', ENUM_POWERLEVEL_POWER_LEVEL)); else return payload.asBuffer();
		if ('TestFrameCount' in context) payload.writeWORD(context['TestFrameCount']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['PowerLevel'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_POWERLEVEL_POWER_LEVEL.enum); else return context;
		if (!payload.insufficientBytes(1)) context['TestFrameCount'] = payload.readWORD(); else return context;
		return context;
	}
};

// POWERLEVEL [0x73] TEST_NODE_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x05] = {
	name: "TEST_NODE_GET",
	help: "Powerlevel Test Node Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// POWERLEVEL [0x73] TEST_NODE_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x73].command[0x06] = {
	name: "TEST_NODE_REPORT",
	help: "Powerlevel Test Node Report",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* CONST */ }, 
		'0x01': {name: "StatusOfOperation" /* CONST */ }, 
		'0x02': {name: "TestFrameCount" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(helpers.getValue(context, 'zwave.NodeId', ENUM_POWERLEVEL_TEST_NODE_ZWAVE_NODE_ID)); else return payload.asBuffer();
		if ('StatusOfOperation' in context) payload.writeBYTE(helpers.getValue(context, 'StatusOfOperation', ENUM_POWERLEVEL_TEST_NODE_STATUS_OF_OPERATION)); else return payload.asBuffer();
		if ('TestFrameCount' in context) payload.writeWORD(context['TestFrameCount']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_POWERLEVEL_TEST_NODE_ZWAVE_NODE_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['StatusOfOperation'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_POWERLEVEL_TEST_NODE_STATUS_OF_OPERATION.enum); else return context;
		if (!payload.insufficientBytes(1)) context['TestFrameCount'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_POWERLEVEL_TEST_NODE_ZWAVE_NODE_ID = {
	ZwTestNotANodeid: 0x00, 
	enum: {
		0x00: "ZwTestNotANodeid"
	}
};

const ENUM_POWERLEVEL_TEST_NODE_STATUS_OF_OPERATION = {
	ZwTestFailed: 0x00, 
	ZwTestSucces: 0x01, 
	ZwTestInprogress: 0x02, 
	enum: {
		0x00: "ZwTestFailed", 
		0x01: "ZwTestSucces", 
		0x02: "ZwTestInprogress"
	}
};



/*
 * COMMAND_CLASS 0x74 INCLUSION_CONTROLLER COMMANDS
 */

// INCLUSION_CONTROLLER [0x74] INITIATE [0x01] COMMAND 
COMMAND_CLASS.enum[0x74].command[0x01] = {
	name: "INITIATE",
	help: "Initiate",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "StepId" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('StepId' in context) payload.writeBYTE(helpers.getValue(context, 'StepId', ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['StepId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID.enum); else return context;
		return context;
	}
};

const ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID = {
	ProxyInclusion: 0x01, 
	S0Inclusion: 0x02, 
	enum: {
		0x01: "ProxyInclusion", 
		0x02: "S0Inclusion"
	}
};

// INCLUSION_CONTROLLER [0x74] COMPLETE [0x02] COMMAND 
COMMAND_CLASS.enum[0x74].command[0x02] = {
	name: "COMPLETE",
	help: "Complete",
	param: { 
		'0x00': {name: "StepId" /* CONST */ }, 
		'0x01': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('StepId' in context) payload.writeBYTE(helpers.getValue(context, 'StepId', ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID)); else return payload.asBuffer();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_INCLUSION_CONTROLLER_COMPLETE_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['StepId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INCLUSION_CONTROLLER_COMPLETE_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_INCLUSION_CONTROLLER_COMPLETE_STATUS = {
	StepOk: 0x01, 
	StepUserRejected: 0x02, 
	StepFailed: 0x03, 
	StepNotSupported: 0x04, 
	enum: {
		0x01: "StepOk", 
		0x02: "StepUserRejected", 
		0x03: "StepFailed", 
		0x04: "StepNotSupported"
	}
};



/*
 * COMMAND_CLASS 0x75 PROTECTION COMMANDS
 */

// PROTECTION [0x75] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x01] = {
	name: "SET",
	help: "Protection Set",
	param: { 
		'0x00a': {name: "LocalProtectionState" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Level STRUCT_BYTE */ }, 
		'0x01a': {name: "RfProtectionState" /* Level2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved2" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LocalProtectionState' in context || 'Reserved1' in context) {
			let _level = 0x00;
			if ('LocalProtectionState' in context) _level = _level | ((context['LocalProtectionState']) & 0x0f);
			if ('Reserved1' in context) _level = _level | ((context['Reserved1'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('RfProtectionState' in context || 'Reserved2' in context) {
			let _level2 = 0x00;
			if ('RfProtectionState' in context) _level2 = _level2 | ((context['RfProtectionState']) & 0x0f);
			if ('Reserved2' in context) _level2 = _level2 | ((context['Reserved2'] << 4) & 0xf0);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LocalProtectionState'] = (_level & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_level & 0xf0) >> 4; else return context;
		}
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RfProtectionState'] = (_level2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_level2 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// PROTECTION [0x75] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x02] = {
	name: "GET",
	help: "Protection Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// PROTECTION [0x75] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x03] = {
	name: "REPORT",
	help: "Protection Report",
	param: { 
		'0x00a': {name: "LocalProtectionState" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved1" /* Level STRUCT_BYTE */ }, 
		'0x01a': {name: "RfProtectionState" /* Level2 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved2" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LocalProtectionState' in context || 'Reserved1' in context) {
			let _level = 0x00;
			if ('LocalProtectionState' in context) _level = _level | ((context['LocalProtectionState']) & 0x0f);
			if ('Reserved1' in context) _level = _level | ((context['Reserved1'] << 4) & 0xf0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('RfProtectionState' in context || 'Reserved2' in context) {
			let _level2 = 0x00;
			if ('RfProtectionState' in context) _level2 = _level2 | ((context['RfProtectionState']) & 0x0f);
			if ('Reserved2' in context) _level2 = _level2 | ((context['Reserved2'] << 4) & 0xf0);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LocalProtectionState'] = (_level & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved1'] = (_level & 0xf0) >> 4; else return context;
		}
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RfProtectionState'] = (_level2 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_level2 & 0xf0) >> 4; else return context;
		}
		return context;
	}
};

// PROTECTION [0x75] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Protection Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// PROTECTION [0x75] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Protection Supported Report",
	param: { 
		'0x00a': {name: "Timeout" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "ExclusiveControl" /* Level STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "LocalProtectionState" /* WORD */ }, 
		'0x02': {name: "RfProtectionState" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Timeout' in context || 'ExclusiveControl' in context || 'Reserved' in context) {
			let _level = 0x00;
			if (context['Timeout']) _level = _level | 0x01;
			if (context['ExclusiveControl']) _level = _level | 0x02;
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('LocalProtectionState' in context) payload.writeWORD(context['LocalProtectionState']); else return payload.asBuffer();
		if ('RfProtectionState' in context) payload.writeWORD(context['RfProtectionState']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Timeout'] = ((_level & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ExclusiveControl'] = ((_level & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['LocalProtectionState'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['RfProtectionState'] = payload.readWORD(); else return context;
		return context;
	}
};

// PROTECTION [0x75] EC_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x06] = {
	name: "EC_SET",
	help: "Protection Ec Set",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// PROTECTION [0x75] EC_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x07] = {
	name: "EC_GET",
	help: "Protection Ec Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// PROTECTION [0x75] EC_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x08] = {
	name: "EC_REPORT",
	help: "Protection Ec Report",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// PROTECTION [0x75] TIMEOUT_SET [0x09] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x09] = {
	name: "TIMEOUT_SET",
	help: "Protection Timeout Set",
	param: { 
		'0x00': {name: "Timeout" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Timeout' in context) payload.writeBYTE(helpers.getValue(context, 'Timeout', ENUM_PROTECTION_TIMEOUT)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Timeout'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_PROTECTION_TIMEOUT.enum); else return context;
		return context;
	}
};

const ENUM_PROTECTION_TIMEOUT = {
	NoTimerIsSet: 0x00, 
	NoTimeout: 0xff, 
	enum: {
		0x00: "NoTimerIsSet", 
		0xff: "NoTimeout"
	}
};

// PROTECTION [0x75] TIMEOUT_GET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x0a] = {
	name: "TIMEOUT_GET",
	help: "Protection Timeout Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// PROTECTION [0x75] TIMEOUT_REPORT [0x0b] COMMAND 
COMMAND_CLASS.enum[0x75].command[0x0b] = {
	name: "TIMEOUT_REPORT",
	help: "Protection Timeout Report",
	param: { 
		'0x00': {name: "Timeout" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Timeout' in context) payload.writeBYTE(helpers.getValue(context, 'Timeout', ENUM_PROTECTION_TIMEOUT_REPORT_TIMEOUT)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Timeout'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_PROTECTION_TIMEOUT_REPORT_TIMEOUT.enum); else return context;
		return context;
	}
};

const ENUM_PROTECTION_TIMEOUT_REPORT_TIMEOUT = {
	NoTimerIsSet: 0x00, 
	NoTimeoutIsSet: 0xff, 
	enum: {
		0x00: "NoTimerIsSet", 
		0xff: "NoTimeoutIsSet"
	}
};



/*
 * COMMAND_CLASS 0x76 LOCK COMMANDS
 */

// LOCK [0x76] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x76].command[0x01] = {
	name: "SET",
	help: "Lock Set",
	param: { 
		'0x00': {name: "LockState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LockState' in context) payload.writeBYTE(helpers.getValue(context, 'LockState', ENUM_LOCK_LOCK_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LockState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_LOCK_LOCK_STATE.enum); else return context;
		return context;
	}
};

const ENUM_LOCK_LOCK_STATE = {
	Unlocked: 0x00, 
	Locked: 0x01, 
	enum: {
		0x00: "Unlocked", 
		0x01: "Locked"
	}
};

// LOCK [0x76] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x76].command[0x02] = {
	name: "GET",
	help: "Lock Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// LOCK [0x76] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x76].command[0x03] = {
	name: "REPORT",
	help: "Lock Report",
	param: { 
		'0x00': {name: "LockState" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LockState' in context) payload.writeBYTE(helpers.getValue(context, 'LockState', ENUM_LOCK_LOCK_STATE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LockState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_LOCK_LOCK_STATE.enum); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x77 NODE_NAMING COMMANDS
 */

// NODE_NAMING [0x77] NODE_NAME_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x01] = {
	name: "NODE_NAME_SET",
	help: "Node Naming Node Name Set",
	param: { 
		'0x00a': {name: "CharPresentation" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "NodeNameChar" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('CharPresentation' in context) _level = _level | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('NodeNameChar' in context) payload.writeSTRING(context['NodeNameChar'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['NodeNameChar'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};

// NODE_NAMING [0x77] NODE_NAME_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x02] = {
	name: "NODE_NAME_GET",
	help: "Node Naming Node Name Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// NODE_NAMING [0x77] NODE_NAME_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x03] = {
	name: "NODE_NAME_REPORT",
	help: "Node Naming Node Name Report",
	param: { 
		'0x00a': {name: "CharPresentation" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "NodeNameChar" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('CharPresentation' in context) _level = _level | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('NodeNameChar' in context) payload.writeSTRING(context['NodeNameChar'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['NodeNameChar'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};

// NODE_NAMING [0x77] NODE_LOCATION_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x04] = {
	name: "NODE_LOCATION_SET",
	help: "Node Naming Node Location  Set",
	param: { 
		'0x00a': {name: "CharPresentation" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "NodeLocationChar" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('CharPresentation' in context) _level = _level | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('NodeLocationChar' in context) payload.writeSTRING(context['NodeLocationChar'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['NodeLocationChar'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};

// NODE_NAMING [0x77] NODE_LOCATION_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x05] = {
	name: "NODE_LOCATION_GET",
	help: "Node Naming Node Location Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// NODE_NAMING [0x77] NODE_LOCATION_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x77].command[0x06] = {
	name: "NODE_LOCATION_REPORT",
	help: "Node Naming Node Location  Report",
	param: { 
		'0x00a': {name: "CharPresentation" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "NodeLocationChar" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _level = 0x00;
			if ('CharPresentation' in context) _level = _level | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _level = _level | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('NodeLocationChar' in context) payload.writeSTRING(context['NodeLocationChar'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_level & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['NodeLocationChar'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x7a FIRMWARE_UPDATE_MD COMMANDS
 */

// FIRMWARE_UPDATE_MD [0x7a] FIRMWARE_MD_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x01] = {
	name: "FIRMWARE_MD_GET",
	help: "Firmware Md Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// FIRMWARE_UPDATE_MD [0x7a] FIRMWARE_MD_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x02] = {
	name: "FIRMWARE_MD_REPORT",
	help: "Firmware Md Report",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "Firmware0Id" /* WORD */ }, 
		'0x02': {name: "Firmware0Checksum" /* WORD */ }, 
		'0x03': {name: "FirmwareUpgradable" /* BYTE */ }, 
		'0x04': {name: "NumberOfFirmwareTargets" /* BYTE */ }, 
		'0x05': {name: "MaxFragmentSize" /* WORD */ }, 
		'0x06': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x06-0x00': {name: "FirmwareId" /* WORD */ }, 
		'0x07': {name: "HardwareVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('Firmware0Id' in context) payload.writeWORD(context['Firmware0Id']); else return payload.asBuffer();
		if ('Firmware0Checksum' in context) payload.writeWORD(context['Firmware0Checksum']); else return payload.asBuffer();
		if ('FirmwareUpgradable' in context) payload.writeBYTE(context['FirmwareUpgradable']); else return payload.asBuffer();
		if ('NumberOfFirmwareTargets' in context) payload.writeBYTE(context['NumberOfFirmwareTargets']); else return payload.asBuffer();
		if ('MaxFragmentSize' in context) payload.writeWORD(context['MaxFragmentSize']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(4))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('FirmwareId' in context) payload.writeWORD(context['FirmwareId']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Firmware0Id'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Firmware0Checksum'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareUpgradable'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfFirmwareTargets'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxFragmentSize'] = payload.readWORD(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(4); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['FirmwareId'] = payload.readWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] REQUEST_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x03] = {
	name: "REQUEST_GET",
	help: "Firmware Update Md Request Get",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "FirmwareId" /* WORD */ }, 
		'0x02': {name: "Checksum" /* WORD */ }, 
		'0x03': {name: "FirmwareTarget" /* BYTE */ }, 
		'0x04': {name: "FragmentSize" /* WORD */ }, 
		'0x05a': {name: "Activation" /* Properties1 STRUCT_BYTE */ }, 
		'0x05b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x06': {name: "HardwareVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('FirmwareId' in context) payload.writeWORD(context['FirmwareId']); else return payload.asBuffer();
		if ('Checksum' in context) payload.writeWORD(context['Checksum']); else return payload.asBuffer();
		if ('FirmwareTarget' in context) payload.writeBYTE(context['FirmwareTarget']); else return payload.asBuffer();
		if ('FragmentSize' in context) payload.writeWORD(context['FragmentSize']); else return payload.asBuffer();
		if ('Activation' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Activation']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Checksum'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareTarget'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['FragmentSize'] = payload.readWORD(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Activation'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] REQUEST_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x04] = {
	name: "REQUEST_REPORT",
	help: "Firmware Update Md Request Report",
	param: { 
		'0x00': {name: "Status" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS.enum); else return context;
		return context;
	}
};

const ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS = {
	InvalidCombination: 0x00, 
	RequiresAuthentication: 0x01, 
	InvalidFragmentSize: 0x02, 
	NotUpgradable: 0x03, 
	InvalidHardwareVersion: 0x04, 
	ValidCombination: 0xff, 
	enum: {
		0x00: "InvalidCombination", 
		0x01: "RequiresAuthentication", 
		0x02: "InvalidFragmentSize", 
		0x03: "NotUpgradable", 
		0x04: "InvalidHardwareVersion", 
		0xff: "ValidCombination"
	}
};

// FIRMWARE_UPDATE_MD [0x7a] GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x05] = {
	name: "GET",
	help: "Firmware Update Md Get",
	param: { 
		'0x00': {name: "NumberOfReports" /* BYTE */ }, 
		'0x01a': {name: "Zero" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "ReportNumber1" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "ReportNumber2" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfReports' in context) payload.writeBYTE(context['NumberOfReports']); else return payload.asBuffer();
		if ('Zero' in context || 'ReportNumber1' in context) {
			let _properties1 = 0x00;
			if (context['Zero']) _properties1 = _properties1 | 0x80;
			if ('ReportNumber1' in context) _properties1 = _properties1 | ((context['ReportNumber1']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ReportNumber2' in context) payload.writeBYTE(context['ReportNumber2']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfReports'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Zero'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ReportNumber1'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['ReportNumber2'] = payload.readBYTE(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x06] = {
	name: "REPORT",
	help: "Firmware Update Md Report",
	param: { 
		'0x00a': {name: "Last" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "ReportNumber1" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "ReportNumber2" /* BYTE */ }, 
		'0x02': {name: "Data" /* VARIANT */ }, 
		'0x03': {name: "Checksum" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Last' in context || 'ReportNumber1' in context) {
			let _properties1 = 0x00;
			if (context['Last']) _properties1 = _properties1 | 0x80;
			if ('ReportNumber1' in context) _properties1 = _properties1 | ((context['ReportNumber1']) & 0x7f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ReportNumber2' in context) payload.writeBYTE(context['ReportNumber2']); else return payload.asBuffer();
		if ('Data' in context) payload.writeSTRING(context['Data'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('Checksum' in context) payload.writeWORD(context['Checksum']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Last'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ReportNumber1'] = (_properties1 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['ReportNumber2'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Data'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['Checksum'] = payload.readWORD(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] STATUS_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x07] = {
	name: "STATUS_REPORT",
	help: "Firmware Update Md Status Report",
	param: { 
		'0x00': {name: "Status" /* CONST */ }, 
		'0x01': {name: "WaitTime" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_FIRMWARE_UPDATE_MD_STATUS)); else return payload.asBuffer();
		if ('WaitTime' in context) payload.writeWORD(context['WaitTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_FIRMWARE_UPDATE_MD_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['WaitTime'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_FIRMWARE_UPDATE_MD_STATUS = {
	UnableToReceiveWithoutChecksumError: 0x00, 
	UnableToReceive: 0x01, 
	DoesNotMatchTheManufacturerId: 0x02, 
	DoesNotMatchTheFirmwareId: 0x03, 
	DoesNotMatchTheFirmwareTarget: 0x04, 
	InvalidFileHeaderInformation: 0x05, 
	InvalidFileHeaderFormat: 0x06, 
	InsufficientMemory: 0x07, 
	DoesNotMatchTheHardwareVersion: 0x08, 
	SuccessfullyWaitingForActivation: 0xfd, 
	SuccessfullyStored: 0xfe, 
	Successfully: 0xff, 
	enum: {
		0x00: "UnableToReceiveWithoutChecksumError", 
		0x01: "UnableToReceive", 
		0x02: "DoesNotMatchTheManufacturerId", 
		0x03: "DoesNotMatchTheFirmwareId", 
		0x04: "DoesNotMatchTheFirmwareTarget", 
		0x05: "InvalidFileHeaderInformation", 
		0x06: "InvalidFileHeaderFormat", 
		0x07: "InsufficientMemory", 
		0x08: "DoesNotMatchTheHardwareVersion", 
		0xfd: "SuccessfullyWaitingForActivation", 
		0xfe: "SuccessfullyStored", 
		0xff: "Successfully"
	}
};

// FIRMWARE_UPDATE_MD [0x7a] FIRMWARE_UPDATE_ACTIVATION_SET [0x08] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x08] = {
	name: "FIRMWARE_UPDATE_ACTIVATION_SET",
	help: "Firmware Update Activation Set Command",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "FirmwareId" /* WORD */ }, 
		'0x02': {name: "Checksum" /* WORD */ }, 
		'0x03': {name: "FirmwareTarget" /* BYTE */ }, 
		'0x04': {name: "HardwareVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('FirmwareId' in context) payload.writeWORD(context['FirmwareId']); else return payload.asBuffer();
		if ('Checksum' in context) payload.writeWORD(context['Checksum']); else return payload.asBuffer();
		if ('FirmwareTarget' in context) payload.writeBYTE(context['FirmwareTarget']); else return payload.asBuffer();
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Checksum'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareTarget'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] FIRMWARE_UPDATE_ACTIVATION_STATUS_REPORT [0x09] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x09] = {
	name: "FIRMWARE_UPDATE_ACTIVATION_STATUS_REPORT",
	help: "Firmware Update Activation Status Report",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "FirmwareId" /* BYTE */ }, 
		'0x02': {name: "Checksum" /* WORD */ }, 
		'0x03': {name: "FirmwareTarget" /* BYTE */ }, 
		'0x04': {name: "FirmwareUpdateStatus" /* CONST */ }, 
		'0x05': {name: "HardwareVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('FirmwareId' in context) payload.writeBYTE(context['FirmwareId']); else return payload.asBuffer();
		if ('Checksum' in context) payload.writeWORD(context['Checksum']); else return payload.asBuffer();
		if ('FirmwareTarget' in context) payload.writeBYTE(context['FirmwareTarget']); else return payload.asBuffer();
		if ('FirmwareUpdateStatus' in context) payload.writeBYTE(helpers.getValue(context, 'FirmwareUpdateStatus', ENUM_FIRMWARE_UPDATE_MD_FIRMWARE_UPDATE_ACTIVATION_STATUS_FIRMWARE_UPDATE_STATUS)); else return payload.asBuffer();
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Checksum'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareTarget'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareUpdateStatus'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_FIRMWARE_UPDATE_MD_FIRMWARE_UPDATE_ACTIVATION_STATUS_FIRMWARE_UPDATE_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_FIRMWARE_UPDATE_MD_FIRMWARE_UPDATE_ACTIVATION_STATUS_FIRMWARE_UPDATE_STATUS = {
	InvalidCombination: 0x00, 
	ErrorActivatingTheFirmware: 0x01, 
	FirmwareUpdateCompletedSuccessfully: 0xff, 
	enum: {
		0x00: "InvalidCombination", 
		0x01: "ErrorActivatingTheFirmware", 
		0xff: "FirmwareUpdateCompletedSuccessfully"
	}
};

// FIRMWARE_UPDATE_MD [0x7a] PREPARE_GET [0x0a] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x0a] = {
	name: "PREPARE_GET",
	help: "Firmware Update MD Prepare Get",
	param: { 
		'0x00': {name: "ManufacturerId" /* WORD */ }, 
		'0x01': {name: "FirmwareId" /* WORD */ }, 
		'0x02': {name: "FirmwareTarget" /* BYTE */ }, 
		'0x03': {name: "FragmentSize" /* WORD */ }, 
		'0x04': {name: "HardwareVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ManufacturerId' in context) payload.writeWORD(context['ManufacturerId']); else return payload.asBuffer();
		if ('FirmwareId' in context) payload.writeWORD(context['FirmwareId']); else return payload.asBuffer();
		if ('FirmwareTarget' in context) payload.writeBYTE(context['FirmwareTarget']); else return payload.asBuffer();
		if ('FragmentSize' in context) payload.writeWORD(context['FragmentSize']); else return payload.asBuffer();
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ManufacturerId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareId'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareTarget'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['FragmentSize'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};

// FIRMWARE_UPDATE_MD [0x7a] PREPARE_REPORT [0x0b] COMMAND 
COMMAND_CLASS.enum[0x7a].command[0x0b] = {
	name: "PREPARE_REPORT",
	help: "Firmware Update MD Prepare Report",
	param: { 
		'0x00': {name: "Status" /* CONST */ }, 
		'0x01': {name: "FirmwareChecksum" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Status' in context) payload.writeBYTE(helpers.getValue(context, 'Status', ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS)); else return payload.asBuffer();
		if ('FirmwareChecksum' in context) payload.writeWORD(context['FirmwareChecksum']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Status'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['FirmwareChecksum'] = payload.readWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x7b GROUPING_NAME COMMANDS
 */

// GROUPING_NAME [0x7b] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x7b].command[0x01] = {
	name: "SET",
	help: "Grouping Name Set",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01a': {name: "CharPresentation" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "GroupingName" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('CharPresentation' in context) _properties1 = _properties1 | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('GroupingName' in context) payload.writeSTRING(context['GroupingName'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['GroupingName'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};

// GROUPING_NAME [0x7b] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x7b].command[0x02] = {
	name: "GET",
	help: "Grouping Name Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// GROUPING_NAME [0x7b] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x7b].command[0x03] = {
	name: "REPORT",
	help: "Grouping Name Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01a': {name: "CharPresentation" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "GroupingName" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('CharPresentation' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('CharPresentation' in context) _properties1 = _properties1 | ((context['CharPresentation']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('GroupingName' in context) payload.writeSTRING(context['GroupingName'], { encoding: 'ascii', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['GroupingName'] = payload.readSTRING({ encoding: 'ascii', length: 16 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x7c REMOTE_ASSOCIATION_ACTIVATE COMMANDS
 */

// REMOTE_ASSOCIATION_ACTIVATE [0x7c] REMOTE_ASSOCIATION_ACTIVATE [0x01] COMMAND 
COMMAND_CLASS.enum[0x7c].command[0x01] = {
	name: "REMOTE_ASSOCIATION_ACTIVATE",
	help: "Remote Association Activate",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x7d REMOTE_ASSOCIATION COMMANDS
 */

// REMOTE_ASSOCIATION [0x7d] CONFIGURATION_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x7d].command[0x01] = {
	name: "CONFIGURATION_SET",
	help: "Remote Association Configuration Set",
	param: { 
		'0x00': {name: "LocalGroupingIdentifier" /* CONST */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* CONST */ }, 
		'0x02': {name: "RemoteGroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LocalGroupingIdentifier' in context) payload.writeBYTE(helpers.getValue(context, 'LocalGroupingIdentifier', ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER)); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(helpers.getValue(context, 'zwave.NodeId', ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID)); else return payload.asBuffer();
		if ('RemoteGroupingIdentifier' in context) payload.writeBYTE(context['RemoteGroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LocalGroupingIdentifier'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['RemoteGroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

const ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER = {
	EraseAllLin: 0x00, 
	enum: {
		0x00: "EraseAllLin"
	}
};

const ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID = {
	RemoveaLink: 0x00, 
	enum: {
		0x00: "RemoveaLink"
	}
};

// REMOTE_ASSOCIATION [0x7d] CONFIGURATION_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x7d].command[0x02] = {
	name: "CONFIGURATION_GET",
	help: "Remote Association Configuration Get",
	param: { 
		'0x00': {name: "LocalGroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LocalGroupingIdentifier' in context) payload.writeBYTE(context['LocalGroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LocalGroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// REMOTE_ASSOCIATION [0x7d] CONFIGURATION_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x7d].command[0x03] = {
	name: "CONFIGURATION_REPORT",
	help: "Remote Association Configuration Report",
	param: { 
		'0x00': {name: "LocalGroupingIdentifier" /* CONST */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* CONST */ }, 
		'0x02': {name: "RemoteGroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LocalGroupingIdentifier' in context) payload.writeBYTE(helpers.getValue(context, 'LocalGroupingIdentifier', ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER)); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(helpers.getValue(context, 'zwave.NodeId', ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID)); else return payload.asBuffer();
		if ('RemoteGroupingIdentifier' in context) payload.writeBYTE(context['RemoteGroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LocalGroupingIdentifier'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER.enum); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['RemoteGroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x80 BATTERY COMMANDS
 */

// BATTERY [0x80] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x80].command[0x02] = {
	name: "GET",
	help: "Battery Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// BATTERY [0x80] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x80].command[0x03] = {
	name: "REPORT",
	help: "Battery Report",
	param: { 
		'0x00': {name: "BatteryLevel" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('BatteryLevel' in context) payload.writeBYTE(helpers.getValue(context, 'BatteryLevel', ENUM_BATTERY_BATTERY_LEVEL)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['BatteryLevel'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_BATTERY_BATTERY_LEVEL.enum); else return context;
		return context;
	}
};

const ENUM_BATTERY_BATTERY_LEVEL = {
	BatteryLowWarning: 0xff, 
	enum: {
		0xff: "BatteryLowWarning"
	}
};



/*
 * COMMAND_CLASS 0x81 CLOCK COMMANDS
 */

// CLOCK [0x81] SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x81].command[0x04] = {
	name: "SET",
	help: "Clock Set",
	param: { 
		'0x00a': {name: "Hour" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Weekday" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "Minute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Hour' in context || 'Weekday' in context) {
			let _level = 0x00;
			if ('Hour' in context) _level = _level | ((context['Hour']) & 0x1f);
			if ('Weekday' in context) _level = _level | ((context['Weekday'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('Minute' in context) payload.writeBYTE(context['Minute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Hour'] = (_level & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Weekday'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Minute'] = payload.readBYTE(); else return context;
		return context;
	}
};

// CLOCK [0x81] GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x81].command[0x05] = {
	name: "GET",
	help: "Clock Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// CLOCK [0x81] REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x81].command[0x06] = {
	name: "REPORT",
	help: "Clock Report",
	param: { 
		'0x00a': {name: "Hour" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "Weekday" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "Minute" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Hour' in context || 'Weekday' in context) {
			let _level = 0x00;
			if ('Hour' in context) _level = _level | ((context['Hour']) & 0x1f);
			if ('Weekday' in context) _level = _level | ((context['Weekday'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('Minute' in context) payload.writeBYTE(context['Minute']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Hour'] = (_level & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Weekday'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Minute'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x82 HAIL COMMANDS
 */

// HAIL [0x82] HAIL [0x01] COMMAND 
COMMAND_CLASS.enum[0x82].command[0x01] = {
	name: "HAIL",
	help: "Hail",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x84 WAKE_UP COMMANDS
 */

// WAKE_UP [0x84] INTERVAL_SET [0x04] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x04] = {
	name: "INTERVAL_SET",
	help: "Wake Up Interval Set",
	param: { 
		'0x00': {name: "Seconds" /* BIT_24 */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Seconds' in context) payload.writeBIT_24(context['Seconds']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Seconds'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// WAKE_UP [0x84] INTERVAL_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x05] = {
	name: "INTERVAL_GET",
	help: "Wake Up Interval Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// WAKE_UP [0x84] INTERVAL_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x06] = {
	name: "INTERVAL_REPORT",
	help: "Wake Up Interval Report",
	param: { 
		'0x00': {name: "Seconds" /* BIT_24 */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Seconds' in context) payload.writeBIT_24(context['Seconds']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Seconds'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// WAKE_UP [0x84] NOTIFICATION [0x07] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x07] = {
	name: "NOTIFICATION",
	help: "Wake Up Notification",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// WAKE_UP [0x84] NO_MORE_INFORMATION [0x08] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x08] = {
	name: "NO_MORE_INFORMATION",
	help: "Wake Up No More Information",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// WAKE_UP [0x84] INTERVAL_CAPABILITIES_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x09] = {
	name: "INTERVAL_CAPABILITIES_GET",
	help: "Wake Up Interval Capabilities Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// WAKE_UP [0x84] INTERVAL_CAPABILITIES_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x84].command[0x0a] = {
	name: "INTERVAL_CAPABILITIES_REPORT",
	help: "Wake Up Interval Capabilities Report",
	param: { 
		'0x00': {name: "MinimumWakeUpIntervalSeconds" /* BIT_24 */ }, 
		'0x01': {name: "MaximumWakeUpIntervalSeconds" /* BIT_24 */ }, 
		'0x02': {name: "DefaultWakeUpIntervalSeconds" /* BIT_24 */ }, 
		'0x03': {name: "WakeUpIntervalStepSeconds" /* BIT_24 */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('MinimumWakeUpIntervalSeconds' in context) payload.writeBIT_24(context['MinimumWakeUpIntervalSeconds']); else return payload.asBuffer();
		if ('MaximumWakeUpIntervalSeconds' in context) payload.writeBIT_24(context['MaximumWakeUpIntervalSeconds']); else return payload.asBuffer();
		if ('DefaultWakeUpIntervalSeconds' in context) payload.writeBIT_24(context['DefaultWakeUpIntervalSeconds']); else return payload.asBuffer();
		if ('WakeUpIntervalStepSeconds' in context) payload.writeBIT_24(context['WakeUpIntervalStepSeconds']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['MinimumWakeUpIntervalSeconds'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['MaximumWakeUpIntervalSeconds'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['DefaultWakeUpIntervalSeconds'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['WakeUpIntervalStepSeconds'] = payload.readBIT_24(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x85 ASSOCIATION COMMANDS
 */

// ASSOCIATION [0x85] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x01] = {
	name: "SET",
	help: "Association Set",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFER(context['zwave.NodeId'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// ASSOCIATION [0x85] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x02] = {
	name: "GET",
	help: "Association Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION [0x85] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x03] = {
	name: "REPORT",
	help: "Association Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "MaxNodesSupported" /* BYTE */ }, 
		'0x02': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x03': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('MaxNodesSupported' in context) payload.writeBYTE(context['MaxNodesSupported']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFER(context['zwave.NodeId'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxNodesSupported'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// ASSOCIATION [0x85] REMOVE [0x04] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x04] = {
	name: "REMOVE",
	help: "Association Remove",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFER(context['zwave.NodeId'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// ASSOCIATION [0x85] GROUPINGS_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x05] = {
	name: "GROUPINGS_GET",
	help: "Association Groupings Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ASSOCIATION [0x85] GROUPINGS_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x06] = {
	name: "GROUPINGS_REPORT",
	help: "Association Groupings Report",
	param: { 
		'0x00': {name: "SupportedGroupings" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedGroupings' in context) payload.writeBYTE(context['SupportedGroupings']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedGroupings'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION [0x85] SPECIFIC_GROUP_GET [0x0b] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x0b] = {
	name: "SPECIFIC_GROUP_GET",
	help: "Association Specific Group Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ASSOCIATION [0x85] SPECIFIC_GROUP_REPORT [0x0c] COMMAND 
COMMAND_CLASS.enum[0x85].command[0x0c] = {
	name: "SPECIFIC_GROUP_REPORT",
	help: "Association Specific Group Report",
	param: { 
		'0x00': {name: "Group" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Group' in context) payload.writeBYTE(context['Group']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Group'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x86 VERSION COMMANDS
 */

// VERSION [0x86] GET [0x11] COMMAND 
COMMAND_CLASS.enum[0x86].command[0x11] = {
	name: "GET",
	help: "Version Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// VERSION [0x86] REPORT [0x12] COMMAND 
COMMAND_CLASS.enum[0x86].command[0x12] = {
	name: "REPORT",
	help: "Version Report",
	param: { 
		'0x00': {name: "LibraryType" /* BYTE */ }, 
		'0x01': {name: "ProtocolVersion" /* BYTE */ }, 
		'0x02': {name: "ProtocolSubVersion" /* BYTE */ }, 
		'0x03': {name: "Firmware0Version" /* BYTE */ }, 
		'0x04': {name: "Firmware0SubVersion" /* BYTE */ }, 
		'0x05': {name: "HardwareVersion" /* BYTE */ }, 
		'0x06': {name: "NumberOfFirmwareTargets" /* BYTE */ }, 
		'0x07': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x07-0x00': {name: "FirmwareVersion" /* BYTE */ },
				'0x07-0x01': {name: "FirmwareSubVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LibraryType' in context) payload.writeBYTE(context['LibraryType']); else return payload.asBuffer();
		if ('ProtocolVersion' in context) payload.writeBYTE(context['ProtocolVersion']); else return payload.asBuffer();
		if ('ProtocolSubVersion' in context) payload.writeBYTE(context['ProtocolSubVersion']); else return payload.asBuffer();
		if ('Firmware0Version' in context) payload.writeBYTE(context['Firmware0Version']); else return payload.asBuffer();
		if ('Firmware0SubVersion' in context) payload.writeBYTE(context['Firmware0SubVersion']); else return payload.asBuffer();
		if ('HardwareVersion' in context) payload.writeBYTE(context['HardwareVersion']); else return payload.asBuffer();
		if ('NumberOfFirmwareTargets' in context) payload.writeBYTE(context['NumberOfFirmwareTargets']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(6))) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('FirmwareVersion' in context) payload.writeBYTE(context['FirmwareVersion']); else return payload.asBuffer();
				if ('FirmwareSubVersion' in context) payload.writeBYTE(context['FirmwareSubVersion']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LibraryType'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ProtocolVersion'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ProtocolSubVersion'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Firmware0Version'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Firmware0SubVersion'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HardwareVersion'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfFirmwareTargets'] = payload.readBYTE(); else return context;
		let $variablegroup = [],  $variablegroup_length = payload.at(6); 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['FirmwareVersion'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['FirmwareSubVersion'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// VERSION [0x86] GET [0x13] COMMAND 
COMMAND_CLASS.enum[0x86].command[0x13] = {
	name: "GET",
	help: "Version Command Class Get",
	param: { 
		'0x00': {name: "RequestedCommandClass" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RequestedCommandClass' in context) payload.writeBYTE(context['RequestedCommandClass']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RequestedCommandClass'] = payload.readBYTE(); else return context;
		return context;
	}
};

// VERSION [0x86] REPORT [0x14] COMMAND 
COMMAND_CLASS.enum[0x86].command[0x14] = {
	name: "REPORT",
	help: "Version Command Class Report",
	param: { 
		'0x00': {name: "RequestedCommandClass" /* BYTE */ }, 
		'0x01': {name: "CommandClassVersion" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RequestedCommandClass' in context) payload.writeBYTE(context['RequestedCommandClass']); else return payload.asBuffer();
		if ('CommandClassVersion' in context) payload.writeBYTE(context['CommandClassVersion']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RequestedCommandClass'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClassVersion'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x87 INDICATOR COMMANDS
 */

// INDICATOR [0x87] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x87].command[0x01] = {
	name: "SET",
	help: "Indicator Set",
	param: { 
		'0x00': {name: "Indicator0Value" /* CONST */ }, 
		'0x01a': {name: "IndicatorObjectCount" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x02-0x00': {name: "IndicatorId" /* CONST */ },
				'0x02-0x01': {name: "PropertyId" /* CONST */ },
				'0x02-0x02': {name: "Value" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Indicator0Value' in context) payload.writeBYTE(helpers.getValue(context, 'Indicator0Value', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('IndicatorObjectCount' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('IndicatorObjectCount' in context) _properties1 = _properties1 | ((context['IndicatorObjectCount']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(1) & 0x1f)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('IndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'IndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
				if ('PropertyId' in context) payload.writeBYTE(helpers.getValue(context, 'PropertyId', ENUM_INDICATOR_PROPERTY_ID)); else return payload.asBuffer();
				if ('Value' in context) payload.writeBYTE(context['Value']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Indicator0Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IndicatorObjectCount'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(1) & 0x1f; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['IndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
			if (!payload.insufficientBytes(1)) context['PropertyId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_PROPERTY_ID.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Value'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

const ENUM_INDICATOR_INDICATOR_ID = {
	NA: 0x00, 
	Armed: 0x01, 
	NotArmed: 0x02, 
	Ready: 0x03, 
	Fault: 0x04, 
	Busy: 0x05, 
	EnterId: 0x06, 
	EnterPin: 0x07, 
	Ok: 0x08, 
	NotOk: 0x09, 
	Zone1Armed: 0x20, 
	Zone2Armed: 0x21, 
	Zone3Armed: 0x22, 
	Zone4Armed: 0x23, 
	Zone5Armed: 0x24, 
	Zone6Armed: 0x25, 
	LcdBacklight: 0x30, 
	ButtonBacklightLetters: 0x40, 
	ButtonBacklightDigits: 0x41, 
	ButtonBacklightCommand: 0x42, 
	Button1Indication: 0x43, 
	Button2Indication: 0x44, 
	Button3Indication: 0x45, 
	Button4Indication: 0x46, 
	Button5Indication: 0x47, 
	Button6Indication: 0x48, 
	Button7Indication: 0x49, 
	Button8Indication: 0x4a, 
	Button9Indication: 0x4b, 
	Button10Indication: 0x4c, 
	Button11Indication: 0x4d, 
	Button12Indication: 0x4e, 
	Buzzer: 0xf0, 
	enum: {
		0x00: "NA", 
		0x01: "Armed", 
		0x02: "NotArmed", 
		0x03: "Ready", 
		0x04: "Fault", 
		0x05: "Busy", 
		0x06: "EnterId", 
		0x07: "EnterPin", 
		0x08: "Ok", 
		0x09: "NotOk", 
		0x20: "Zone1Armed", 
		0x21: "Zone2Armed", 
		0x22: "Zone3Armed", 
		0x23: "Zone4Armed", 
		0x24: "Zone5Armed", 
		0x25: "Zone6Armed", 
		0x30: "LcdBacklight", 
		0x40: "ButtonBacklightLetters", 
		0x41: "ButtonBacklightDigits", 
		0x42: "ButtonBacklightCommand", 
		0x43: "Button1Indication", 
		0x44: "Button2Indication", 
		0x45: "Button3Indication", 
		0x46: "Button4Indication", 
		0x47: "Button5Indication", 
		0x48: "Button6Indication", 
		0x49: "Button7Indication", 
		0x4a: "Button8Indication", 
		0x4b: "Button9Indication", 
		0x4c: "Button10Indication", 
		0x4d: "Button11Indication", 
		0x4e: "Button12Indication", 
		0xf0: "Buzzer"
	}
};

const ENUM_INDICATOR_PROPERTY_ID = {
	Multilevel: 0x01, 
	Binary: 0x02, 
	OnOffPeriod: 0x03, 
	OnOffCycles: 0x04, 
	LowPower: 0x10, 
	enum: {
		0x01: "Multilevel", 
		0x02: "Binary", 
		0x03: "OnOffPeriod", 
		0x04: "OnOffCycles", 
		0x10: "LowPower"
	}
};

// INDICATOR [0x87] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x87].command[0x02] = {
	name: "GET",
	help: "Indicator Get",
	param: { 
		'0x00': {name: "IndicatorId" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'IndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['IndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
		return context;
	}
};

// INDICATOR [0x87] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x87].command[0x03] = {
	name: "REPORT",
	help: "Indicator Report",
	param: { 
		'0x00': {name: "Indicator0Value" /* CONST */ }, 
		'0x01a': {name: "IndicatorObjectCount" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x02-0x00': {name: "IndicatorId" /* CONST */ },
				'0x02-0x01': {name: "PropertyId" /* CONST */ },
				'0x02-0x02': {name: "Value" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Indicator0Value' in context) payload.writeBYTE(helpers.getValue(context, 'Indicator0Value', ENUM_SWITCH_BINARY_TARGET_VALUE)); else return payload.asBuffer();
		if ('IndicatorObjectCount' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('IndicatorObjectCount' in context) _properties1 = _properties1 | ((context['IndicatorObjectCount']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			if (context['VariableGroup'].length !== (payload.at(1) & 0x1f)) throw new Error('VariableGroup array size does not match length field');
			context['VariableGroup'].forEach(function(context) {
					if ('IndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'IndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
				if ('PropertyId' in context) payload.writeBYTE(helpers.getValue(context, 'PropertyId', ENUM_INDICATOR_PROPERTY_ID)); else return payload.asBuffer();
				if ('Value' in context) payload.writeBYTE(context['Value']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Indicator0Value'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SWITCH_BINARY_TARGET_VALUE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IndicatorObjectCount'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		let $variablegroup = [],  $variablegroup_length = payload.at(1) & 0x1f; 
		for (var $variablegroup_index = 0;  $variablegroup_index < $variablegroup_length; $variablegroup_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['IndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
			if (!payload.insufficientBytes(1)) context['PropertyId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_PROPERTY_ID.enum); else return context;
			if (!payload.insufficientBytes(1)) context['Value'] = payload.readBYTE(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// INDICATOR [0x87] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x87].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Indicator Supported Get",
	param: { 
		'0x00': {name: "IndicatorId" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'IndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['IndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
		return context;
	}
};

// INDICATOR [0x87] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x87].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Indicator Supported Report",
	param: { 
		'0x00': {name: "IndicatorId" /* CONST */ }, 
		'0x01': {name: "NextIndicatorId" /* CONST */ }, 
		'0x02a': {name: "PropertySupportedBitMaskLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x03-0': {name: "Multilevel" /* PropertySupportedBitMask BITMASK */ }, 
		'0x03-1': {name: "Binary" /* PropertySupportedBitMask BITMASK */ }, 
		'0x03-2': {name: "OnOffPeriod" /* PropertySupportedBitMask BITMASK */ }, 
		'0x03-3': {name: "OnOffCycles" /* PropertySupportedBitMask BITMASK */ }, 
		'0x03-4': {name: "LowPower" /* PropertySupportedBitMask BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'IndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
		if ('NextIndicatorId' in context) payload.writeBYTE(helpers.getValue(context, 'NextIndicatorId', ENUM_INDICATOR_INDICATOR_ID)); else return payload.asBuffer();
		if ('PropertySupportedBitMaskLength' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('PropertySupportedBitMaskLength' in context) _properties1 = _properties1 | ((context['PropertySupportedBitMaskLength']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_INDICATOR_PROPERTY_ID), {length: 5});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['IndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NextIndicatorId'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_INDICATOR_INDICATOR_ID.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['PropertySupportedBitMaskLength'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		helpers.setNameFlags(context, payload.readBITMASK({length: 5}), ENUM_INDICATOR_PROPERTY_ID.enum);
		return context;
	}
};



/*
 * COMMAND_CLASS 0x88 PROPRIETARY COMMANDS
 */

// PROPRIETARY [0x88] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x88].command[0x01] = {
	name: "SET",
	help: "Proprietary Set",
	param: { 
		'0x00': {name: "Data" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Data' in context) payload.writeSTRING(context['Data'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Data'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// PROPRIETARY [0x88] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x88].command[0x02] = {
	name: "GET",
	help: "Proprietary Get",
	param: { 
		'0x00': {name: "Data" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Data' in context) payload.writeSTRING(context['Data'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Data'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// PROPRIETARY [0x88] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x88].command[0x03] = {
	name: "REPORT",
	help: "Proprietary Report",
	param: { 
		'0x00': {name: "Data" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Data' in context) payload.writeSTRING(context['Data'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Data'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x89 LANGUAGE COMMANDS
 */

// LANGUAGE [0x89] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x89].command[0x01] = {
	name: "SET",
	help: "Language Set",
	param: { 
		'0x00': {name: "Language" /* BIT_24 */ }, 
		'0x01': {name: "Country" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Language' in context) payload.writeBIT_24(context['Language']); else return payload.asBuffer();
		if ('Country' in context) payload.writeWORD(context['Country']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Language'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Country'] = payload.readWORD(); else return context;
		return context;
	}
};

// LANGUAGE [0x89] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x89].command[0x02] = {
	name: "GET",
	help: "Language Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// LANGUAGE [0x89] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x89].command[0x03] = {
	name: "REPORT",
	help: "Language Report",
	param: { 
		'0x00': {name: "Language" /* BIT_24 */ }, 
		'0x01': {name: "Country" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Language' in context) payload.writeBIT_24(context['Language']); else return payload.asBuffer();
		if ('Country' in context) payload.writeWORD(context['Country']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Language'] = payload.readBIT_24(); else return context;
		if (!payload.insufficientBytes(1)) context['Country'] = payload.readWORD(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x8a TIME COMMANDS
 */

// TIME [0x8a] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x01] = {
	name: "GET",
	help: "Time Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// TIME [0x8a] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x02] = {
	name: "REPORT",
	help: "Time Report",
	param: { 
		'0x00a': {name: "RtcFailure" /* HourLocalTime STRUCT_BYTE */ }, 
		'0x00b': {name: "HourLocalTime" /* HourLocalTime STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* HourLocalTime STRUCT_BYTE */ }, 
		'0x01': {name: "MinuteLocalTime" /* BYTE */ }, 
		'0x02': {name: "SecondLocalTime" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RtcFailure' in context || 'HourLocalTime' in context || 'Reserved' in context) {
			let _hourlocaltime = 0x00;
			if (context['RtcFailure']) _hourlocaltime = _hourlocaltime | 0x80;
			if ('HourLocalTime' in context) _hourlocaltime = _hourlocaltime | ((context['HourLocalTime']) & 0x1f);
			if ('Reserved' in context) _hourlocaltime = _hourlocaltime | ((context['Reserved'] << 5) & 0x60);
			payload.writeBYTE(_hourlocaltime);
		} else return payload.asBuffer();;
		if ('MinuteLocalTime' in context) payload.writeBYTE(context['MinuteLocalTime']); else return payload.asBuffer();
		if ('SecondLocalTime' in context) payload.writeBYTE(context['SecondLocalTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _hourlocaltime = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['RtcFailure'] = ((_hourlocaltime & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HourLocalTime'] = (_hourlocaltime & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_hourlocaltime & 0x60) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteLocalTime'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondLocalTime'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TIME [0x8a] DATE_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x03] = {
	name: "DATE_GET",
	help: "Date Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// TIME [0x8a] DATE_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x04] = {
	name: "DATE_REPORT",
	help: "Date Report",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TIME [0x8a] OFFSET_SET [0x05] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x05] = {
	name: "OFFSET_SET",
	help: "Time Offset Set",
	param: { 
		'0x00a': {name: "SignTzo" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "HourTzo" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "MinuteTzo" /* BYTE */ }, 
		'0x02a': {name: "SignOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x02b': {name: "MinuteOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x03': {name: "MonthStartDst" /* BYTE */ }, 
		'0x04': {name: "DayStartDst" /* BYTE */ }, 
		'0x05': {name: "HourStartDst" /* BYTE */ }, 
		'0x06': {name: "MonthEndDst" /* BYTE */ }, 
		'0x07': {name: "DayEndDst" /* BYTE */ }, 
		'0x08': {name: "HourEndDst" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SignTzo' in context || 'HourTzo' in context) {
			let _level = 0x00;
			if (context['SignTzo']) _level = _level | 0x80;
			if ('HourTzo' in context) _level = _level | ((context['HourTzo']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('MinuteTzo' in context) payload.writeBYTE(context['MinuteTzo']); else return payload.asBuffer();
		if ('SignOffsetDst' in context || 'MinuteOffsetDst' in context) {
			let _level2 = 0x00;
			if (context['SignOffsetDst']) _level2 = _level2 | 0x80;
			if ('MinuteOffsetDst' in context) _level2 = _level2 | ((context['MinuteOffsetDst']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		if ('MonthStartDst' in context) payload.writeBYTE(context['MonthStartDst']); else return payload.asBuffer();
		if ('DayStartDst' in context) payload.writeBYTE(context['DayStartDst']); else return payload.asBuffer();
		if ('HourStartDst' in context) payload.writeBYTE(context['HourStartDst']); else return payload.asBuffer();
		if ('MonthEndDst' in context) payload.writeBYTE(context['MonthEndDst']); else return payload.asBuffer();
		if ('DayEndDst' in context) payload.writeBYTE(context['DayEndDst']); else return payload.asBuffer();
		if ('HourEndDst' in context) payload.writeBYTE(context['HourEndDst']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignTzo'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HourTzo'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteTzo'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignOffsetDst'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MinuteOffsetDst'] = (_level2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MonthStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MonthEndDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayEndDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourEndDst'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TIME [0x8a] OFFSET_GET [0x06] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x06] = {
	name: "OFFSET_GET",
	help: "Time Offset Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// TIME [0x8a] OFFSET_REPORT [0x07] COMMAND 
COMMAND_CLASS.enum[0x8a].command[0x07] = {
	name: "OFFSET_REPORT",
	help: "Time Offset Report",
	param: { 
		'0x00a': {name: "SignTzo" /* Level STRUCT_BYTE */ }, 
		'0x00b': {name: "HourTzo" /* Level STRUCT_BYTE */ }, 
		'0x01': {name: "MinuteTzo" /* BYTE */ }, 
		'0x02a': {name: "SignOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x02b': {name: "MinuteOffsetDst" /* Level2 STRUCT_BYTE */ }, 
		'0x03': {name: "MonthStartDst" /* BYTE */ }, 
		'0x04': {name: "DayStartDst" /* BYTE */ }, 
		'0x05': {name: "HourStartDst" /* BYTE */ }, 
		'0x06': {name: "MonthEndDst" /* BYTE */ }, 
		'0x07': {name: "DayEndDst" /* BYTE */ }, 
		'0x08': {name: "HourEndDst" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SignTzo' in context || 'HourTzo' in context) {
			let _level = 0x00;
			if (context['SignTzo']) _level = _level | 0x80;
			if ('HourTzo' in context) _level = _level | ((context['HourTzo']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('MinuteTzo' in context) payload.writeBYTE(context['MinuteTzo']); else return payload.asBuffer();
		if ('SignOffsetDst' in context || 'MinuteOffsetDst' in context) {
			let _level2 = 0x00;
			if (context['SignOffsetDst']) _level2 = _level2 | 0x80;
			if ('MinuteOffsetDst' in context) _level2 = _level2 | ((context['MinuteOffsetDst']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		if ('MonthStartDst' in context) payload.writeBYTE(context['MonthStartDst']); else return payload.asBuffer();
		if ('DayStartDst' in context) payload.writeBYTE(context['DayStartDst']); else return payload.asBuffer();
		if ('HourStartDst' in context) payload.writeBYTE(context['HourStartDst']); else return payload.asBuffer();
		if ('MonthEndDst' in context) payload.writeBYTE(context['MonthEndDst']); else return payload.asBuffer();
		if ('DayEndDst' in context) payload.writeBYTE(context['DayEndDst']); else return payload.asBuffer();
		if ('HourEndDst' in context) payload.writeBYTE(context['HourEndDst']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignTzo'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['HourTzo'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MinuteTzo'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SignOffsetDst'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MinuteOffsetDst'] = (_level2 & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['MonthStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourStartDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MonthEndDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['DayEndDst'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourEndDst'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x8b TIME_PARAMETERS COMMANDS
 */

// TIME_PARAMETERS [0x8b] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x8b].command[0x01] = {
	name: "SET",
	help: "Time Parameters Set",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourUtc" /* BYTE */ }, 
		'0x04': {name: "MinuteUtc" /* BYTE */ }, 
		'0x05': {name: "SecondUtc" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourUtc' in context) payload.writeBYTE(context['HourUtc']); else return payload.asBuffer();
		if ('MinuteUtc' in context) payload.writeBYTE(context['MinuteUtc']); else return payload.asBuffer();
		if ('SecondUtc' in context) payload.writeBYTE(context['SecondUtc']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourUtc'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteUtc'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondUtc'] = payload.readBYTE(); else return context;
		return context;
	}
};

// TIME_PARAMETERS [0x8b] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x8b].command[0x02] = {
	name: "GET",
	help: "Time Parameters Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// TIME_PARAMETERS [0x8b] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x8b].command[0x03] = {
	name: "REPORT",
	help: "Time Parameters Report",
	param: { 
		'0x00': {name: "Year" /* WORD */ }, 
		'0x01': {name: "Month" /* BYTE */ }, 
		'0x02': {name: "Day" /* BYTE */ }, 
		'0x03': {name: "HourUtc" /* BYTE */ }, 
		'0x04': {name: "MinuteUtc" /* BYTE */ }, 
		'0x05': {name: "SecondUtc" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Year' in context) payload.writeWORD(context['Year']); else return payload.asBuffer();
		if ('Month' in context) payload.writeBYTE(context['Month']); else return payload.asBuffer();
		if ('Day' in context) payload.writeBYTE(context['Day']); else return payload.asBuffer();
		if ('HourUtc' in context) payload.writeBYTE(context['HourUtc']); else return payload.asBuffer();
		if ('MinuteUtc' in context) payload.writeBYTE(context['MinuteUtc']); else return payload.asBuffer();
		if ('SecondUtc' in context) payload.writeBYTE(context['SecondUtc']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Year'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Month'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['Day'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['HourUtc'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MinuteUtc'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SecondUtc'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x8c GEOGRAPHIC_LOCATION COMMANDS
 */

// GEOGRAPHIC_LOCATION [0x8c] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x8c].command[0x01] = {
	name: "SET",
	help: "Geographic Location Set",
	param: { 
		'0x00': {name: "LongitudeDegrees" /* BYTE */ }, 
		'0x01a': {name: "LongSign" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "LongitudeMinutes" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "LatitudeDegrees" /* BYTE */ }, 
		'0x03a': {name: "LatSign" /* Level2 STRUCT_BYTE */ }, 
		'0x03b': {name: "LatitudeMinutes" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LongitudeDegrees' in context) payload.writeBYTE(context['LongitudeDegrees']); else return payload.asBuffer();
		if ('LongSign' in context || 'LongitudeMinutes' in context) {
			let _level = 0x00;
			if (context['LongSign']) _level = _level | 0x80;
			if ('LongitudeMinutes' in context) _level = _level | ((context['LongitudeMinutes']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('LatitudeDegrees' in context) payload.writeBYTE(context['LatitudeDegrees']); else return payload.asBuffer();
		if ('LatSign' in context || 'LatitudeMinutes' in context) {
			let _level2 = 0x00;
			if (context['LatSign']) _level2 = _level2 | 0x80;
			if ('LatitudeMinutes' in context) _level2 = _level2 | ((context['LatitudeMinutes']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LongitudeDegrees'] = payload.readBYTE(); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LongSign'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['LongitudeMinutes'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['LatitudeDegrees'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LatSign'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['LatitudeMinutes'] = (_level2 & 0x7f); else return context;
		}
		return context;
	}
};

// GEOGRAPHIC_LOCATION [0x8c] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x8c].command[0x02] = {
	name: "GET",
	help: "Geographic Location Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// GEOGRAPHIC_LOCATION [0x8c] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x8c].command[0x03] = {
	name: "REPORT",
	help: "Geographic Location Report",
	param: { 
		'0x00': {name: "LongitudeDegrees" /* BYTE */ }, 
		'0x01a': {name: "LongSign" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "LongitudeMinutes" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "LatitudeDegrees" /* BYTE */ }, 
		'0x03a': {name: "LatSign" /* Level2 STRUCT_BYTE */ }, 
		'0x03b': {name: "LatitudeMinutes" /* Level2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('LongitudeDegrees' in context) payload.writeBYTE(context['LongitudeDegrees']); else return payload.asBuffer();
		if ('LongSign' in context || 'LongitudeMinutes' in context) {
			let _level = 0x00;
			if (context['LongSign']) _level = _level | 0x80;
			if ('LongitudeMinutes' in context) _level = _level | ((context['LongitudeMinutes']) & 0x7f);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('LatitudeDegrees' in context) payload.writeBYTE(context['LatitudeDegrees']); else return payload.asBuffer();
		if ('LatSign' in context || 'LatitudeMinutes' in context) {
			let _level2 = 0x00;
			if (context['LatSign']) _level2 = _level2 | 0x80;
			if ('LatitudeMinutes' in context) _level2 = _level2 | ((context['LatitudeMinutes']) & 0x7f);
			payload.writeBYTE(_level2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['LongitudeDegrees'] = payload.readBYTE(); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LongSign'] = ((_level & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['LongitudeMinutes'] = (_level & 0x7f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['LatitudeDegrees'] = payload.readBYTE(); else return context;
		{
			let _level2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['LatSign'] = ((_level2 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['LatitudeMinutes'] = (_level2 & 0x7f); else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x8e MULTI_CHANNEL_ASSOCIATION COMMANDS
 */

// MULTI_CHANNEL_ASSOCIATION [0x8e] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x01] = {
	name: "SET",
	help: "Multi Channel Association Set",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }, 
		'0x02': null /* MARKER Marker handled by VARIANT */, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ },
				'0x03-0x01a': {name: "BitAddress" /* Properties1 STRUCT_BYTE */ },
				'0x03-0x01b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFERtoMARKER(context['zwave.NodeId'], { marker: [ 0x00 ] }); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
				if ('BitAddress' in context || 'EndPoint' in context) {
					let _properties1 = 0x00;
					if (context['BitAddress']) _properties1 = _properties1 | 0x80;
					if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFERtoMARKER({ marker: [ 0x00 ] }); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['BitAddress'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
			}
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// MULTI_CHANNEL_ASSOCIATION [0x8e] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x02] = {
	name: "GET",
	help: "Multi Channel Association Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		return context;
	}
};

// MULTI_CHANNEL_ASSOCIATION [0x8e] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x03] = {
	name: "REPORT",
	help: "Multi Channel Association Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "MaxNodesSupported" /* BYTE */ }, 
		'0x02': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x03': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }, 
		'0x04': null /* MARKER Marker handled by VARIANT */, 
		'0x05': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x05-0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ },
				'0x05-0x01a': {name: "BitAddress" /* Properties1 STRUCT_BYTE */ },
				'0x05-0x01b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('MaxNodesSupported' in context) payload.writeBYTE(context['MaxNodesSupported']); else return payload.asBuffer();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFERtoMARKER(context['zwave.NodeId'], { marker: [ 0x00 ] }); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
				if ('BitAddress' in context || 'EndPoint' in context) {
					let _properties1 = 0x00;
					if (context['BitAddress']) _properties1 = _properties1 | 0x80;
					if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxNodesSupported'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFERtoMARKER({ marker: [ 0x00 ] }); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['BitAddress'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
			}
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// MULTI_CHANNEL_ASSOCIATION [0x8e] REMOVE [0x04] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x04] = {
	name: "REMOVE",
	help: "Multi Channel Association Remove",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* VARIANT */ }, 
		'0x02': null /* MARKER Marker handled by VARIANT */, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ },
				'0x03-0x01a': {name: "BitAddress" /* Properties1 STRUCT_BYTE */ },
				'0x03-0x01b': {name: "EndPoint" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBUFFERtoMARKER(context['zwave.NodeId'], { marker: [ 0x00 ] }); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
				if ('BitAddress' in context || 'EndPoint' in context) {
					let _properties1 = 0x00;
					if (context['BitAddress']) _properties1 = _properties1 | 0x80;
					if ('EndPoint' in context) _properties1 = _properties1 | ((context['EndPoint']) & 0x7f);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBUFFERtoMARKER({ marker: [ 0x00 ] }); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['BitAddress'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['EndPoint'] = (_properties1 & 0x7f); else return context;
			}
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// MULTI_CHANNEL_ASSOCIATION [0x8e] GROUPINGS_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x05] = {
	name: "GROUPINGS_GET",
	help: "Multi Channel Association Groupings Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// MULTI_CHANNEL_ASSOCIATION [0x8e] GROUPINGS_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x8e].command[0x06] = {
	name: "GROUPINGS_REPORT",
	help: "Multi Channel Association Groupings Report",
	param: { 
		'0x00': {name: "SupportedGroupings" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedGroupings' in context) payload.writeBYTE(context['SupportedGroupings']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedGroupings'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x8f MULTI_CMD COMMANDS
 */

// MULTI_CMD [0x8f] ENCAP [0x01] COMMAND 
COMMAND_CLASS.enum[0x8f].command[0x01] = {
	name: "ENCAP",
	help: "Multi Cmd Encap",
	param: { 
		'0x00': {name: "NumberOfCommands" /* BYTE */ }, 
		'0x01': {name: "EncapsulatedCommand" /* VARIANT_GROUP */ }, 
				'0x01-0x00': {name: "CommandLength" /* BYTE */ },
				'0x01-0x01': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* BYTE */ },
				'0x01-0x02': {name: "zwave.Command", alias: "zwaveCommand", encaptype: "CMD_REF" /* BYTE */ },
				'0x01-0x03': {name: "zwave.Payload", alias: "zwavePayload", encaptype: "CMD_DATA" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfCommands' in context) payload.writeBYTE(context['NumberOfCommands']); else return payload.asBuffer();
		if ('EncapsulatedCommand' in context) {
			if (context['EncapsulatedCommand'].length !== (payload.at(0))) throw new Error('EncapsulatedCommand array size does not match length field');
			context['EncapsulatedCommand'].forEach(function(context) {
					if ('CommandLength' in context) payload.writeBYTE(context['CommandLength']); else return payload.asBuffer();
				if ('zwave.CommandClass' in context) payload.writeBYTE(context['zwave.CommandClass']); else return payload.asBuffer();
				if ('zwave.Command' in context) payload.writeBYTE(context['zwave.Command']); else return payload.asBuffer();
				if ('zwave.Payload' in context) payload.writeBUFFER(context['zwave.Payload'], { length: (payload.at(1) & 0xff) -2 }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfCommands'] = payload.readBYTE(); else return context;
		let $encapsulatedcommand = [],  $encapsulatedcommand_length = payload.at(0); 
		for (var $encapsulatedcommand_index = 0;  $encapsulatedcommand_index < $encapsulatedcommand_length; $encapsulatedcommand_index++ ) {
			if (payload.insufficientBytes(1)) break;
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['CommandLength'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['zwave.Command'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['zwave.Payload'] = payload.readBUFFER({ length: payload.at(1) & 0xff }); else return context;
			$encapsulatedcommand.push(context);
		};
		if (!payload.insufficientBytes(1)) context['EncapsulatedCommand'] = $encapsulatedcommand; else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x90 ENERGY_PRODUCTION COMMANDS
 */

// ENERGY_PRODUCTION [0x90] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x90].command[0x02] = {
	name: "GET",
	help: "Energy Production Get",
	param: { 
		'0x00': {name: "ParameterNumber" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ParameterNumber' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterNumber', ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER.enum); else return context;
		return context;
	}
};

const ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER = {
	InstantEnergyProduction: 0x00, 
	TotalEnergyProduction: 0x01, 
	EnergyProductionToday: 0x02, 
	TotalProductionTime: 0x03, 
	enum: {
		0x00: "InstantEnergyProduction", 
		0x01: "TotalEnergyProduction", 
		0x02: "EnergyProductionToday", 
		0x03: "TotalProductionTime"
	}
};

// ENERGY_PRODUCTION [0x90] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x90].command[0x03] = {
	name: "REPORT",
	help: "Energy Production Report",
	param: { 
		'0x00': {name: "ParameterNumber" /* CONST */ }, 
		'0x01a': {name: "Size" /* Level STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Level STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Level STRUCT_BYTE */ }, 
		'0x02': {name: "Value" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('Value' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'Value', 'Precision', 'Size');
		if ('ParameterNumber' in context) payload.writeBYTE(helpers.getValue(context, 'ParameterNumber', ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER)); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _level = 0x00;
			if ('Size' in context) _level = _level | ((context['Size']) & 0x07);
			if ('Scale' in context) _level = _level | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _level = _level | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_level);
		} else return payload.asBuffer();;
		if ('Value' in context) payload.writeFLOATING(context['Value'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ParameterNumber'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER.enum); else return context;
		{
			let _level = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_level & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_level & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_level & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['Value'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x92 SCREEN_MD COMMANDS
 */

// SCREEN_MD [0x92] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x92].command[0x01] = {
	name: "GET",
	help: "Screen Md Get",
	param: { 
		'0x00': {name: "NumberOfReports" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfReports' in context) payload.writeBYTE(context['NumberOfReports']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfReports'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SCREEN_MD [0x92] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x92].command[0x03] = {
	name: "REPORT",
	help: "Screen Md Report",
	param: { 
		'0x00a': {name: "Reserved1" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "MoreData" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "CharPresentation" /* Properties1 STRUCT_BYTE */ }, 
		'0x00d': {name: "ScreenSettings" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x01-0x00a': {name: "Clear" /* Properties1 STRUCT_BYTE */ },
				'0x01-0x00b': {name: "LineNumber" /* Properties1 STRUCT_BYTE */ },
				'0x01-0x00c': {name: "LineSettings" /* Properties1 STRUCT_BYTE */ },
				'0x01-0x01': {name: "CharacterPosition" /* BYTE */ },
				'0x01-0x02': {name: "NumberOfCharacters" /* BYTE */ },
				'0x01-0x03': {name: "Character" /* VARIANT */ }, 
		'0x02a': {name: "ScreenTimeout" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Reserved2" /* Properties2 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Reserved1' in context || 'MoreData' in context || 'CharPresentation' in context || 'ScreenSettings' in context) {
			let _properties1 = 0x00;
			if (context['Reserved1']) _properties1 = _properties1 | 0x40;
			if (context['MoreData']) _properties1 = _properties1 | 0x80;
			if ('CharPresentation' in context) _properties1 = _properties1 | ((context['CharPresentation']) & 0x07);
			if ('ScreenSettings' in context) _properties1 = _properties1 | ((context['ScreenSettings'] << 3) & 0x38);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('Clear' in context || 'LineNumber' in context || 'LineSettings' in context) {
					let _properties1 = 0x00;
					if (context['Clear']) _properties1 = _properties1 | 0x10;
					if ('LineNumber' in context) _properties1 = _properties1 | ((context['LineNumber']) & 0x0f);
					if ('LineSettings' in context) _properties1 = _properties1 | ((context['LineSettings'] << 5) & 0xe0);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('CharacterPosition' in context) payload.writeBYTE(context['CharacterPosition']); else return payload.asBuffer();
				if ('NumberOfCharacters' in context) payload.writeBYTE(context['NumberOfCharacters']); else return payload.asBuffer();
				if ('Character' in context) payload.writeSTRING(context['Character'], { encoding: 'hex', length: (payload.at(3) & 0xff) }); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		if ('ScreenTimeout' in context || 'Reserved2' in context) {
			let _properties2 = 0x00;
			if (context['ScreenTimeout']) _properties2 = _properties2 | 0x01;
			if ('Reserved2' in context) _properties2 = _properties2 | ((context['Reserved2'] << 1) & 0xfe);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Reserved1'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MoreData'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['CharPresentation'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['ScreenSettings'] = (_properties1 & 0x38) >> 3; else return context;
		}
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['Clear'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['LineNumber'] = (_properties1 & 0x0f); else return context;
				if (!payload.insufficientBytes(1)) context['LineSettings'] = (_properties1 & 0xe0) >> 5; else return context;
			}
			if (!payload.insufficientBytes(1)) context['CharacterPosition'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfCharacters'] = payload.readBYTE(); else return context;
			if (!payload.insufficientBytes(1)) context['Character'] = payload.readSTRING({ encoding: 'hex', length: payload.at(3) & 0xff }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ScreenTimeout'] = ((_properties2 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved2'] = (_properties2 & 0xfe) >> 1; else return context;
		}
		return context;
	}
};



/*
 * COMMAND_CLASS 0x93 SCREEN_ATTRIBUTES COMMANDS
 */

// SCREEN_ATTRIBUTES [0x93] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x93].command[0x01] = {
	name: "GET",
	help: "Screen Attributes Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SCREEN_ATTRIBUTES [0x93] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x93].command[0x03] = {
	name: "REPORT",
	help: "Screen Attributes Report",
	param: { 
		'0x00a': {name: "EscapeSequence" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "NumberOfLines" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "NumberOfCharactersPerLine" /* BYTE */ }, 
		'0x02': {name: "SizeOfLineBuffer" /* BYTE */ }, 
		'0x03': {name: "NumericalPresentationOfaCharacter" /* BYTE */ }, 
		'0x04': {name: "ScreenTimeout" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('EscapeSequence' in context || 'NumberOfLines' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['EscapeSequence']) _properties1 = _properties1 | 0x20;
			if ('NumberOfLines' in context) _properties1 = _properties1 | ((context['NumberOfLines']) & 0x1f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('NumberOfCharactersPerLine' in context) payload.writeBYTE(context['NumberOfCharactersPerLine']); else return payload.asBuffer();
		if ('SizeOfLineBuffer' in context) payload.writeBYTE(context['SizeOfLineBuffer']); else return payload.asBuffer();
		if ('NumericalPresentationOfaCharacter' in context) payload.writeBYTE(context['NumericalPresentationOfaCharacter']); else return payload.asBuffer();
		if ('ScreenTimeout' in context) payload.writeBYTE(context['ScreenTimeout']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['EscapeSequence'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['NumberOfLines'] = (_properties1 & 0x1f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['NumberOfCharactersPerLine'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SizeOfLineBuffer'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['NumericalPresentationOfaCharacter'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['ScreenTimeout'] = payload.readBYTE(); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x94 SIMPLE_AV_CONTROL COMMANDS
 */

// SIMPLE_AV_CONTROL [0x94] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x94].command[0x01] = {
	name: "SET",
	help: "Simple Av Control Set",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "KeyAttributes" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "ItemId" /* WORD */ }, 
		'0x03': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x03-0x00': {name: "Command" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('KeyAttributes' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if ('KeyAttributes' in context) _properties1 = _properties1 | ((context['KeyAttributes']) & 0x07);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 3) & 0xf8);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ItemId' in context) payload.writeWORD(context['ItemId']); else return payload.asBuffer();
		if ('VariableGroup' in context) {
			context['VariableGroup'].forEach(function(context) {
					if ('Command' in context) payload.writeWORD(context['Command']); else return payload.asBuffer();
			});
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['KeyAttributes'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xf8) >> 3; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ItemId'] = payload.readWORD(); else return context;
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['Command'] = payload.readWORD(); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		return context;
	}
};

// SIMPLE_AV_CONTROL [0x94] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x94].command[0x02] = {
	name: "GET",
	help: "Simple Av Control Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SIMPLE_AV_CONTROL [0x94] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x94].command[0x03] = {
	name: "REPORT",
	help: "Simple Av Control Report",
	param: { 
		'0x00': {name: "NumberOfReports" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfReports' in context) payload.writeBYTE(context['NumberOfReports']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfReports'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SIMPLE_AV_CONTROL [0x94] SUPPORTED_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x94].command[0x04] = {
	name: "SUPPORTED_GET",
	help: "Simple Av Control Supported Get",
	param: { 
		'0x00': {name: "ReportNo" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportNo' in context) payload.writeBYTE(context['ReportNo']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportNo'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SIMPLE_AV_CONTROL [0x94] SUPPORTED_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x94].command[0x05] = {
	name: "SUPPORTED_REPORT",
	help: "Simple Av Control Supported Report",
	param: { 
		'0x00': {name: "ReportNo" /* BYTE */ }, 
		'0x01': {name: "BitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportNo' in context) payload.writeBYTE(context['ReportNo']); else return payload.asBuffer();
		if ('BitMask' in context) payload.writeBITMASK(context['BitMask'], {length: 0}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportNo'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['BitMask'] = payload.readBITMASK({length: 0}); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x95 AV_CONTENT_DIRECTORY_MD COMMANDS
 */

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x01] = {
	name: "AV_CONTENT_BROWSE_MD_GET",
	help: "Av Content Browse Md Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x02] = {
	name: "AV_CONTENT_BROWSE_MD_REPORT",
	help: "Av Content Browse Md Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_BY_LETTER_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x03] = {
	name: "AV_CONTENT_BROWSE_MD_BY_LETTER_GET",
	help: "Av Content Browse Md By Letter Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_BY_LETTER_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x04] = {
	name: "AV_CONTENT_BROWSE_MD_BY_LETTER_REPORT",
	help: "Av Content Browse Md By Letter Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_CHILD_COUNT_GET [0x05] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x05] = {
	name: "AV_CONTENT_BROWSE_MD_CHILD_COUNT_GET",
	help: "Av Content Browse Md Child Count Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_CONTENT_BROWSE_MD_CHILD_COUNT_REPORT [0x06] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x06] = {
	name: "AV_CONTENT_BROWSE_MD_CHILD_COUNT_REPORT",
	help: "Av Content Browse Md Child Count Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_MATCH_ITEM_TO_RENDERER_MD_GET [0x07] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x07] = {
	name: "AV_MATCH_ITEM_TO_RENDERER_MD_GET",
	help: "Av Match Item To Renderer Md Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_DIRECTORY_MD [0x95] AV_MATCH_ITEM_TO_RENDERER_MD_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x95].command[0x08] = {
	name: "AV_MATCH_ITEM_TO_RENDERER_MD_REPORT",
	help: "Av Match Item To Renderer Md Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x96 AV_RENDERER_STATUS COMMANDS
 */

// AV_RENDERER_STATUS [0x96] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x96].command[0x01] = {
	name: "GET",
	help: "Av Renderer Status Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_RENDERER_STATUS [0x96] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x96].command[0x02] = {
	name: "REPORT",
	help: "Av Renderer Status Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x97 AV_CONTENT_SEARCH_MD COMMANDS
 */

// AV_CONTENT_SEARCH_MD [0x97] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x97].command[0x01] = {
	name: "GET",
	help: "Av Content Search Md Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_CONTENT_SEARCH_MD [0x97] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x97].command[0x02] = {
	name: "REPORT",
	help: "Av Content Search Md Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x98 SECURITY COMMANDS
 */

// SECURITY [0x98] COMMANDS_SUPPORTED_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x02] = {
	name: "COMMANDS_SUPPORTED_GET",
	help: "Security Commands Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY [0x98] COMMANDS_SUPPORTED_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x03] = {
	name: "COMMANDS_SUPPORTED_REPORT",
	help: "Security Commands Supported Report",
	param: { 
		'0x00': {name: "ReportsToFollow" /* BYTE */ }, 
		'0x01': {name: "CommandClassSupport", encaptype: "CMD_CLASS_REF" /* VARIANT */ }, 
		'0x02': null /* MARKER Mark handled by VARIANT */, 
		'0x03': {name: "CommandClassControl", encaptype: "CMD_CLASS_REF" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ReportsToFollow' in context) payload.writeBYTE(context['ReportsToFollow']); else return payload.asBuffer();
		if ('CommandClassSupport' in context) payload.writeBUFFERtoMARKER(context['CommandClassSupport'], { marker: [ 0xef ] }); else return payload.asBuffer();
		if ('CommandClassControl' in context) payload.writeBUFFER(context['CommandClassControl'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClassSupport'] = payload.readBUFFERtoMARKER({ marker: [ 0xef ] }); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClassControl'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// SECURITY [0x98] SCHEME_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x04] = {
	name: "SCHEME_GET",
	help: "Security Scheme Get",
	param: { 
		'0x00': {name: "SupportedSecuritySchemes" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedSecuritySchemes' in context) payload.writeBYTE(context['SupportedSecuritySchemes']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedSecuritySchemes'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY [0x98] SCHEME_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x05] = {
	name: "SCHEME_REPORT",
	help: "Security Scheme Report",
	param: { 
		'0x00': {name: "SupportedSecuritySchemes" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedSecuritySchemes' in context) payload.writeBYTE(context['SupportedSecuritySchemes']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedSecuritySchemes'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY [0x98] NETWORK_KEY_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x06] = {
	name: "NETWORK_KEY_SET",
	help: "Network Key Set",
	param: { 
		'0x00': {name: "NetworkKeyByte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NetworkKeyByte' in context) payload.writeSTRING(context['NetworkKeyByte'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NetworkKeyByte'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// SECURITY [0x98] NETWORK_KEY_VERIFY [0x07] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x07] = {
	name: "NETWORK_KEY_VERIFY",
	help: "Network Key Verify",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY [0x98] SCHEME_INHERIT [0x08] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x08] = {
	name: "SCHEME_INHERIT",
	help: "Security Scheme Inherit",
	param: { 
		'0x00': {name: "SupportedSecuritySchemes" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedSecuritySchemes' in context) payload.writeBYTE(context['SupportedSecuritySchemes']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedSecuritySchemes'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY [0x98] NONCE_GET [0x40] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x40] = {
	name: "NONCE_GET",
	help: "Security Nonce Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY [0x98] NONCE_REPORT [0x80] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x80] = {
	name: "NONCE_REPORT",
	help: "Security Nonce Report",
	param: { 
		'0x00': {name: "NonceByte" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NonceByte' in context) payload.writeSTRING(context['NonceByte'], { encoding: 'hex', length: 8 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NonceByte'] = payload.readSTRING({ encoding: 'hex', length: 8 }); else return context;
		return context;
	}
};

// SECURITY [0x98] MESSAGE_ENCAPSULATION [0x81] COMMAND 
COMMAND_CLASS.enum[0x98].command[0x81] = {
	name: "MESSAGE_ENCAPSULATION",
	help: "Security Message Encapsulation",
	param: { 
		'0x00': {name: "InitializationVectorByte" /* ARRAY */ }, 
		'0x01a': {name: "Sequenced" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SecondFrame" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "SequenceCounter" /* Properties1 STRUCT_BYTE */ }, 
		'0x01d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x04': {name: "CommandByte" /* VARIANT */ }, 
		'0x05': {name: "ReceiversNonceIdentifier" /* BYTE */ }, 
		'0x06': {name: "MessageAuthenticationCodeByte" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('InitializationVectorByte' in context) payload.writeSTRING(context['InitializationVectorByte'], { encoding: 'hex', length: 8 }); else return payload.asBuffer();
		if ('Sequenced' in context || 'SecondFrame' in context || 'SequenceCounter' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Sequenced']) _properties1 = _properties1 | 0x10;
			if (context['SecondFrame']) _properties1 = _properties1 | 0x20;
			if ('SequenceCounter' in context) _properties1 = _properties1 | ((context['SequenceCounter']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('CommandByte' in context) payload.writeSTRING(context['CommandByte'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('ReceiversNonceIdentifier' in context) payload.writeBYTE(context['ReceiversNonceIdentifier']); else return payload.asBuffer();
		if ('MessageAuthenticationCodeByte' in context) payload.writeSTRING(context['MessageAuthenticationCodeByte'], { encoding: 'hex', length: 8 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['InitializationVectorByte'] = payload.readSTRING({ encoding: 'hex', length: 8 }); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Sequenced'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SecondFrame'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SequenceCounter'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['CommandByte'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['ReceiversNonceIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MessageAuthenticationCodeByte'] = payload.readSTRING({ encoding: 'hex', length: 8 }); else return context;
		return context;
	}
};

// SECURITY [0x98] MESSAGE_ENCAPSULATION_NONCE_GET [0xc1] COMMAND 
COMMAND_CLASS.enum[0x98].command[0xc1] = {
	name: "MESSAGE_ENCAPSULATION_NONCE_GET",
	help: "Security Message Encapsulation Nonce Get",
	param: { 
		'0x00': {name: "InitializationVectorByte" /* ARRAY */ }, 
		'0x01a': {name: "Sequenced" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "SecondFrame" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "SequenceCounter" /* Properties1 STRUCT_BYTE */ }, 
		'0x01d': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x04': {name: "CommandByte" /* VARIANT */ }, 
		'0x05': {name: "ReceiversNonceIdentifier" /* BYTE */ }, 
		'0x06': {name: "MessageAuthenticationCodeByte" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('InitializationVectorByte' in context) payload.writeSTRING(context['InitializationVectorByte'], { encoding: 'hex', length: 8 }); else return payload.asBuffer();
		if ('Sequenced' in context || 'SecondFrame' in context || 'SequenceCounter' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Sequenced']) _properties1 = _properties1 | 0x10;
			if (context['SecondFrame']) _properties1 = _properties1 | 0x20;
			if ('SequenceCounter' in context) _properties1 = _properties1 | ((context['SequenceCounter']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 6) & 0xc0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('CommandByte' in context) payload.writeSTRING(context['CommandByte'], { encoding: 'hex' }); else return payload.asBuffer();
		if ('ReceiversNonceIdentifier' in context) payload.writeBYTE(context['ReceiversNonceIdentifier']); else return payload.asBuffer();
		if ('MessageAuthenticationCodeByte' in context) payload.writeSTRING(context['MessageAuthenticationCodeByte'], { encoding: 'hex', length: 8 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['InitializationVectorByte'] = payload.readSTRING({ encoding: 'hex', length: 8 }); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Sequenced'] = ((_properties1 & 0x10) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SecondFrame'] = ((_properties1 & 0x20) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['SequenceCounter'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xc0) >> 6; else return context;
		}
		if (!payload.insufficientBytes(1)) context['CommandByte'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		if (!payload.insufficientBytes(1)) context['ReceiversNonceIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['MessageAuthenticationCodeByte'] = payload.readSTRING({ encoding: 'hex', length: 8 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x99 AV_TAGGING_MD COMMANDS
 */

// AV_TAGGING_MD [0x99] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x99].command[0x01] = {
	name: "GET",
	help: "Av Tagging Md Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// AV_TAGGING_MD [0x99] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x99].command[0x02] = {
	name: "REPORT",
	help: "Av Tagging Md Report",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x9a IP_CONFIGURATION COMMANDS
 */

// IP_CONFIGURATION [0x9a] SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9a].command[0x01] = {
	name: "SET",
	help: "Ip Configuration Set",
	param: { 
		'0x00a': {name: "AutoDns" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "AutoIp" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "IpAddress" /* DWORD */ }, 
		'0x02': {name: "SubnetMask" /* DWORD */ }, 
		'0x03': {name: "Gateway" /* DWORD */ }, 
		'0x04': {name: "DNS1" /* DWORD */ }, 
		'0x05': {name: "DNS2" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('AutoDns' in context || 'AutoIp' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['AutoDns']) _properties1 = _properties1 | 0x01;
			if (context['AutoIp']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('IpAddress' in context) payload.writeDWORD(context['IpAddress']); else return payload.asBuffer();
		if ('SubnetMask' in context) payload.writeDWORD(context['SubnetMask']); else return payload.asBuffer();
		if ('Gateway' in context) payload.writeDWORD(context['Gateway']); else return payload.asBuffer();
		if ('DNS1' in context) payload.writeDWORD(context['DNS1']); else return payload.asBuffer();
		if ('DNS2' in context) payload.writeDWORD(context['DNS2']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['AutoDns'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AutoIp'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['IpAddress'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['SubnetMask'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Gateway'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DNS1'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DNS2'] = payload.readDWORD(); else return context;
		return context;
	}
};

// IP_CONFIGURATION [0x9a] GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x9a].command[0x02] = {
	name: "GET",
	help: "Ip Configuration Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// IP_CONFIGURATION [0x9a] REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x9a].command[0x03] = {
	name: "REPORT",
	help: "Ip Configuration Report",
	param: { 
		'0x00a': {name: "AutoDns" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "AutoIp" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "IpAddress" /* DWORD */ }, 
		'0x02': {name: "SubnetMask" /* DWORD */ }, 
		'0x03': {name: "Gateway" /* DWORD */ }, 
		'0x04': {name: "DNS1" /* DWORD */ }, 
		'0x05': {name: "DNS2" /* DWORD */ }, 
		'0x06': {name: "LeaseTime" /* DWORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('AutoDns' in context || 'AutoIp' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['AutoDns']) _properties1 = _properties1 | 0x01;
			if (context['AutoIp']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('IpAddress' in context) payload.writeDWORD(context['IpAddress']); else return payload.asBuffer();
		if ('SubnetMask' in context) payload.writeDWORD(context['SubnetMask']); else return payload.asBuffer();
		if ('Gateway' in context) payload.writeDWORD(context['Gateway']); else return payload.asBuffer();
		if ('DNS1' in context) payload.writeDWORD(context['DNS1']); else return payload.asBuffer();
		if ('DNS2' in context) payload.writeDWORD(context['DNS2']); else return payload.asBuffer();
		if ('LeaseTime' in context) payload.writeDWORD(context['LeaseTime']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['AutoDns'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['AutoIp'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['IpAddress'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['SubnetMask'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['Gateway'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DNS1'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['DNS2'] = payload.readDWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['LeaseTime'] = payload.readDWORD(); else return context;
		return context;
	}
};

// IP_CONFIGURATION [0x9a] RELEASE [0x04] COMMAND 
COMMAND_CLASS.enum[0x9a].command[0x04] = {
	name: "RELEASE",
	help: "Ip Configuration Release",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// IP_CONFIGURATION [0x9a] RENEW [0x05] COMMAND 
COMMAND_CLASS.enum[0x9a].command[0x05] = {
	name: "RENEW",
	help: "Ip Configuration Renew",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};



/*
 * COMMAND_CLASS 0x9b ASSOCIATION_COMMAND_CONFIGURATION COMMANDS
 */

// ASSOCIATION_COMMAND_CONFIGURATION [0x9b] COMMAND_RECORDS_SUPPORTED_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9b].command[0x01] = {
	name: "COMMAND_RECORDS_SUPPORTED_GET",
	help: "Command Records Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// ASSOCIATION_COMMAND_CONFIGURATION [0x9b] COMMAND_RECORDS_SUPPORTED_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x9b].command[0x02] = {
	name: "COMMAND_RECORDS_SUPPORTED_REPORT",
	help: "Command Records Supported Report",
	param: { 
		'0x00a': {name: "ConfCmd" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "VC" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "MaxCommandLength" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "FreeCommandRecords" /* WORD */ }, 
		'0x02': {name: "MaxCommandRecords" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('ConfCmd' in context || 'VC' in context || 'MaxCommandLength' in context) {
			let _properties1 = 0x00;
			if (context['ConfCmd']) _properties1 = _properties1 | 0x01;
			if (context['VC']) _properties1 = _properties1 | 0x02;
			if ('MaxCommandLength' in context) _properties1 = _properties1 | ((context['MaxCommandLength'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('FreeCommandRecords' in context) payload.writeWORD(context['FreeCommandRecords']); else return payload.asBuffer();
		if ('MaxCommandRecords' in context) payload.writeWORD(context['MaxCommandRecords']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['ConfCmd'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['VC'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MaxCommandLength'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['FreeCommandRecords'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['MaxCommandRecords'] = payload.readWORD(); else return context;
		return context;
	}
};

// ASSOCIATION_COMMAND_CONFIGURATION [0x9b] COMMAND_CONFIGURATION_SET [0x03] COMMAND 
COMMAND_CLASS.enum[0x9b].command[0x03] = {
	name: "COMMAND_CONFIGURATION_SET",
	help: "Command Configuration Set",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02': {name: "CommandLength" /* BYTE */ }, 
		'0x03': {name: "CommandClassIdentifier" /* BYTE */ }, 
		'0x04': {name: "CommandIdentifier" /* BYTE */ }, 
		'0x05': {name: "CommandByte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('CommandLength' in context) payload.writeBYTE(context['CommandLength']); else return payload.asBuffer();
		if ('CommandClassIdentifier' in context) payload.writeBYTE(context['CommandClassIdentifier']); else return payload.asBuffer();
		if ('CommandIdentifier' in context) payload.writeBYTE(context['CommandIdentifier']); else return payload.asBuffer();
		if ('CommandByte' in context) payload.writeSTRING(context['CommandByte'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClassIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandByte'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// ASSOCIATION_COMMAND_CONFIGURATION [0x9b] COMMAND_CONFIGURATION_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x9b].command[0x04] = {
	name: "COMMAND_CONFIGURATION_GET",
	help: "Command Configuration Get",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		return context;
	}
};

// ASSOCIATION_COMMAND_CONFIGURATION [0x9b] COMMAND_CONFIGURATION_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x9b].command[0x05] = {
	name: "COMMAND_CONFIGURATION_REPORT",
	help: "Command Configuration Report",
	param: { 
		'0x00': {name: "GroupingIdentifier" /* BYTE */ }, 
		'0x01': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x02a': {name: "First" /* Properties1 STRUCT_BYTE */ }, 
		'0x02b': {name: "ReportsToFollow" /* Properties1 STRUCT_BYTE */ }, 
		'0x02c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x03': {name: "CommandLength" /* BYTE */ }, 
		'0x04': {name: "CommandClassIdentifier" /* BYTE */ }, 
		'0x05': {name: "CommandIdentifier" /* BYTE */ }, 
		'0x06': {name: "CommandByte" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GroupingIdentifier' in context) payload.writeBYTE(context['GroupingIdentifier']); else return payload.asBuffer();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('First' in context || 'ReportsToFollow' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['First']) _properties1 = _properties1 | 0x80;
			if ('ReportsToFollow' in context) _properties1 = _properties1 | ((context['ReportsToFollow']) & 0x0f);
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 4) & 0x70);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('CommandLength' in context) payload.writeBYTE(context['CommandLength']); else return payload.asBuffer();
		if ('CommandClassIdentifier' in context) payload.writeBYTE(context['CommandClassIdentifier']); else return payload.asBuffer();
		if ('CommandIdentifier' in context) payload.writeBYTE(context['CommandIdentifier']); else return payload.asBuffer();
		if ('CommandByte' in context) payload.writeSTRING(context['CommandByte'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GroupingIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['First'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['ReportsToFollow'] = (_properties1 & 0x0f); else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x70) >> 4; else return context;
		}
		if (!payload.insufficientBytes(1)) context['CommandLength'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandClassIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandIdentifier'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['CommandByte'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x9c SENSOR_ALARM COMMANDS
 */

// SENSOR_ALARM [0x9c] GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9c].command[0x01] = {
	name: "GET",
	help: "Sensor Alarm Get",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_ALARM_SENSOR_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_ALARM_SENSOR_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SENSOR_ALARM_SENSOR_TYPE = {
	GeneralPurposeAlarm: 0x00, 
	SmokeAlarm: 0x01, 
	CoAlarm: 0x02, 
	Co2Alarm: 0x03, 
	HeatAlarm: 0x04, 
	WaterLeakAlarm: 0x05, 
	ReturnFirstAlarmOnSupportedList: 0xff, 
	enum: {
		0x00: "GeneralPurposeAlarm", 
		0x01: "SmokeAlarm", 
		0x02: "CoAlarm", 
		0x03: "Co2Alarm", 
		0x04: "HeatAlarm", 
		0x05: "WaterLeakAlarm", 
		0xff: "ReturnFirstAlarmOnSupportedList"
	}
};

// SENSOR_ALARM [0x9c] REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x9c].command[0x02] = {
	name: "REPORT",
	help: "Sensor Alarm Report",
	param: { 
		'0x00': {name: "zwave.NodeId", alias: "zwaveNodeId", encaptype: "NODE_NUMBER" /* BYTE */ }, 
		'0x01': {name: "SensorType" /* CONST */ }, 
		'0x02': {name: "SensorState" /* CONST */ }, 
		'0x03': {name: "Seconds" /* WORD */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.NodeId' in context) payload.writeBYTE(context['zwave.NodeId']); else return payload.asBuffer();
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_ALARM_SENSOR_TYPE)); else return payload.asBuffer();
		if ('SensorState' in context) payload.writeBYTE(helpers.getValue(context, 'SensorState', ENUM_SENSOR_ALARM_SENSOR_STATE)); else return payload.asBuffer();
		if ('Seconds' in context) payload.writeWORD(context['Seconds']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.NodeId'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_ALARM_SENSOR_TYPE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['SensorState'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_ALARM_SENSOR_STATE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Seconds'] = payload.readWORD(); else return context;
		return context;
	}
};

const ENUM_SENSOR_ALARM_SENSOR_STATE = {
	NoAlarm: 0x00, 
	Alarm: 0xff, 
	enum: {
		0x00: "NoAlarm", 
		0xff: "Alarm"
	}
};

// SENSOR_ALARM [0x9c] SUPPORTED_GET [0x03] COMMAND 
COMMAND_CLASS.enum[0x9c].command[0x03] = {
	name: "SUPPORTED_GET",
	help: "Sensor Alarm Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SENSOR_ALARM [0x9c] SUPPORTED_REPORT [0x04] COMMAND 
COMMAND_CLASS.enum[0x9c].command[0x04] = {
	name: "SUPPORTED_REPORT",
	help: "Sensor Alarm Supported Report",
	param: { 
		'0x00': {name: "NumberOfBitMasks" /* BYTE */ }, 
		'0x01': {name: "BitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('NumberOfBitMasks' in context) payload.writeBYTE(context['NumberOfBitMasks']); else return payload.asBuffer();
		if ('BitMask' in context) payload.writeBITMASK(context['BitMask'], {length: payload.at(0) & 0xff}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['NumberOfBitMasks'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['BitMask'] = payload.readBITMASK({length: payload.at(0) & 0xff}); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x9d SILENCE_ALARM COMMANDS
 */

// SILENCE_ALARM [0x9d] SENSOR_ALARM_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9d].command[0x01] = {
	name: "SENSOR_ALARM_SET",
	help: "Sensor Alarm Set",
	param: { 
		'0x00': {name: "Mode" /* CONST */ }, 
		'0x01': {name: "Seconds" /* WORD */ }, 
		'0x02': {name: "NumberOfBitMasks" /* BYTE */ }, 
		'0x03': {name: "BitMask" /* BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Mode' in context) payload.writeBYTE(helpers.getValue(context, 'Mode', ENUM_SILENCE_ALARM_SENSOR_ALARM_MODE)); else return payload.asBuffer();
		if ('Seconds' in context) payload.writeWORD(context['Seconds']); else return payload.asBuffer();
		if ('NumberOfBitMasks' in context) payload.writeBYTE(context['NumberOfBitMasks']); else return payload.asBuffer();
		if ('BitMask' in context) payload.writeBITMASK(context['BitMask'], {length: payload.at(2) & 0xff}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['Mode'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SILENCE_ALARM_SENSOR_ALARM_MODE.enum); else return context;
		if (!payload.insufficientBytes(1)) context['Seconds'] = payload.readWORD(); else return context;
		if (!payload.insufficientBytes(1)) context['NumberOfBitMasks'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['BitMask'] = payload.readBITMASK({length: payload.at(2) & 0xff}); else return context;
		return context;
	}
};

const ENUM_SILENCE_ALARM_SENSOR_ALARM_MODE = {
	DisableSoundingOfAllSensorAlarms: 0x00, 
	DisableSoundingOfAllSensorAlarmsIndependentOfBitMaskWhichHaveReceivedTheAlarm: 0x01, 
	DisableSoundingOfAllSensorAlarmsAccordingToBitMask: 0x02, 
	DisableSoundingOfAllSensorAlarmsAccordingToBitMaskWhichHaveReceivedTheAlarm: 0x03, 
	enum: {
		0x00: "DisableSoundingOfAllSensorAlarms", 
		0x01: "DisableSoundingOfAllSensorAlarmsIndependentOfBitMaskWhichHaveReceivedTheAlarm", 
		0x02: "DisableSoundingOfAllSensorAlarmsAccordingToBitMask", 
		0x03: "DisableSoundingOfAllSensorAlarmsAccordingToBitMaskWhichHaveReceivedTheAlarm"
	}
};



/*
 * COMMAND_CLASS 0x9e SENSOR_CONFIGURATION COMMANDS
 */

// SENSOR_CONFIGURATION [0x9e] SENSOR_TRIGGER_LEVEL_SET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9e].command[0x01] = {
	name: "SENSOR_TRIGGER_LEVEL_SET",
	help: "Sensor Trigger Level Set",
	param: { 
		'0x00a': {name: "Current" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Default" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "SensorType" /* CONST */ }, 
		'0x02a': {name: "Size" /* Properties2 STRUCT_BYTE */ }, 
		'0x02b': {name: "Scale" /* Properties2 STRUCT_BYTE */ }, 
		'0x02c': {name: "Precision" /* Properties2 STRUCT_BYTE */ }, 
		'0x03': {name: "TriggerValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('TriggerValue' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'TriggerValue', 'Precision', 'Size');
		if ('Current' in context || 'Default' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Current']) _properties1 = _properties1 | 0x40;
			if (context['Default']) _properties1 = _properties1 | 0x80;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved']) & 0x3f);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE)); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties2 = 0x00;
			if ('Size' in context) _properties2 = _properties2 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties2 = _properties2 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties2 = _properties2 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties2);
		} else return payload.asBuffer();;
		if ('TriggerValue' in context) payload.writeFLOATING(context['TriggerValue'], {size: payload.at(2) & 0x07, precision: (payload.at(2) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Current'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Default'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0x3f); else return context;
		}
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE.enum); else return context;
		{
			let _properties2 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties2 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties2 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties2 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['TriggerValue'] = payload.readFLOATING({size: payload.at(2) & 0x07, precision: (payload.at(2) & 0xe0) >> 5 }); else return context;
		return context;
	}
};

const ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE = {
	Temperature: 0x01, 
	GeneralPurposeValue: 0x02, 
	Luminance: 0x03, 
	Power: 0x04, 
	RelativeHumidity: 0x05, 
	Velocity: 0x06, 
	Direction: 0x07, 
	AtmosphericPressure: 0x08, 
	BarometricPressure: 0x09, 
	SolarRadiation: 0x0a, 
	DewPoint: 0x0b, 
	RainRate: 0x0c, 
	TideLevel: 0x0d, 
	enum: {
		0x01: "Temperature", 
		0x02: "GeneralPurposeValue", 
		0x03: "Luminance", 
		0x04: "Power", 
		0x05: "RelativeHumidity", 
		0x06: "Velocity", 
		0x07: "Direction", 
		0x08: "AtmosphericPressure", 
		0x09: "BarometricPressure", 
		0x0a: "SolarRadiation", 
		0x0b: "DewPoint", 
		0x0c: "RainRate", 
		0x0d: "TideLevel"
	}
};

// SENSOR_CONFIGURATION [0x9e] SENSOR_TRIGGER_LEVEL_GET [0x02] COMMAND 
COMMAND_CLASS.enum[0x9e].command[0x02] = {
	name: "SENSOR_TRIGGER_LEVEL_GET",
	help: "Sensor Trigger Level Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SENSOR_CONFIGURATION [0x9e] SENSOR_TRIGGER_LEVEL_REPORT [0x03] COMMAND 
COMMAND_CLASS.enum[0x9e].command[0x03] = {
	name: "SENSOR_TRIGGER_LEVEL_REPORT",
	help: "Sensor Trigger Level Report",
	param: { 
		'0x00': {name: "SensorType" /* CONST */ }, 
		'0x01a': {name: "Size" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "Scale" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Precision" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "TriggerValue" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if (('TriggerValue' in context) && !(('Precision' in context) && ('Size' in context))) helpers.updateFLOATINGSizePrecision(context, 'TriggerValue', 'Precision', 'Size');
		if ('SensorType' in context) payload.writeBYTE(helpers.getValue(context, 'SensorType', ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE)); else return payload.asBuffer();
		if ('Size' in context || 'Scale' in context || 'Precision' in context) {
			let _properties1 = 0x00;
			if ('Size' in context) _properties1 = _properties1 | ((context['Size']) & 0x07);
			if ('Scale' in context) _properties1 = _properties1 | ((context['Scale'] << 3) & 0x18);
			if ('Precision' in context) _properties1 = _properties1 | ((context['Precision'] << 5) & 0xe0);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('TriggerValue' in context) payload.writeFLOATING(context['TriggerValue'], {size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SensorType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE.enum); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Size'] = (_properties1 & 0x07); else return context;
			if (!payload.insufficientBytes(1)) context['Scale'] = (_properties1 & 0x18) >> 3; else return context;
			if (!payload.insufficientBytes(1)) context['Precision'] = (_properties1 & 0xe0) >> 5; else return context;
		}
		if (!payload.insufficientBytes(1)) context['TriggerValue'] = payload.readFLOATING({size: payload.at(1) & 0x07, precision: (payload.at(1) & 0xe0) >> 5 }); else return context;
		return context;
	}
};



/*
 * COMMAND_CLASS 0x9f SECURITY_2 COMMANDS
 */

// SECURITY_2 [0x9f] NONCE_GET [0x01] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x01] = {
	name: "NONCE_GET",
	help: "S2 Nonce Get",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] NONCE_REPORT [0x02] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x02] = {
	name: "NONCE_REPORT",
	help: "S2 Nonce Report",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "SOS" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "MOS" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "ReceiversEntropyInput" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('SOS' in context || 'MOS' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['SOS']) _properties1 = _properties1 | 0x01;
			if (context['MOS']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('ReceiversEntropyInput' in context) payload.writeSTRING(context['ReceiversEntropyInput'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['SOS'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['MOS'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['ReceiversEntropyInput'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] MESSAGE_ENCAPSULATION [0x03] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x03] = {
	name: "MESSAGE_ENCAPSULATION",
	help: "S2 Message Encapsulation",
	param: { 
		'0x00': {name: "SequenceNumber" /* BYTE */ }, 
		'0x01a': {name: "Extension" /* Properties1 STRUCT_BYTE */ }, 
		'0x01b': {name: "EncryptedExtension" /* Properties1 STRUCT_BYTE */ }, 
		'0x01c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x02': {name: "VariableGroup" /* VARIANT_GROUP */ }, 
				'0x02-0x00': {name: "ExtensionLength" /* BYTE */ },
				'0x02-0x01a': {name: "Critical" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x01b': {name: "MoreToFollow" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x01c': {name: "Type" /* Properties1 STRUCT_BYTE */ },
				'0x02-0x02': {name: "Extension" /* VARIANT */ }, 
		'0x03': {name: "CcmCiphertextObject" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SequenceNumber' in context) payload.writeBYTE(context['SequenceNumber']); else return payload.asBuffer();
		if ('Extension' in context || 'EncryptedExtension' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Extension']) _properties1 = _properties1 | 0x01;
			if (context['EncryptedExtension']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ((payload.at(1) & 0x01) !== 0) /* optional flag for VariableGroup */ {
			if ('VariableGroup' in context) {
				context['VariableGroup'].forEach(function(context) {
						if ('ExtensionLength' in context) payload.writeBYTE(context['ExtensionLength']); else return payload.asBuffer();
				if ('Critical' in context || 'MoreToFollow' in context || 'Type' in context) {
					let _properties1 = 0x00;
					if (context['Critical']) _properties1 = _properties1 | 0x40;
					if (context['MoreToFollow']) _properties1 = _properties1 | 0x80;
					if ('Type' in context) _properties1 = _properties1 | ((context['Type']) & 0x3f);
					payload.writeBYTE(_properties1);
				} else return payload.asBuffer();;
				if ('Extension' in context) payload.writeSTRING(context['Extension'], { encoding: 'hex', length: (payload.at(2) & 0xff) -2 }); else return payload.asBuffer();
				});
			} else return payload.asBuffer();;
		}
		if ('CcmCiphertextObject' in context) payload.writeSTRING(context['CcmCiphertextObject'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SequenceNumber'] = payload.readBYTE(); else return context;
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Extension'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['EncryptedExtension'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		let $variablegroup = []; 
		while (!(payload.insufficientBytes(1))) {
			let context = {};  // note inner scope shadowing of context
			if (!payload.insufficientBytes(1)) context['ExtensionLength'] = payload.readBYTE(); else return context;
			{
				let _properties1 = payload.readBYTE();
				if (!payload.insufficientBytes(1)) context['Critical'] = ((_properties1 & 0x40) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['MoreToFollow'] = ((_properties1 & 0x80) == 0) ? false : true; else return context;
				if (!payload.insufficientBytes(1)) context['Type'] = (_properties1 & 0x3f); else return context;
			}
			if (!payload.insufficientBytes(1)) context['Extension'] = payload.readSTRING({ encoding: 'hex', length: payload.at(2) & 0xff }); else return context;
			$variablegroup.push(context);
		};
		if (!payload.insufficientBytes(1)) context['VariableGroup'] = $variablegroup; else return context;
		if (!payload.insufficientBytes(1)) context['CcmCiphertextObject'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] KEX_GET [0x04] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x04] = {
	name: "KEX_GET",
	help: "KEX Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_2 [0x9f] KEX_REPORT [0x05] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x05] = {
	name: "KEX_REPORT",
	help: "KEX Report",
	param: { 
		'0x00a': {name: "Echo" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RequestCsa" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "SupportedKexSchemes" /* BYTE */ }, 
		'0x02': {name: "SupportedEcdhProfiles" /* BYTE */ }, 
		'0x03-0': {name: "Unauthenticated" /* RequestedKeys BITMASK */ }, 
		'0x03-1': {name: "Authenticated" /* RequestedKeys BITMASK */ }, 
		'0x03-2': {name: "Access" /* RequestedKeys BITMASK */ }, 
		'0x03-3': {name: "S0" /* RequestedKeys BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Echo' in context || 'RequestCsa' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Echo']) _properties1 = _properties1 | 0x01;
			if (context['RequestCsa']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SupportedKexSchemes' in context) payload.writeBYTE(context['SupportedKexSchemes']); else return payload.asBuffer();
		if ('SupportedEcdhProfiles' in context) payload.writeBYTE(context['SupportedEcdhProfiles']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_SECURITY_2_KEX_REQUESTED_KEYS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Echo'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RequestCsa'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SupportedKexSchemes'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SupportedEcdhProfiles'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_SECURITY_2_KEX_REQUESTED_KEYS.enum);
		return context;
	}
};

const ENUM_SECURITY_2_KEX_REQUESTED_KEYS = {
	Unauthenticated: 0x00, 
	Authenticated: 0x01, 
	Access: 0x02, 
	S0: 0x07, 
	enum: {
		0x00: "Unauthenticated", 
		0x01: "Authenticated", 
		0x02: "Access", 
		0x07: "S0"
	}
};

// SECURITY_2 [0x9f] KEX_SET [0x06] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x06] = {
	name: "KEX_SET",
	help: "KEX Set",
	param: { 
		'0x00a': {name: "Echo" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "RequestCsa" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "SelectedKexScheme" /* BYTE */ }, 
		'0x02': {name: "SelectedEcdhProfile" /* BYTE */ }, 
		'0x03-0': {name: "Unauthenticated" /* GrantedKeys BITMASK */ }, 
		'0x03-1': {name: "Authenticated" /* GrantedKeys BITMASK */ }, 
		'0x03-2': {name: "Access" /* GrantedKeys BITMASK */ }, 
		'0x03-3': {name: "S0" /* GrantedKeys BITMASK */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('Echo' in context || 'RequestCsa' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['Echo']) _properties1 = _properties1 | 0x01;
			if (context['RequestCsa']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('SelectedKexScheme' in context) payload.writeBYTE(context['SelectedKexScheme']); else return payload.asBuffer();
		if ('SelectedEcdhProfile' in context) payload.writeBYTE(context['SelectedEcdhProfile']); else return payload.asBuffer();
		payload.writeBITMASK(helpers.getFlagArray(context,  ENUM_SECURITY_2_KEX_REQUESTED_KEYS), {length: 1});
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['Echo'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['RequestCsa'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		if (!payload.insufficientBytes(1)) context['SelectedKexScheme'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SelectedEcdhProfile'] = payload.readBYTE(); else return context;
		helpers.setNameFlags(context, payload.readBITMASK({length: 1}), ENUM_SECURITY_2_KEX_REQUESTED_KEYS.enum);
		return context;
	}
};

// SECURITY_2 [0x9f] KEX_FAIL [0x07] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x07] = {
	name: "KEX_FAIL",
	help: "KEX Fail",
	param: { 
		'0x00': {name: "KexFailType" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('KexFailType' in context) payload.writeBYTE(helpers.getValue(context, 'KexFailType', ENUM_SECURITY_2_KEX_FAIL_KEX_FAIL_TYPE)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['KexFailType'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_2_KEX_FAIL_KEX_FAIL_TYPE.enum); else return context;
		return context;
	}
};

const ENUM_SECURITY_2_KEX_FAIL_KEX_FAIL_TYPE = {
	KexKey: 0x01, 
	KexScheme: 0x02, 
	KexCurves: 0x03, 
	Decrypt: 0x05, 
	Cancel: 0x06, 
	Auth: 0x07, 
	KeyGet: 0x08, 
	KeyVerify: 0x09, 
	KeyReport: 0x0a, 
	enum: {
		0x01: "KexKey", 
		0x02: "KexScheme", 
		0x03: "KexCurves", 
		0x05: "Decrypt", 
		0x06: "Cancel", 
		0x07: "Auth", 
		0x08: "KeyGet", 
		0x09: "KeyVerify", 
		0x0a: "KeyReport"
	}
};

// SECURITY_2 [0x9f] PUBLIC_KEY_REPORT [0x08] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x08] = {
	name: "PUBLIC_KEY_REPORT",
	help: "Public Key Report",
	param: { 
		'0x00a': {name: "IncludingNode" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }, 
		'0x01': {name: "EcdhPublicKey" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('IncludingNode' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['IncludingNode']) _properties1 = _properties1 | 0x01;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 1) & 0xfe);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		if ('EcdhPublicKey' in context) payload.writeSTRING(context['EcdhPublicKey'], { encoding: 'hex' }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['IncludingNode'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfe) >> 1; else return context;
		}
		if (!payload.insufficientBytes(1)) context['EcdhPublicKey'] = payload.readSTRING({ encoding: 'hex' }); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] NETWORK_KEY_GET [0x09] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x09] = {
	name: "NETWORK_KEY_GET",
	help: "S2 Network Key Get",
	param: { 
		'0x00': {name: "RequestedKey" /* CONST */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('RequestedKey' in context) payload.writeBYTE(helpers.getValue(context, 'RequestedKey', ENUM_SECURITY_2_KEX_REQUESTED_KEYS)); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['RequestedKey'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_2_KEX_REQUESTED_KEYS.enum); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] NETWORK_KEY_REPORT [0x0a] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0a] = {
	name: "NETWORK_KEY_REPORT",
	help: "S2 Network Key Report",
	param: { 
		'0x00': {name: "GrantedKey" /* CONST */ }, 
		'0x01': {name: "NetworkKey" /* ARRAY */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('GrantedKey' in context) payload.writeBYTE(helpers.getValue(context, 'GrantedKey', ENUM_SECURITY_2_KEX_REQUESTED_KEYS)); else return payload.asBuffer();
		if ('NetworkKey' in context) payload.writeSTRING(context['NetworkKey'], { encoding: 'hex', length: 16 }); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['GrantedKey'] = helpers.lookupNameValue(payload.readBYTE(), ENUM_SECURITY_2_KEX_REQUESTED_KEYS.enum); else return context;
		if (!payload.insufficientBytes(1)) context['NetworkKey'] = payload.readSTRING({ encoding: 'hex', length: 16 }); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] NETWORK_KEY_VERIFY [0x0b] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0b] = {
	name: "NETWORK_KEY_VERIFY",
	help: "S2 Network Key Verify",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_2 [0x9f] TRANSFER_END [0x0c] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0c] = {
	name: "TRANSFER_END",
	help: "S2 Transfer End",
	param: { 
		'0x00a': {name: "KeyRequestComplete" /* Properties1 STRUCT_BYTE */ }, 
		'0x00b': {name: "KeyVerified" /* Properties1 STRUCT_BYTE */ }, 
		'0x00c': {name: "Reserved" /* Properties1 STRUCT_BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('KeyRequestComplete' in context || 'KeyVerified' in context || 'Reserved' in context) {
			let _properties1 = 0x00;
			if (context['KeyRequestComplete']) _properties1 = _properties1 | 0x01;
			if (context['KeyVerified']) _properties1 = _properties1 | 0x02;
			if ('Reserved' in context) _properties1 = _properties1 | ((context['Reserved'] << 2) & 0xfc);
			payload.writeBYTE(_properties1);
		} else return payload.asBuffer();;
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		{
			let _properties1 = payload.readBYTE();
			if (!payload.insufficientBytes(1)) context['KeyRequestComplete'] = ((_properties1 & 0x01) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['KeyVerified'] = ((_properties1 & 0x02) == 0) ? false : true; else return context;
			if (!payload.insufficientBytes(1)) context['Reserved'] = (_properties1 & 0xfc) >> 2; else return context;
		}
		return context;
	}
};

// SECURITY_2 [0x9f] COMMANDS_SUPPORTED_GET [0x0d] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0d] = {
	name: "COMMANDS_SUPPORTED_GET",
	help: "S2 Commands Supported Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_2 [0x9f] COMMANDS_SUPPORTED_REPORT [0x0e] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0e] = {
	name: "COMMANDS_SUPPORTED_REPORT",
	help: "S2 Commands Supported Report",
	param: { 
		'0x00': {name: "zwave.CommandClass", alias: "zwaveCommandClass", encaptype: "CMD_CLASS_REF" /* VARIANT */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('zwave.CommandClass' in context) payload.writeBUFFER(context['zwave.CommandClass'], {}); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['zwave.CommandClass'] = payload.readBUFFER({}); else return context;
		return context;
	}
};

// SECURITY_2 [0x9f] CAPABILITIES_GET [0x0f] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x0f] = {
	name: "CAPABILITIES_GET",
	help: "S2 Capabilities Get",
	param: { /* no parameters */ },
	encode: function (context) { return Buffer.alloc(0) },
	decode: function (payload) { return {} }
};

// SECURITY_2 [0x9f] CAPABILITIES_REPORT [0x10] COMMAND 
COMMAND_CLASS.enum[0x9f].command[0x10] = {
	name: "CAPABILITIES_REPORT",
	help: "S2 Capabilities Report",
	param: { 
		'0x00': {name: "SupportedSpans" /* BYTE */ }, 
		'0x01': {name: "SupportedMpans" /* BYTE */ }
	},
	encode: function (context) {
		var payload = BufferStream.alloc();
		if ('SupportedSpans' in context) payload.writeBYTE(context['SupportedSpans']); else return payload.asBuffer();
		if ('SupportedMpans' in context) payload.writeBYTE(context['SupportedMpans']); else return payload.asBuffer();
		return payload.asBuffer();
	},
	decode: function (payload) {
		var context = {};  payload = BufferStream.from(payload);
		if (!payload.insufficientBytes(1)) context['SupportedSpans'] = payload.readBYTE(); else return context;
		if (!payload.insufficientBytes(1)) context['SupportedMpans'] = payload.readBYTE(); else return context;
		return context;
	}
};

module.exports.ENUM = {
	'APPLICATION_STATUS_APPLICATION_BUSY_STATUS': ENUM_APPLICATION_STATUS_APPLICATION_BUSY_STATUS,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE1': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE1,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_CONTROL': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_CONTROL,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_GENERAL': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_GENERAL,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_IRRIGATION': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_IRRIGATION,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_METER': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_METER,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_NOTIFICATION': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_NOTIFICATION,
	'ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_SENSOR': ENUM_ASSOCIATION_GRP_INFO_ASSOCIATION_GROUP_INFO_PROFILE2_PROFILE_SENSOR,
	'BARRIER_OPERATOR_SIGNAL_SUPPORTED_': ENUM_BARRIER_OPERATOR_SIGNAL_SUPPORTED_,
	'BARRIER_OPERATOR_STATE': ENUM_BARRIER_OPERATOR_STATE,
	'BATTERY_BATTERY_LEVEL': ENUM_BATTERY_BATTERY_LEVEL,
	'CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE': ENUM_CENTRAL_SCENE_SUPPORTED_SUPPORTED_KEY_ATTRIBUTES_FOR_SCENE,
	'CHIMNEY_FAN_ALARM_LOG_MESSAGE': ENUM_CHIMNEY_FAN_ALARM_LOG_MESSAGE,
	'CHIMNEY_FAN_SPEED': ENUM_CHIMNEY_FAN_SPEED,
	'CHIMNEY_FAN_STATE': ENUM_CHIMNEY_FAN_STATE,
	'CHIMNEY_FAN_STATE_REPORT_STATE': ENUM_CHIMNEY_FAN_STATE_REPORT_STATE,
	'CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE': ENUM_CLIMATE_CONTROL_SCHEDULE_SCHEDULE_OVERRIDE_OVERRIDE_STATE,
	'CONFIGURATION_PROPERTIES_FORMAT': ENUM_CONFIGURATION_PROPERTIES_FORMAT,
	'DCP_MONITOR_DCP_EVENT_STATUS': ENUM_DCP_MONITOR_DCP_EVENT_STATUS,
	'DOOR_LOCK_CONFIGURATION_OPERATION_TYPE': ENUM_DOOR_LOCK_CONFIGURATION_OPERATION_TYPE,
	'DOOR_LOCK_OPERATION_DOOR_LOCK_MODE': ENUM_DOOR_LOCK_OPERATION_DOOR_LOCK_MODE,
	'ENERGY_PRODUCTION_PARAMETER_NUMBER': ENUM_ENERGY_PRODUCTION_PARAMETER_NUMBER,
	'ENTRY_CONTROL_EVENT_SUPPORTED_DATA_TYPE_SUPPORTED_': ENUM_ENTRY_CONTROL_EVENT_SUPPORTED_DATA_TYPE_SUPPORTED_,
	'ENTRY_CONTROL_NOTIFICATION_DATA_TYPE': ENUM_ENTRY_CONTROL_NOTIFICATION_DATA_TYPE,
	'ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE': ENUM_ENTRY_CONTROL_NOTIFICATION_EVENT_TYPE,
	'FIRMWARE_UPDATE_MD_FIRMWARE_UPDATE_ACTIVATION_STATUS_FIRMWARE_UPDATE_STATUS': ENUM_FIRMWARE_UPDATE_MD_FIRMWARE_UPDATE_ACTIVATION_STATUS_FIRMWARE_UPDATE_STATUS,
	'FIRMWARE_UPDATE_MD_REQUEST_STATUS': ENUM_FIRMWARE_UPDATE_MD_REQUEST_STATUS,
	'FIRMWARE_UPDATE_MD_STATUS': ENUM_FIRMWARE_UPDATE_MD_STATUS,
	'HRV_CONTROL_MODE': ENUM_HRV_CONTROL_MODE,
	'HRV_CONTROL_MODE_SUPPORTED_MANUAL_CONTROL_SUPPORTED': ENUM_HRV_CONTROL_MODE_SUPPORTED_MANUAL_CONTROL_SUPPORTED,
	'HRV_STATUS_STATUS_PARAMETER': ENUM_HRV_STATUS_STATUS_PARAMETER,
	'HUMIDITY_CONTROL_MODE': ENUM_HUMIDITY_CONTROL_MODE,
	'HUMIDITY_CONTROL_OPERATING_STATE': ENUM_HUMIDITY_CONTROL_OPERATING_STATE,
	'HUMIDITY_CONTROL_SETPOINT_SCALE': ENUM_HUMIDITY_CONTROL_SETPOINT_SCALE,
	'HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE': ENUM_HUMIDITY_CONTROL_SETPOINT_SETPOINT_TYPE,
	'INCLUSION_CONTROLLER_COMPLETE_STATUS': ENUM_INCLUSION_CONTROLLER_COMPLETE_STATUS,
	'INCLUSION_CONTROLLER_INITIATE_STEP_ID': ENUM_INCLUSION_CONTROLLER_INITIATE_STEP_ID,
	'INDICATOR_INDICATOR_ID': ENUM_INDICATOR_INDICATOR_ID,
	'INDICATOR_PROPERTY_ID': ENUM_INDICATOR_PROPERTY_ID,
	'IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY': ENUM_IRRIGATION_SYSTEM_CONFIG_SENSOR_POLARITY,
	'IRRIGATION_SYSTEM_STATUS_SENSOR_STATUS': ENUM_IRRIGATION_SYSTEM_STATUS_SENSOR_STATUS,
	'IRRIGATION_SYSTEM_STATUS_SYSTEM_ERROR_STATUS': ENUM_IRRIGATION_SYSTEM_STATUS_SYSTEM_ERROR_STATUS,
	'IRRIGATION_VALVE_CONFIG_SENSOR_USAGE': ENUM_IRRIGATION_VALVE_CONFIG_SENSOR_USAGE,
	'IRRIGATION_VALVE_INFO_VALVE_ERROR_STATUS': ENUM_IRRIGATION_VALVE_INFO_VALVE_ERROR_STATUS,
	'LOCK_LOCK_STATE': ENUM_LOCK_LOCK_STATE,
	'MAILBOX_CONFIGURATION_MODE': ENUM_MAILBOX_CONFIGURATION_MODE,
	'MAILBOX_CONFIGURATION_SUPPORTED_MODES': ENUM_MAILBOX_CONFIGURATION_SUPPORTED_MODES,
	'MAILBOX_QUEUE_MODE': ENUM_MAILBOX_QUEUE_MODE,
	'MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_DATA_FORMAT': ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_DATA_FORMAT,
	'MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE': ENUM_MANUFACTURER_SPECIFIC_DEVICE_SPECIFIC_DEVICE_ID_TYPE,
	'METER_METER_TYPE': ENUM_METER_METER_TYPE,
	'METER_RATE_TYPE': ENUM_METER_RATE_TYPE,
	'METER_SUPPORTED_RATE_TYPE': ENUM_METER_SUPPORTED_RATE_TYPE,
	'METER_TBL_MONITOR_METER_TBL_PAY_METER': ENUM_METER_TBL_MONITOR_METER_TBL_PAY_METER,
	'MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE': ENUM_MTP_WINDOW_COVERING_MOVE_TO_POSITION_VALUE,
	'NETWORK_MANAGEMENT_BASIC_DEFAULT_SET_COMPLETE_STATUS': ENUM_NETWORK_MANAGEMENT_BASIC_DEFAULT_SET_COMPLETE_STATUS,
	'NETWORK_MANAGEMENT_BASIC_LEARN_MODE': ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE,
	'NETWORK_MANAGEMENT_BASIC_LEARN_MODE_SET_STATUS': ENUM_NETWORK_MANAGEMENT_BASIC_LEARN_MODE_SET_STATUS,
	'NETWORK_MANAGEMENT_BASIC_NETWORK_UPDATE_REQUEST_STATUS': ENUM_NETWORK_MANAGEMENT_BASIC_NETWORK_UPDATE_REQUEST_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REMOVE_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REMOVE_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REPLACE_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_FAILED_NODE_REPLACE_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_MODE': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_MODE,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_ADD_TX_OPTIONS,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_NEIGHBOR_UPDATE_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_NEIGHBOR_UPDATE_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_MODE': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_MODE,
	'NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_NODE_REMOVE_STATUS,
	'NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS': ENUM_NETWORK_MANAGEMENT_INCLUSION_RETURN_ROUTE_ASSIGN_COMPLETE_STATUS,
	'NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED': ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_LAST_WORKING_ROUTE_SPEED,
	'NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_STATISTICS_TYPE': ENUM_NETWORK_MANAGEMENT_INSTALLATION_MAINTENANCE_STATISTICS_TYPE,
	'NETWORK_MANAGEMENT_PRIMARY_CONTROLLER_CHANGE_MODE': ENUM_NETWORK_MANAGEMENT_PRIMARY_CONTROLLER_CHANGE_MODE,
	'NETWORK_MANAGEMENT_PROXY_NODE_INFO_CACHED_STATUS': ENUM_NETWORK_MANAGEMENT_PROXY_NODE_INFO_CACHED_STATUS,
	'NETWORK_MANAGEMENT_PROXY_NODE_LIST_STATUS': ENUM_NETWORK_MANAGEMENT_PROXY_NODE_LIST_STATUS,
	'NODE_INFO_BASIC_DEVICE_CLASS': ENUM_NODE_INFO_BASIC_DEVICE_CLASS,
	'NODE_INFO_MAX_BAUD_RATE': ENUM_NODE_INFO_MAX_BAUD_RATE,
	'NODE_INFO_PROTOCOL_VERSION': ENUM_NODE_INFO_PROTOCOL_VERSION,
	'NODE_INFO_SPEED_EXTENSION': ENUM_NODE_INFO_SPEED_EXTENSION,
	'NODE_INFO_ZWAVE_COMMAND_CLASS': ENUM_NODE_INFO_ZWAVE_COMMAND_CLASS,
	'NODE_INFO_ZWAVE_GENERIC_DEVICE': ENUM_NODE_INFO_ZWAVE_GENERIC_DEVICE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_APPLIANCE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_APPLIANCE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_AV_CONTROL_POINT': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_AV_CONTROL_POINT,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_DISPLAY': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_DISPLAY,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ENTRY_CONTROL': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ENTRY_CONTROL,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_GENERIC_CONTROLLER': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_GENERIC_CONTROLLER,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER_PULSE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_METER_PULSE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_NETWORK_EXTENDER': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_NETWORK_EXTENDER,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_REPEATER_SLAVE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_REPEATER_SLAVE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SECURITY_PANEL': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SECURITY_PANEL,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SEMI_INTEROPERABLE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SEMI_INTEROPERABLE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_ALARM': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_ALARM,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_BINARY': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_BINARY,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_MULTILEVEL': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_MULTILEVEL,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_NOTIFICATION': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SENSOR_NOTIFICATION,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_STATIC_CONTROLLER': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_STATIC_CONTROLLER,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_BINARY': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_BINARY,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_MULTILEVEL': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_MULTILEVEL,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_REMOTE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_REMOTE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_TOGGLE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_SWITCH_TOGGLE,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_THERMOSTAT': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_THERMOSTAT,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_VENTILATION': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_VENTILATION,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WALL_CONTROLLER': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WALL_CONTROLLER,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WINDOW_COVERING': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_WINDOW_COVERING,
	'NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ZIP_NODE': ENUM_NODE_INFO_ZWAVE_SPECIFIC_DEVICE_ZIP_NODE,
	'NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE': ENUM_NOTIFICATION_EVENT_SUPPORTED_NOTIFICATION_TYPE,
	'NOTIFICATION_NOTIFICATION_STATUS': ENUM_NOTIFICATION_NOTIFICATION_STATUS,
	'POWERLEVEL_POWER_LEVEL': ENUM_POWERLEVEL_POWER_LEVEL,
	'POWERLEVEL_TEST_NODE_STATUS_OF_OPERATION': ENUM_POWERLEVEL_TEST_NODE_STATUS_OF_OPERATION,
	'POWERLEVEL_TEST_NODE_ZWAVE_NODE_ID': ENUM_POWERLEVEL_TEST_NODE_ZWAVE_NODE_ID,
	'PREPAYMENT_BALANCE_BALANCE_TYPE': ENUM_PREPAYMENT_BALANCE_BALANCE_TYPE,
	'PROTECTION_TIMEOUT': ENUM_PROTECTION_TIMEOUT,
	'PROTECTION_TIMEOUT_REPORT_TIMEOUT': ENUM_PROTECTION_TIMEOUT_REPORT_TIMEOUT,
	'REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER': ENUM_REMOTE_ASSOCIATION_CONFIGURATION_LOCAL_GROUPING_IDENTIFIER,
	'REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID': ENUM_REMOTE_ASSOCIATION_CONFIGURATION_ZWAVE_NODE_ID,
	'SCENE_ACTIVATION_DIMMING_DURATION': ENUM_SCENE_ACTIVATION_DIMMING_DURATION,
	'SCENE_ACTUATOR_CONF_DIMMING_DURATION': ENUM_SCENE_ACTUATOR_CONF_DIMMING_DURATION,
	'SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION': ENUM_SCENE_ACTUATOR_CONF_REPORT_DIMMING_DURATION,
	'SCENE_CONTROLLER_CONF_DIMMING_DURATION': ENUM_SCENE_CONTROLLER_CONF_DIMMING_DURATION,
	'SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE': ENUM_SCHEDULE_COMMAND_SCHEDULE_RECURRENCE_MODE,
	'SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED': ENUM_SCHEDULE_ENTRY_LOCK_ENABLE_ENABLED,
	'SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION': ENUM_SCHEDULE_ENTRY_LOCK_WEEK_DAY_SET_ACTION,
	'SECURITY_2_KEX_FAIL_KEX_FAIL_TYPE': ENUM_SECURITY_2_KEX_FAIL_KEX_FAIL_TYPE,
	'SECURITY_2_KEX_REQUESTED_KEYS': ENUM_SECURITY_2_KEX_REQUESTED_KEYS,
	'SECURITY_PANEL_MODE': ENUM_SECURITY_PANEL_MODE,
	'SECURITY_PANEL_ZONE_STATE': ENUM_SECURITY_PANEL_ZONE_STATE,
	'SECURITY_PANEL_ZONE_TYPE': ENUM_SECURITY_PANEL_ZONE_TYPE,
	'SENSOR_ALARM_SENSOR_STATE': ENUM_SENSOR_ALARM_SENSOR_STATE,
	'SENSOR_ALARM_SENSOR_TYPE': ENUM_SENSOR_ALARM_SENSOR_TYPE,
	'SENSOR_BINARY_SENSOR_TYPE': ENUM_SENSOR_BINARY_SENSOR_TYPE,
	'SENSOR_BINARY_SENSOR_VALUE': ENUM_SENSOR_BINARY_SENSOR_VALUE,
	'SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE': ENUM_SENSOR_CONFIGURATION_SENSOR_TRIGGER_LEVEL_SENSOR_TYPE,
	'SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE': ENUM_SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE_SENSOR_TYPE,
	'SENSOR_MULTILEVEL_SUPPORTED_SENSOR_': ENUM_SENSOR_MULTILEVEL_SUPPORTED_SENSOR_,
	'SILENCE_ALARM_SENSOR_ALARM_MODE': ENUM_SILENCE_ALARM_SENSOR_ALARM_MODE,
	'SUPERVISION_STATUS': ENUM_SUPERVISION_STATUS,
	'SWITCH_ALL_MODE': ENUM_SWITCH_ALL_MODE,
	'SWITCH_BINARY_DURATION': ENUM_SWITCH_BINARY_DURATION,
	'SWITCH_BINARY_REPORT_DURATION': ENUM_SWITCH_BINARY_REPORT_DURATION,
	'SWITCH_BINARY_TARGET_VALUE': ENUM_SWITCH_BINARY_TARGET_VALUE,
	'SWITCH_MULTILEVEL_START_LEVEL_CHANGE_INC_DEC': ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_INC_DEC,
	'SWITCH_MULTILEVEL_START_LEVEL_CHANGE_UP_DOWN': ENUM_SWITCH_MULTILEVEL_START_LEVEL_CHANGE_UP_DOWN,
	'SWITCH_TOGGLE_BINARY_VALUE': ENUM_SWITCH_TOGGLE_BINARY_VALUE,
	'THERMOSTAT_FAN_MODE': ENUM_THERMOSTAT_FAN_MODE,
	'THERMOSTAT_FAN_MODE_SUPPORTED_': ENUM_THERMOSTAT_FAN_MODE_SUPPORTED_,
	'THERMOSTAT_FAN_STATE_FAN_OPERATING_STATE': ENUM_THERMOSTAT_FAN_STATE_FAN_OPERATING_STATE,
	'THERMOSTAT_HEATING_MODE': ENUM_THERMOSTAT_HEATING_MODE,
	'THERMOSTAT_HEATING_RELAY_STATUS': ENUM_THERMOSTAT_HEATING_RELAY_STATUS,
	'THERMOSTAT_HEATING_STATUS': ENUM_THERMOSTAT_HEATING_STATUS,
	'THERMOSTAT_MODE': ENUM_THERMOSTAT_MODE,
	'THERMOSTAT_MODE_SUPPORTED_': ENUM_THERMOSTAT_MODE_SUPPORTED_,
	'THERMOSTAT_OPERATING_STATE': ENUM_THERMOSTAT_OPERATING_STATE,
	'THERMOSTAT_SETBACK_SETBACK_STATE': ENUM_THERMOSTAT_SETBACK_SETBACK_STATE,
	'THERMOSTAT_SETPOINT_SETPOINT_TYPE': ENUM_THERMOSTAT_SETPOINT_SETPOINT_TYPE,
	'THERMOSTAT_SETPOINT_SUPPORTED_': ENUM_THERMOSTAT_SETPOINT_SUPPORTED_,
	'USER_CODE_USER_ID_STATUS': ENUM_USER_CODE_USER_ID_STATUS,
	'WINDOW_COVERING_PARAMETER_ID': ENUM_WINDOW_COVERING_PARAMETER_ID,
	'ZIP_GATEWAY_GATEWAY_MODE': ENUM_ZIP_GATEWAY_GATEWAY_MODE,
	'ZIP_ND_ZIP_NODE_ADVERTISEMENT_VALIDITY': ENUM_ZIP_ND_ZIP_NODE_ADVERTISEMENT_VALIDITY,
	'ZWAVEPLUS_INFO_NODE_TYPE': ENUM_ZWAVEPLUS_INFO_NODE_TYPE,
	'ZWAVEPLUS_INFO_ROLE_TYPE': ENUM_ZWAVEPLUS_INFO_ROLE_TYPE
};

/*
 * End of system-generated code
 */